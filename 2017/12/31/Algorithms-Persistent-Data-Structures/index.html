<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><title>「学习笔记」可持久化数据结构</title><link rel="shortcut icon" href="/images/avatar.png"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/highlight.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"></head><body><nav class="main-nav"><a href="/">Home</a><a href="/archives">Archives</a></nav><div class="profile"><section id="wrapper"><header id="header"><a href="/about"><img class="2x" id="avatar" src="/images/avatar.png"></a><h1>Cyanic's Blog</h1><h2></h2></header></section></div><section class="post" id="wrapper"><article><header><h1>「学习笔记」可持久化数据结构</h1><h2 class="headline">12月 31, 2017 11:59·1,618 words
·6 minutes read<span class="tags"></span></h2></header><div id="toc"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#可持久化线段树"><span class="toc-text">可持久化线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本思想"><span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#经典应用：区间K小值。"><span class="toc-text">经典应用：区间K小值。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一些好题"><span class="toc-text">一些好题</span></a></li></ol></li></ol></div><section id="post-body"><h3 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h3><p>常见的一个实现是主席树，由<code>HJT主席</code>引入中国OI界。</p>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>考虑一颗不同的线段树，进行单点修改。注意到每一次只会修改 $\log$ 个节点。</p>
<p>引入函数式编程的思想，我们不进行修改，而是新建节点。操作的时间复杂度仍然为 $O(log n)$，但是空间为 $O(n log n)$。</p>
<p>从第 $i$ 个根开始访问即可得到第 $i$ 次修改后的历史版本。</p>
<a id="more"></a>
<h4 id="经典应用：区间K小值。"><a href="#经典应用：区间K小值。" class="headerlink" title="经典应用：区间K小值。"></a>经典应用：区间K小值。</h4><p>考虑建立权值线段树，按照下标插入，$[l,r]$ 中，某个元素出现了多少遍，可以通过 $r$ 和 $l-1$ 版本的线段树作差得到。然后在主席树上二分即可。</p>
<h4 id="一些好题"><a href="#一些好题" class="headerlink" title="一些好题"></a>一些好题</h4><blockquote>
<p><strong>BZOJ1146-[CTSC2008]网络管理Network</strong> 维护一棵树，要求支持：单点修改权值，路径第 $K$ 大。<br>$n, Q \leq 80000$</p>
</blockquote>
<p><strong>树上带修改主席树，真·裸题。</strong> 首先这道题从2个log到4个log的算法都能过。话说<code>zzd Dalao</code>用了二分答案+树链剖分+主席树，竟然只比两个log慢4倍！</p>
<p>树上主席树有一个常见的套路：每一个节点的版本，都是在父节点的基础上修改。这样 $root[x] + root[y] - root[lca(x,y)] - root[fa[lca(x,y)]]$ 就得到这条链了。</p>
<p>再考虑这个带修改。注意到，一个点修改之后，只对它的子节点与外界的询问有影响。稍微分类讨论一下，就能发现，我们只需要修改子树中所有版本即可。</p>
<p>这个可以用树状数组套权值线段树解决。修改的时候，需要改变 $\log$ 个节点；查询的时候，也只需要考虑 $\log$ 个节点的贡献总和。</p>
<p>复杂度 $O(n \log ^ 2 n)$</p>
<blockquote>
<p><strong>BZOJ3674-可持久化并查集加强版</strong> 维护可持久化并查集。</p>
</blockquote>
<p><strong>可持久化数组。</strong> 注意到主席树就是一个可持久化数组，维护并查集的 $fa,rank$ ，按秩合并即可。</p>
<blockquote>
<p><strong>BZOJ2653-middle</strong> 给定一个长度为 $n$ 的序列，和若干个询问。每个询问 $(a,b,c,d)$ 要求求出 $l$ 在 $[a,b]$ 之间， $r$ 在 $[c,d]$ 之间的，构成的子序列的中位数的最大值。</p>
</blockquote>
<p><strong>二分答案，主席树，中位数。</strong>  中位数嘛，有一个常见的套路：二分答案 $x$ ，令所有小于 $x$ 为 $-1$，否则为 $1$ 。如果左后所有数之和大于等于 $0$ ，说明符合要求，可以继续变大。</p>
<p>这题同样也是二分答案。注意到，对于区间 $[b,c]$ 是一定要选择的。而对于 $[a,b-1]$ 和 $[c+1,d]$ 我们最好是选择一个最大的前缀和后缀。就是线段树最基础的维护了。</p>
<p>预处理主席树的时候，默认所有数都为 $1$ ，插入一个数之后，修改对应的位置为 $-1$ ，这样就能方便判断了。</p>
<blockquote>
<p><strong>BZOJ3545-[ONTAK2010]Peaks</strong> 给定一张图，每个点有点权，边有边权。查询 $(v,x,k)$ 要求回答：从 $x$ 出发，走边权不超过 $x$ 的边，能都到达的第 $k$ 大点权。</p>
</blockquote>
<p><strong>并查集虚拟点，dfs序，主席树。</strong> 显然，根据最小瓶颈树的理论，求出的最小生成树一定是最优的。</p>
<p>考虑按照边权从小到大插入。对于边 $(u,v)$ ，我们找到它们对应的祖先 $a,b$ 造一个虚拟点 $c$ 对应的点权是 $(u,v)$ 的边权。</p>
<p>这样有什么用处呢？发现对于点 $(x,y)$ ，他们的 $lca$ 对应的点权，就是从 $x$ 到 $y$ 需要经过路径最大值的最小值。</p>
<p>这样就可以搞出整棵，包含 $2n-1$ 个节点的树了。首先倍增预处理，对于 $v$ ，我们倍增向上跳到点 $u$，但是点权不能超过 $x$ ，那么， $v$ 能达到的点就是 $u$ 的子树！</p>
<p>dfs序预处理一下，然后就是区间K大了。</p>
<blockquote>
<p><strong>BZOJ3772-精神污染</strong> 给定一棵树，和若干条路径，求其中一条路径包含另一条路径的概率。</p>
</blockquote>
<p><strong>欧拉序，主席树。</strong> 确实是一道好题。注意到，这相当于求 <strong>一条路径的两个端点都在另一条路径上的方案数。</strong></p>
<p>考虑首先限制 $x$ 。对于 $(x,y)$，每个点建一棵主席树，$x$ 在父亲版本的基础上加入另一个端点 $y$。</p>
<p>对于查询路径上两个端点都被包含，相当于是路径上插入的另一个点也在路径上。</p>
<p>于是问题就转化为 <strong>统计路径上的点数之和。</strong></p>
<p>可以用欧拉序：保存一个节点入栈和出栈的时间。入栈的位置 $+1$ ,出栈的位置 $-1$。</p>
<p>有一个很神奇的性质：$(x,y)$ 之间的点数之和（$x,y$是祖先/后代关系），就是 $[in[x],in[y]]$之和（其他节点都没有计算，或者被抵消；其实就是 $(x,y)$当前还在栈中）。路径就拆成 $[x,lca],[lca,y],[lca,lca]$。</p>
<p>主要代码，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> o1, <span class="keyword">int</span> o2, <span class="keyword">int</span> o3, <span class="keyword">int</span> o4, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (l == x &amp;&amp; y == r) <span class="keyword">return</span> T[o1].sum + T[o2].sum - T[o3].sum - T[o4].sum;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</div><div class="line">	in[u] = ++clk;</div><div class="line">  ...</div><div class="line">	out[u] = ++clk;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</div><div class="line">	root[u] = root[fa[u][<span class="number">0</span>]];</div><div class="line">	loop (k, headV[u], linkV) &#123;</div><div class="line">		insert(root[u], <span class="number">1</span>, <span class="number">2</span>*n, in[v[k]], <span class="number">1</span>);</div><div class="line">		insert(root[u], <span class="number">1</span>, <span class="number">2</span>*n, out[v[k]], <span class="number">-1</span>);</div><div class="line">	&#125;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	rep (i, <span class="number">1</span>, m) &#123;</div><div class="line">		a[i] = read(); b[i] = read();</div><div class="line">		addEdge(headV, v, linkV, sizeV, a[i], b[i]);</div><div class="line">	&#125;</div><div class="line">	dfs1(<span class="number">1</span>);</div><div class="line">  ...</div><div class="line">	dfs2(<span class="number">1</span>);</div><div class="line">	rep (i, <span class="number">1</span>, m) &#123;</div><div class="line">		c = lca(a[i], b[i]);</div><div class="line">		ans += query(root[a[i]], root[b[i]], root[c], root[fa[c][<span class="number">0</span>]], <span class="number">1</span>, <span class="number">2</span>*n, in[c], in[a[i]]);</div><div class="line">		ans += query(root[a[i]], root[b[i]], root[c], root[fa[c][<span class="number">0</span>]], <span class="number">1</span>, <span class="number">2</span>*n, in[c], in[b[i]]);</div><div class="line">		ans -= query(root[a[i]], root[b[i]], root[c], root[fa[c][<span class="number">0</span>]], <span class="number">1</span>, <span class="number">2</span>*n, in[c], in[c]) + <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">  ...</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>BZOJ4546-[CodeChef]XRQRS</strong> 给定一个初始时为空的整数序列以及一些询问：<br>类型1：在数组后面就加入数字 $x$。<br>类型2：在区间 $[L,R]$ 中找到 $y$，最大化 $x xor y$。<br>类型3：删除数组最后 $K$个元素。<br>类型4：在区间 $[L,R]$ 中，统计小于等于 $x$ 的元素个数。<br>类型5：在区间 $[L,R]$ 中，找到第 $k$ 小的数。</p>
</blockquote>
<p><strong>可持久化Trie树。</strong> 本质上就是主席树，都是最基础的操作。需要注意的是操作 $2$ ，就是经典的 Trie树 上贪心。</p>
</section><nav id="post-nav"><span class="prev"><a href="/2017/12/31/Algorithms-Number-Theoretic-Function/"><span class="arrow">←</span>Newer Posts</a></span><span class="next"><a href="/2017/12/31/Algorithms-Flows/">Older Posts<span class="arrow">→</span></a></span></nav></article></section><footer id="footer"><div id="social"><a class="symbol" href="https://github.com/fuzhouxxdong"><i class="fa fa-github"></i></a></div><p class="small">© Copyright 2018 &nbsp;<i class="fa fa-heart" aria-hidden="true">&nbsp;Dxx</i></p><p class="small">Powered by &nbsp;<a href="https://hexo.io/">Hexo &nbsp;</a>Theme By &nbsp;<a href="https://github.com/fuzhouxxdong/hexo-theme-dxx">Dxx</a></p></footer></body></html>