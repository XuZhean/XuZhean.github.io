<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><title>「学习笔记」线段树进阶</title><link rel="shortcut icon" href="/images/avatar.png"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/highlight.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"></head><body><nav class="main-nav"><a href="/">Home</a><a href="/archives">Archives</a></nav><div class="profile"><section id="wrapper"><header id="header"><a href="/about"><img class="2x" id="avatar" src="/images/avatar.png"></a><h1>Cyanic's Blog</h1><h2></h2></header></section></div><section class="post" id="wrapper"><article><header><h1>「学习笔记」线段树进阶</h1><h2 class="headline">12月 31, 2017 11:59·2,873 words
·11 minutes read<span class="tags"></span></h2></header><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#线段树的高-chang-级-jian-应用"><span class="toc-text">线段树的高(chang)级(jian)应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#review"><span class="toc-text">review</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小清新线段树"><span class="toc-text">小清新线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-基于均摊复杂度的线段树"><span class="toc-text">A 基于均摊复杂度的线段树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-懒标记顺序-amp-标记回收"><span class="toc-text">B 懒标记顺序&标记回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-线段树与懒标记的变体"><span class="toc-text">C 线段树与懒标记的变体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zkw重口味线段树"><span class="toc-text">zkw重口味线段树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线段树合并"><span class="toc-text">线段树合并</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何优雅地使用set"><span class="toc-text">如何优雅地使用set</span></a></li></ol></li></ol></div><section id="post-body"><h1 id="线段树的高-chang-级-jian-应用"><a href="#线段树的高-chang-级-jian-应用" class="headerlink" title="线段树的高(chang)级(jian)应用"></a>线段树的高(chang)级(jian)应用</h1><a id="more"></a>
<h2 id="review"><a href="#review" class="headerlink" title="review"></a>review</h2><p>分治结构</p>
<p>懒标记</p>
<ul>
<li>可以快速合并</li>
<li>可以快速更新区间信息</li>
</ul>
<p>不满足懒标记性质的一些操作</p>
<ul>
<li>基于均摊复杂度</li>
</ul>
<hr>
<p>线段树优美的分治结构</p>
<p>从一道题引入</p>
<blockquote>
<p>有一个序列，每次在最后加上一个元素，询问区间Max</p>
<p>序列最后长度 $\leq 100000$</p>
<p>$Q \leq 10^7$</p>
</blockquote>
<p>预处理每个区间的前后缀max</p>
<p>对于询问区间 $[l,r]$</p>
<p>找到 $[l,r]$ 第一次分开的位置</p>
<p>左边的后缀max，右边的前缀max</p>
<p>可以做到 $O(1)$</p>
<p>考虑更新</p>
<p>加入一个元素的时候，更新一下前缀max</p>
<p>如果区间被插满了，算一下后缀max</p>
<h2 id="小清新线段树"><a href="#小清新线段树" class="headerlink" title="小清新线段树"></a>小清新线段树</h2><p>线段树的懒标记有很多神奇的用处</p>
<p>但是有些问题并不满足上述的性质</p>
<p><code>......</code></p>
<h4 id="A-基于均摊复杂度的线段树"><a href="#A-基于均摊复杂度的线段树" class="headerlink" title="A 基于均摊复杂度的线段树"></a>A 基于均摊复杂度的线段树</h4><p>来回顾区间加减，区间覆盖的一些神奇性质</p>
<p>区间加，区间覆盖 $\Rightarrow$ 区间内相对大小不变 <code>or</code> 相同</p>
<p>于是，对于</p>
<p>区间覆盖 $\Rightarrow$ 缩成一个点</p>
<p>区间加减 $\Rightarrow$ 差分</p>
<blockquote>
<p>CF438D 维护一个序列，滋瓷区间取模，单点修改，区间求和</p>
<p>$n,m \leq 10^5, a_i \leq 10^9$</p>
</blockquote>
<p>思考10min…</p>
<p>注意到，对于一个大于模数的数，</p>
<p>一次 $\bmod$ 之后，至多为原来大小的一半</p>
<p>直接暴力找最大值，暴力修改</p>
<p>复杂度 $O(m \log n \log a_i)$</p>
<blockquote>
<p>简单的加强，要求滋瓷区间覆盖</p>
</blockquote>
<p>思考5min…</p>
<p>考虑这样一种暴力的做法</p>
<p>维护区间 $\min, \max$ ，分几种情况讨论</p>
<ul>
<li>$\max &lt; m$ ，直接 return</li>
<li>$\min = \max$ ，直接区间覆盖</li>
</ul>
<p>思考：复杂度为什么是对的？</p>
<p>考虑将 <strong>相邻且相同的数字缩成同一个点</strong></p>
<p>再来看区间取模，可以注意到一次操作至多会增加 $2$ 个点</p>
<p>显然，每个大点定位的复杂度也是 $O(\log n)$ ，所以复杂度仍然不变</p>
<blockquote>
<p>我们从势能法角度来理解渐进时间复杂度分析，先简单介绍势能分析</p>
<p>势能分析常用于一类基于均摊的数据结构的时间复杂度</p>
<p>引入“势能”，把势能看作整个数据结构的一个状态函数</p>
<p>定义 $\Phi(i)$ 表示第 $i$ 次操作后，数据结构的势能</p>
<p>定义 $c_i$ 表示第 $i$ 次操作的实际时间花费</p>
<p>定义 $a_i$ 为第 $i$ 次操作的均摊时间花费</p>
<p>我们令</p>
<script type="math/tex; mode=display">\large a_i = c_i + \Phi(i) - \Phi(i-1) = c_i + \Delta \Phi(i)</script><p>显而易见地</p>
<script type="math/tex; mode=display">\large \sum a_i + \Phi(0) - \Phi(n) = \sum c_i</script><p>也就是说，只要我们确定了 $\sum a_i$ 与 $\Phi(0) - \Phi(n)$ 的上界</p>
<p>就能确定 $\sum c_i$ 的上界！</p>
<p>这里，我们不考虑常数问题</p>
<p>回到这一题，受之前的思路启发，我们定义（假设我们已经将相邻且相同的数字缩成一个点）</p>
<script type="math/tex; mode=display">\large \Phi(i)  = \log n \sum _ {i=1} ^ n \log x_i</script><p>考虑区间覆盖操作</p>
<script type="math/tex; mode=display">\large a_i \leq \log n + \log n \log x_i = O(\log n \log x_i)</script><p>考虑区间取模操作（假设我们对 $t$ 个点取模）</p>
<script type="math/tex; mode=display">\large a_i \leq t \log n - t \log n + 2 \log n \log x_i = O(\log n \log x_i)</script><p>（觉得这一步有锅？我们只要给势能函数乘以一个足够大的常数即可）</p>
<p>同时</p>
<script type="math/tex; mode=display">\large \Phi(0) - \Phi(n) \leq O(n \log n \log x_i)</script><p>所以</p>
<script type="math/tex; mode=display">\large T(n) = \sum c_i  = O(n \log n \log x_i)</script><p>我们可以发现，覆盖操作比较省时，在积累势能</p>
<p>而与此相对的，取模操作比较耗时，在消耗势能</p>
<p>势能分析的本质：</p>
<p>将多余的时间存储起来，在需要的时候使用 </p>
<p><del>抱歉，您在其他地方找不到这样的证明</del></p>
<p><del>因为全都是我yy的</del></p>
</blockquote>
<p>那么，该怎么写呢？</p>
<p><del>平衡树</del></p>
<p>线段树模版拓展</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> o, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, ...)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (cut(o, ..)) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> (l == x &amp;&amp; y == r &amp;&amp; check(o, ..)) &#123;</div><div class="line">        ... <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    pushdown(o);</div><div class="line">    <span class="keyword">if</span> (x &lt;= mid) update(lc, l, mid, x, min(mid, y), ...);</div><div class="line">    <span class="keyword">if</span> (mid &lt; y) update(rc, mid+<span class="number">1</span>, r, max(mid+<span class="number">1</span>, x), y, ...);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于这道题</p>
<p>$cut():\; \max(l,r) &lt; x$</p>
<p>$check():\;\max(l,r) = \min(l,r)$</p>
<hr>
<blockquote>
<p><strong>HDU5828 Rikka with Sequence = UOJ228</strong> 维护一个序列，滋瓷区间加减，区间开根号（下取整），询问区间和</p>
</blockquote>
<p>思考10min…</p>
<p>这类问题通常全局也难以解决，考虑从全局修改入手</p>
<p>注意到开根号几次就差不多全相同了（最多差 $1$ ）</p>
<p><code>3 4 -&gt; 1 2 -&gt; 3 4 -&gt; 1 2</code></p>
<p>于是，我们考虑</p>
<p>$check():\; \max(l,r) - \min(l,r) \leq 1$</p>
<p>直接变成区间减法 <code>or</code> 区间覆盖</p>
<p>还是分析复杂度</p>
<p>考虑差分，我们只取绝对值</p>
<p>注意到，我们只需要 $O(\log \log x_i)$ 就能让 $x_i$ 变为 $1$ </p>
<p>同样，我们也只需要经过这么多次，使得两个数的差分值小于 $2$</p>
<p>这启发我们定义势能函数：</p>
<script type="math/tex; mode=display">\large \Phi(i) = \log n \sum _ {i=1} ^{n-1} \log \log |x_i - x_{i-1}|</script><p>考虑区间加减</p>
<script type="math/tex; mode=display">\large a _ i = \log n + 2 \log n \log \log x_i = O(\log n \log \log x_i)</script><p>考虑区间开根（假设执行了 $t$ 段连续区间的减法）</p>
<script type="math/tex; mode=display">\large a_i = t \log n - (t-1) \log n + 2 \log n \log \log x_i = O(\log n \log \log x_i)</script><p>而 $\large \Phi(0) - \Phi(n) = O(n \log n \log \log x_i)$</p>
<p>…</p>
<p><del>口胡完毕</del></p>
<hr>
<p>通过这两道题，大概泥萌都已经掌握了势能分析？</p>
<p>在实际比赛的时候，可以考虑对暴力线段树<code>DFS</code>加入<code>cut,check</code> <del>或许会有意想不到的收获、</del></p>
<p><strong>exercise</strong></p>
<p><code>BZOJ 2130 魔塔</code></p>
<p><code>HDU 5634 Rikka with Phi</code></p>
<h4 id="B-懒标记顺序-amp-标记回收"><a href="#B-懒标记顺序-amp-标记回收" class="headerlink" title="B 懒标记顺序&amp;标记回收"></a>B 懒标记顺序&amp;标记回收</h4><p>普通的懒标记在线段树上的深度顺序是与时间相关的</p>
<p>利用标记的顺序，可以干一些奇怪的事情</p>
<p><code>......</code></p>
<p>一个小🌰</p>
<blockquote>
<p>区间取 $\max$，询问区间和</p>
</blockquote>
<p>我们考虑令所有标记值随着深度的增加而增加</p>
<p>每个点向上走，遇到的第一个标记就是它的历史最大值！</p>
<p>于是可以简单地维护区间和</p>
<p>如何让标记满足这样的顺序要求？</p>
<p>考虑标记回收</p>
<p>我们维护每一个子树内最小的标记值 $w$</p>
<p>在打上标记之后，根据 $w$ 的值暴力<code>DFS</code></p>
<p>删掉所有更小的标记</p>
<p>这样就可保证标记有序</p>
<p>回收标记的复杂度不超过打标记+标记下传</p>
<p>标记回收是一个巧妙的想法，关于这个东西更多的应用，可以参考吉老师的《Segment Tree Beats》与集训队论文</p>
<p><strong>exercise</strong></p>
<p><code>HDU5306 Gorgeous Sequence</code></p>
<h4 id="C-线段树与懒标记的变体"><a href="#C-线段树与懒标记的变体" class="headerlink" title="C 线段树与懒标记的变体"></a>C 线段树与懒标记的变体</h4><p>传统的线段树使用两个孩子的信息，来更新自己的信息</p>
<p>还有一些变体的问题，需要递归到某一个孩子内更新信息</p>
<blockquote>
<p><strong>Codechef STREETTA</strong> 区间对等差数列取 $\min$ ，询问单点值</p>
</blockquote>
<p>思考10min…</p>
<p>线段树维护半平面交？</p>
<p>考虑标记永久化，每个位置只放上一个标记</p>
<p>如何合并标记？</p>
<p>求出两个标记的分界点。分界点两边各是一个标记占优</p>
<p>那么一定有一个标记占优的部分是一个子树的一部分</p>
<p>把这个标记下传下去继续比较</p>
<p>至多 $O(\log n)$ 次比较</p>
<blockquote>
<p><a href="http://dsa.openjudge.cn/finalht2016/2/" target="_blank" rel="external">List</a> 询问一个区间形成的单调栈的大小 </p>
</blockquote>
<p>思考10min…</p>
<p>令 $getw(x,r)$ 为以 $r$ 的初值走到子树 $x$ 中会增加多少个数</p>
<p>$getw(x,r)=getw(lc,r)+getw(rc,max(\max[lc],r))$</p>
<p>发现可以预处理 $getw(rc,\max[lc])$</p>
<p>考虑一下复杂度</p>
<p>如果 $\max[lc] &lt; r$</p>
<p>$getw(lc, r) = 0$ ，我们只需要递归计算 $getw(rc, r)$</p>
<p>如果 $\max[lc] \geq r$</p>
<p>我们只需要递归计算 $getw(lc, r)$</p>
<p>总的复杂度为 $O(n \log ^2n)$</p>
<h2 id="zkw重口味线段树"><a href="#zkw重口味线段树" class="headerlink" title="zkw重口味线段树"></a>zkw重口味线段树</h2><p>讲道理这个东西只能用来卡常，没什么用？</p>
<p>单点加减，最值查询</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (M=<span class="number">1</span>; M&lt;=N+<span class="number">1</span>; M&lt;&lt;=<span class="number">1</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=M+<span class="number">1</span>; i&lt;=M+n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T[i]);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=M<span class="number">-1</span>; i&gt;=<span class="number">1</span>; i--) T[i] = T[i+i] + T[i+i+<span class="number">1</span>];</div><div class="line"><span class="keyword">for</span> (T[x+=M]=V, x&gt;&gt;=<span class="number">1</span>; x; x&gt;&gt;=<span class="number">1</span>)</div><div class="line">	T[x] = T[x+x] + T[x+x+<span class="number">1</span>];</div><div class="line"><span class="keyword">for</span> (s=s+M<span class="number">-1</span>, t=t+M+<span class="number">1</span>; s^t^<span class="number">1</span>; s&gt;&gt;=<span class="number">1</span>, t&gt;&gt;=<span class="number">1</span>) &#123;</div><div class="line">	<span class="keyword">if</span> (~s&amp;<span class="number">1</span>) ans += T[s^<span class="number">1</span>];</div><div class="line">	<span class="keyword">if</span> ( t&amp;<span class="number">1</span>) ans += T[t^<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>zkw线段树处理区间修改比较麻烦，往往需要标记永久化</p>
<p>对于区间加减，最值查询，我们可以考虑差分</p>
<p>zkw线段树的查询方式也可以来搞事情，我们来看一道题</p>
<blockquote>
<p>有一个 $N$ 片叶子的线段树，是他不是按照 $mid$ 分开的。所以树高不是 $O(logn)$ ，并且一个区间会被拆分成很多个区间。有 $Q$ 次询问，每次询问一个区间 $[l, r]$会被拆分成多少个小区间？</p>
<p>$n,Q \leq 100000$</p>
</blockquote>
<p>思考3min…</p>
<p>我们只要统计 $[l-1,lca)$ 路径上所有左儿子的右兄弟，$(lca,r+1]$ 路径上右儿子的左兄弟个数之和，倍增即可</p>
<h2 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h2><p>定义 <code>merge(a,b)</code></p>
<ul>
<li>如果 <code>a,b</code> 中有一个不含任何元素，就返回另一个</li>
</ul>
<ul>
<li>如果 <code>a,b</code> 都是叶子，返回 <code>merge_leaf(a,b)</code></li>
</ul>
<ul>
<li>返回 <code>merge(a-&gt;l,b-&gt;l)</code> 与 <code>merge(a-&gt;r,b-&gt;r)</code> 连接成的树</li>
</ul>
<p><strong>复杂度分析</strong></p>
<p>注意到一个性质，当且仅当两颗线段树在某个位置上都存在节点的时候，才会对时间复杂度产生 $O(1)$ 的贡献</p>
<p>显然，这相当于以 $O(1)$ 的时间复杂度删除一个节点</p>
<p>而一开始存在 $O(n \log n)$ 个节点</p>
<p><strong>有什么用？</strong></p>
<p>利用这种动态开点的值域线段树，可以解决一堆有序集合进行合并/分裂，同时查询<code>k</code>小的问题</p>
<p>两道经典题</p>
<p><code>BZOJ2212 [POI2011]Tree Rotations</code></p>
<p><code>BZOJ2733 [HNOI2010]永无乡 = BZOJ3545 [ONTAK2010]Peaks</code></p>
<blockquote>
<p><strong>BZOJ3307 雨天的尾巴</strong>  $n$ 个点，形成一个树。有 $m$ 次操作，每次选择两个点 $x,y$ 。对于 $x$ 到 $y$ 的路径上，每个点放一个 $z$。完成所有操作后，每个点存放最多的是哪个数字</p>
</blockquote>
<p>思考10min…</p>
<p>考虑差分？</p>
<p>差不多就是 $u,v,lca,fa[lca]$ 打标记</p>
<p>自底向上，线段树合并</p>
<p>没了。</p>
<p><strong>exercise</strong></p>
<p><code>BZOJ4730 Alice和Bob又在玩游戏</code></p>
<p><code>Szkopul</code>    <a href="https://szkopul.edu.pl/problemset/problem/f2dSBM7JteWHqtmVejMWe1bW/site/?key=statement" target="_blank" rel="external"><code>[ONTAK2010]Zadanie Autostrady</code></a></p>
<h2 id="如何优雅地使用set"><a href="#如何优雅地使用set" class="headerlink" title="如何优雅地使用set"></a>如何优雅地使用set</h2><blockquote>
<p>你有 $n$ 个墙，第 $i$ 个墙的高度为 $a_i$，给你 $Q$ 个操作</p>
<p>$P$，询问当前墙的状态下最多能存储多少水</p>
<p>$U, x, v\;(v&gt;0)$ ，$a_x += v$</p>
<p><img src="1.jpg" alt="1"></p>
</blockquote>
<p>思考15min…</p>
<p>可以强行把墙当作水，发现这是单峰的</p>
<p>对于两边，我们都维护一下单调性</p>
<p>可以用线段树区间修改，比较无脑</p>
<p>区间最值操作？</p>
<p>利用单调性，记录区间最大/最小，暴力 <code>DFS</code></p>
<p>复杂度？</p>
<p>当然更好的是用 <code>set</code> </p>
<p>简单易懂</p>
<p>（数据在 <code>prob</code> 文件夹里）</p>
<blockquote>
<p><strong>LOJ#546. 「LibreOJ β Round #7」网格图</strong> 给定一张 $n \times m$ 的网格图，行标号 $1$ 到 $n$，列标号为 $1$ 到 $m$，网格图上设置了 $k$ 个障碍。</p>
<p>一个机器人在网格图中行走，初始时它位于位置 $s$，每一时刻他有三种行动方式</p>
<ul>
<li>如果自己面向的方向不是障碍或网格的边缘，向该方向前进一格。</li>
<li>向左（逆时针）转四分之一周。</li>
<li>向右（顺时针）转四分之一周。</li>
</ul>
<p>初始时机器人可以选择面向任意一个方向</p>
<p>现在有 $Q$ 个询问，每个询问给定一个终点 $t_i$，请你求出他从 $s$ 到 $t_i$ 最少需要的转向次数，每次选择的初始方向可以不同。</p>
<p>$k \leq 50000, Q \leq 10^5$</p>
</blockquote>
<p>思考15min…</p>
<p>一个简单的图论建模：</p>
<p>将被障碍分开的若干个连续网格看作一个点，两个点交叉，加一条边权为 $1$ 的边</p>
<p><del>暴力BFS</del></p>
<p>考虑数据结构优化，有两个方向</p>
<p>线段树套 <code>set</code> 优化 <code>BFS</code>，我的做法，复杂度两只 <code>log</code></p>
<p>主席树上建图，复杂度一只 <code>log</code></p>
<p>大致做法：主席树预处理，树边边权为 $0$ </p>
<p>每个点只会连 $\log$ 条边，边权为 $0$， 跑<code>BFS</code></p>
</section><nav id="post-nav"><span class="prev"><a href="/2017/12/31/Algorithms-Flows/"><span class="arrow">←</span>Newer Posts</a></span><span class="next"><a href="/2017/12/31/Algorithms-Calculous/">Older Posts<span class="arrow">→</span></a></span></nav></article></section><footer id="footer"><div id="social"><a class="symbol" href="https://github.com/fuzhouxxdong"><i class="fa fa-github"></i></a></div><p class="small">© Copyright 2018 &nbsp;<i class="fa fa-heart" aria-hidden="true">&nbsp;Dxx</i></p><p class="small">Powered by &nbsp;<a href="https://hexo.io/">Hexo &nbsp;</a>Theme By &nbsp;<a href="https://github.com/fuzhouxxdong/hexo-theme-dxx">Dxx</a></p></footer></body></html>