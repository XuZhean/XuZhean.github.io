[{"title":"POI切题记","date":"2017-11-13T02:00:00.000Z","path":"2017/11/13/POI/","text":"似乎POI的质量挺高的？蒟蒻也要开始做辣，就从POI2000(7th)开始啦。 POI 2000 (2017.11.13~)","tags":[{"name":"切题","slug":"切题","permalink":"https://xuzhean.github.io/tags/切题/"}]},{"title":"NOIP2017总复习","date":"2017-10-27T12:00:00.000Z","path":"2017/10/27/Contest-NOIP2017/","text":"基础搜索折半搜索。状态可合并（有时配合组合计数/指针单调扫描）。 模拟贪心等价性的利用。经典模型：蚂蚁相撞后各自掉头，等价于彼此穿过。 行列无关。 分别处理。 一个点到所有点的距离最短。中位数。 二分二分答案。转化为判定性问题，常与贪心，DP结合。 三分构造离散化扫描线常与线段树结合。POJ1177。 前缀和&amp;差分两者往往相互转化。修改区间的前缀和/差分值，等价于交换/修改单点的前缀和/差分值。 序列的差分。 倍增NOIP的常考点。可以优化为$\\log$或去掉一个$\\log$。 优化答案合并。假设现在有问题$f(N)$，如果我们可以通过$f(A)$和$f(B)$快速求出$f(A+B)$，则我们就可以倍增。二进制拆分为$\\log$个答案，再合并就是最终答案。 优化二分。对于一些具有单调性的问题，我们可以二分答案，再用倍增求，复杂度$O(\\log n \\log n)$ 。事实上可以用倍增优化二分，复杂度降到$O(\\log n)$ 。 假设二分的区间是$[0,n]$，设$m = \\log n$。 设答案$ans$一开始为$0$，先检验$ans+2^m$是否满足条件，如果满足则让$ans+=2^m$。 之后让$m–1$，一直做到$m=0$为止。 正确性显然，相当于二进制逐位确定最终的$ans$。 离线分块整除形式的分块。取整后的值只有$O(\\sqrt{n} )$个。 优化暴力。往往是把两种暴力合并，适用于询问大小不同的情况。或者总量确定，大于$O(\\sqrt n)$的不超过$O(\\sqrt n)$。 打表分段打表。 防止表过大。 位运算相关异或。 异或两次相当于不操作。 前缀和。 相当于不进位的加法，$a+b = a \\oplus b + 2 \\times a \\&amp; b$ 归并合并有序相邻。 STLbitset。优化$01$矩阵运算等。 动态规划概述改变阶段。使得不存在后效性。 滚动数组。小心MLE 分成两次DP。LA4394。 记录决策路径。DFS输出方案。 bool类型作为DP的值。标记状态是否可能到达。（POJ2134） 未来费用。提前计算。 正序与逆序。互相转化。 减去非法转移。 容斥。 普通/背包DP单调队列优化多重背包DP。POJ3260 序列/区间/环形DP线段树优化。优化区间修改，最值查询。（同一阶段的所有状态用线段树维护） 区间元素种类个数。记录上一次出现位置。 前缀和。前缀和优化DP。 状压DP预处理转移。 暴力枚举子集。 $for\\ (int\\ i=S;\\ i;\\ i=(i-1)\\ \\&amp;\\ S)$，复杂度变为$O(3^n)$。 转移时顺序无关。强制转移$lowbit$。 树形DP求以所有节点为根时的解。DFS时，父节点向子节点转移信息。 背包DP转移。从子节点转移到父节点，使用背包DP。 二叉树。转化为序列的DP。 数位DPDFS通用模版。 注意前缀0。 环套树DPDFS找基环。 图论线段树优化建图。 从二元关系联系到图。 图的遍历拓扑排序字典序最小。优先队列优化。 图的连通性DFS树。逆向边，横向边… 强连通分量缩点。原图变为DAG，在此基础上进行拓扑排序。 最短路Dijksta堆优化。滋瓷次短路。 附加状态，建立最短路模型。 经典模型：判断一个数$n$能否由若干个给定的数线性叠加得到。以最小的数$a0$为模，最短路求余数为$i$的能够组成的最小的数。（BZOJ2118） 分层图最短路。 判断一条边是否属于最短路。最短路不等式取等。 差分约束系统。列出所有不等式（等价于最短路不等式），连边。SPFA求解，无解存在负环/正环。有时需要二分答案，注意需要满足二分的前提（POJ1275）。 状态图非DAG上的DP。使用SPFA的思想，迭代逼近最优解。 最小生成树Prim。似乎没用。 Kruskal。从小到大加边，并查集维护连通性。 次小生成树。预处理最小生成树，构造倍增数组，求路径最值。 最小生成树=最小瓶颈树。 树相关直径，重心直径。树中最长的路径，通过两次$BFS$得到。 树的直径并不唯一，但是直径的中点都是一样的。 直径合并：对于两棵树$T,S$，任取他们的直径$(Ta,Tb)$，$(Sa,Sb)$。假设现在有一条边连接了$T$和$S$，构成了新的树$M$，那么$(Ta,Tb,Sa,Sb)$这四个点中一定能选出两个点$u,v$，使得$(u,v)$是$M$的一条直径。 对于一些要你在树上选两个点的题，可以先打表看看，很大概率是选在直径上最优。 重心。定义一个点的重量是去掉它之后树的最大的联通块的大小。我们将一棵树中重量最小的点称为重心（小于等于$size$即可满足）。 一棵树最多只有两个重心。 DFS序时间戳。树在进行$DFS$时，进入子树的时间$in[u]$和$out[u]$。 祖先关系判断。$y$在$x$的子树中的充要条件是：$in[x] \\leq in[y] \\leq out[y] \\leq out[x]$。 转化为区间维护问题。用树状数组或线段树维护即可。 LCATarjan。离线，并查集辅助。$O(n+Q)$。 树链剖分树上差分优化链修改。拆分为$u \\rightarrow lca, lca \\rightarrow v$,需要离线。BZOJ3631。 DFS前后贡献作差。用同维护总贡献，作差算出子树贡献。NOIP2016D1T2。 树上倍增数学小技巧调和级数。$\\large \\sum _{i=1} ^{n} \\frac 1 i = \\ln (n+1) + γ$，常用于估算时间复杂度。 整数分块。整除时，枚举商。 快速乘。相乘爆$long\\ long$时，使用$O(\\log n)$的快速乘。 莫比乌斯函数。容斥系数。 约数个数上界。目前没有比较好容易算的上界。只要记一下实际数字QAQ，大致如下： $10^9$，约为$10^3$ $10^{13}$，约为$10^4$ $10^{18}$，约为$10^5$ 数论GCD的性质 若$x$与$y$互质，则$x+ky$与$y$互质。BZOJ2186。 不断对某个数取gcd，得到不同的值最多有$O( \\log)$个。 逆元 必须与模数互质。 扩展GCD，求解。 费马小定理，快速幂$power(x,MOD-2)$。需要保证$MOD$是质数。 线性递推求逆元： 设，$ki+r\\equiv 0\\pmod p$ 那么，$kr^{-1}+i^{-1} \\equiv 0 \\pmod p$ 移项，$i^{-1}≡-kr^{-1} \\pmod p$ 于是，$i^{-1} \\equiv - \\lfloor \\frac p i \\rfloor \\times (p\\%i)^{-1} \\pmod p$ 结论；$rev[i] = -(p/i) \\times rev[p\\%i]\\ \\%\\ p$ 欧拉函数积性函数。对于两个互质的数$n,m$,有$\\varphi(nm) = \\varphi(n) \\times \\varphi(m)$。 $\\varphi(n) = n \\times (1- \\frac 1 {p[1]}) \\times .. \\times (1- \\frac 1 {p[k]})$ 欧拉筛Lucas定理及扩展形式若模数$p$是质数，那么$C(n,m)=C(n/p,m/p) \\times C(n\\%p,m\\%p) \\bmod p$ 适用于模数较小，且$n,m$较大时的计算。 中国剩余定理及扩展形式基本结论： 扩展形式。模数不互质。合并同余方程组。 BSGS求$a^x \\equiv b \\pmod p$的最小解。 显然$x&lt;p$，每次令$x$增加$\\sqrt p$。$exgcd$求出$a^{k\\sqrt p+y} \\equiv b \\pmod p$的$a^y$，从预处理过的$HASH$表中查找即可。 组合计数补集转换。方便计算。 组合数相关$C(i,j)=C(i-1,j-1)+C(i-1,j)$，预处理组合数。 容斥原理。 形式一：所有条件必须满足。加上全集，减去至少一个条件不合法的，加上至少两个不合法的… 形式二：至少满足一个条件。加上至少满足一个的（会多次计算），减去满足两个的… 适用于概率的计算。 暴力状压枚举/DP计算。 矩阵相关不满足交换率。注意乘法顺序！ 矩阵快速幂。优化线性递推。 循环矩阵。相乘后仍然是循环矩阵。只需保存第一行，乘法复杂度$O(n^2)$。BZOJ2510 Floyd矩阵。求$K$步后点对的最短路。满足结合律，故可以快速幂。 概率论全概率，全期望公式。分类。 数学期望的线性性。$E(kx+b)=kE(x)+b$。期望可线性叠加。 树上的概率/期望问题，且与父节点/根节点相关。序列上的问题，与某一个位置相关。列方程求解（待定系数）。HDU4089.4035,ZOJ3329。 DP。概率顺推，期望逆推。 图上的期望/概率问题。联立方程组，高斯消元。 博弈论SG函数必输态为$0$，否则为非$0$。$SG(u)=mex{SG(v)}$，状态$u$能到达状态$v$。 组合游戏的和若干个不不相关的组合游戏，总的$SG$等于各个字游戏$SG$的$xor$和。 打表。无法找出规律时，打表SG，找出规律。往往都是递归形式的。 暴力DP。 置换分解为若干个循环。每个循环是一个独立的环。置换的周期为所有环长的$lcm$。 求若干次之后的置换。倍增。 数据结构基准值。需要增加全局的数（或除去某个数），维护一个全局增量$\\Delta$。 栈，队列单调栈。维护单调性。应用： 求出一个数左/右第一个比这个数大/小的数。 单调队列。维护队列单调性，转移限制距离，从队首弹出。常用于优化DP。 并查集带权并查集。 维护与祖先的关系，路径压缩时合并。 时光倒流。支持分离。 按秩合并。保证树高$O( \\log)$，不改变树的形态。支持删除，暴力上爬。常数很小！ 优先队列配合贪心，支持反悔操作。通过加入新收益-旧收益到堆中。有时配合双向链表。51Nod1380。 HASHMAP/链表存储。映射到范围更小的值，插入链表。 集合的HASH。把所有数据都$xor$起来，这种方法适用于数据不需要维持相对顺序的时候，要求元素互异。另一种做法是利用$seed$的幂次，支持多重集合。 序列的HASH。转化成一个$seed$进制下的数模一个质数的值，是可以支持询问一个区间的值，拼接若干区间，以及插入，删除，修改之后的全局/区间询问。 双模数HASH。当极易产生冲突时，使用两个模数校验。 树状数组求逆序对。 二维树状数组。外层再增加一个循环即可。 点查询与前缀修改。一般的树状数组能够支持点修改，前缀查询。通过改变$i$更新方向，可以交换询问和修改。（维护和时，也可以差分）。 树状数组上倍增。 动态第$K$大。 线段树线段树分治结构利用。 均摊复杂度分析。看似暴力的做法，复杂度正确。 一些模型。 维护等差数列：首项，末项，公差。HDU3340。 保存前缀，后缀信息。 标记的奇妙合并。覆盖，等价性合并。BZOJ1858。 ST表支持$O(n\\log n)$的倍增预处理，$O(1)$离线查询。 字符串KMP最小周期串。$n-next[n-1]$。 把匹配位置作为状态的DP。 Tire与位运算结合。贪心地在Tire树上跑。 AC自动机配合DP。以位置作为状态（可以矩阵快速幂优化），有时配合状压记录是否访问病毒串。 fail指针。反向建树。BZOJ2434。 LCPHAHS+二分。 计算几何基础知识叉积，点积有向面积。向量构成的有向面积是叉积的一半。 判断两条线段是否相交。叉积判断。 凸包","tags":[{"name":"复习","slug":"复习","permalink":"https://xuzhean.github.io/tags/复习/"}]},{"title":"「学习笔记」网络流相关","date":"2017-10-05T10:00:00.000Z","path":"2017/10/05/Algorithms-Flows/","text":"前言今年NOIP2017提高的初赛考到的最小割。这是否意味着网络流进入NOIP考纲？ 蒟蒻Cyani发现，周围的同学都会网络流啊。蒟蒻也来学一学姿势。 比较推荐LRJ的蓝书，胡伯涛的论文，关于模版和建模有比较详细的讲解。 听说CF的网络流质量挺高的？ 还有BZOJ的网络流。 为了使叙述更加易懂，本文尽可能减少数学符号的使用。 前置技能最大流每次找到最短增广路径，最坏增广$O(nm)$次。所以时间复杂度取决于找最短增广路径的时间复杂度。 EK算法。直接暴力$BFS$，复杂度$O(nm^2)$。 Dinic算法。按照起点到$u$的距离分层，沿着分层网络上的边增广，直到$s$无法到达$t$。重复以上步骤。最多重复$O(n)$次，每次复杂度$O(nm)$。总的复杂度$O(n^2m)$。 ISAP算法。EK算法的改进版，做法类似于Dinic，维护每个点到终点的最大距离（没有暴力重新计算，而是增广过程中更新）。需要增加当前弧优化，GAP优化。复杂度$O(n^2m)$，常数比Dinic小。 推荐ISAP，详见这篇博文。 网络流算法Dinic跑二分图时，复杂度为$O(\\sqrt n m)$。经过实践，ISAP跑二分图的复杂度也差不多，似乎常数略大？ 最大流最小割定理一个图的割定义为，$s,t$分别所属两个点集$S,T=V-S$，代价定义为$S$到$T$所有边的代价总和。 最大流=最小割。 关键的证明步骤：是最大流-&gt;不存在增广路径-&gt;可以构造一个割使之等于流-&gt;是最大流。证明等价性。 关键在于构造这个割。 令$S$为$s$能够达到的点集，那么对于任意$u \\in S, v \\in T$都有$f(u,v)=c(u,v)$，否则$(u,v)$就属于残量了，与前提矛盾。不难发现这个割的容量总和等于流量。 注意：最小割之间的边一定是满流的边，反过来不一定成立。 常见模型Simple这些小技巧的正确性就挺显然的吧。。 多源多汇。增加超级源$s’$，超级汇$t’$，连上流量无穷的边。 节点容量。将一个点$u$拆成两个点$u1,u2$，$u1\\rightarrow u2$连上节点容量的边，入边连上$u1$，出边连上$u2$。 最大权闭合子图对于一个有向图$G$对于其的一个子集$N$满足：闭合子图中的所有节点指向的，都是闭合子图的节点。赋予每个点一个权值$wi$，要求最大化闭合子图的权值。 构图方法。对于原图中的边，替换为流量无穷的边；对于权值为正的节点，源$S$向这个节点连接容量为$wi$的边；对于权值为负的节点，这个节点连向汇点容量为$-wi$的边。 感性证明。注意到一个性质：新的图的最小割一定不包含容量无限的边（称这种割为简单个）。于是满足闭合子图的定义，每个简单割的$S$集一一对应一个闭合子图。 设所有正数的权之和为$sum$，最小割为$w$。发现闭合子图的权就是$sum-w$，于是我们需要最小化$w$，才能最大化闭合子图的权。 最大密度子图对于一个无向图，定义一个子图的密度为边数除以点数。求密度的最大值。 注意到是分数的形式，考虑分数规划，二分答案$g$。于是我们要求出$|E|-g|V|$的最大值，根据与$0$的关系进一步确定区间。 一种比较容易想到的做法： 注意到，如果我们选择了一条边$(u,v)$，那么一定要选择$u,v$。这种依赖关系恰好对应了最大权闭合子图。我们只需要把边也变成点即可。复杂度为$O(\\log n \\times Maxflow(n+m, n+m))$。发现点数过于大。 深入利用特殊性质，得到更好的做法二： 因为要应用最小割，所以首先转成最小化的形式：$g|V’|-|E’|=\\sum {v \\in V’} g - \\sum {e \\in E’} 1$。前面部分无需改变，考虑如何将后面部分与最小割联系。 注意到后面部分就是 $\\frac 1 2 \\times \\sum _ {v \\in V’} d[v] - c[V’, V-V’]$，左边部分与之前的合并在一起，右边部分就是 $V’,V-V’$ 之间最小割。附加所有节点到$T$的边容量为 $g - \\frac {d[v]} 2$。注意，容量有可能为负数，需要增加一个足够大的固定值。最终，流网络的点数为$n$。 这个模型很容易推广到带边权与点权的问题。 二分图点权最大独立集&amp;覆盖集。话说在无向图里，这个问题是NPC的呢。但是二分图就可用最大流跑啦。 覆盖集：$U \\in V$，$\\forall (u,v) \\in E, u \\in U \\vee v \\in U$ 。 独立集：$U \\in V$, $\\forall (u,v) \\in E, u \\notin U \\vee v \\notin U$。 发现最小覆盖集和最大独立集互补。只用考虑最小覆盖集。根据定义很显然啊。 考虑这样建边，新建$S$，对每个$X$部的点$i$连上容量为$a[i]$的边，边$(i,j)$就要从$i$向$j$连$\\infty$的边，每个$Y$部的点$j$向$T$连容量为$b[j]$的边。 注意到最小割的性质。路径$S \\rightarrow u \\rightarrow v \\rightarrow T$，至少有一条边被割，不可能是$u \\rightarrow v$，对应到原问题就是$u,v$中至少选择一个。 所有点权之和减去最小覆盖集就是最大独立集合辣。 应用，论文题：BZOJ1324 Exca王者之剑 一个一般化，基于二元关系的建模方法适用问题：有$N$个元素，每个元素可以选或者不选，有对应的代价。描述若干个二元组，不同关系是产生不同的代价。求中代价的最小/最大值。 找出题目中的二元关系。有必要时需要附加点。如果出现类似与$x$选了，$y$必须选的情况，相当于$y$没选但$x$选了的代价为$\\infty$。 具体方法。新建一个源点$S$和汇点$T$，割$(S,u)$表示不选，割$(u,T)$表示选。对于所有二元关系$(u,v)$，在$(u,v),(v,u)$连上容量为$e,f$的边。根据四种情况可以列方程，解出所有容量，跑最大流即可。 可能出现的情况以及应对方法。解方程后得到中间两条边的容量之和$K$为负数，如果图不是二分图，就GG。否则考虑令$Y$部的点，与$S,T$相连的边的意义交换。可以使中间的容量之和变为$-K$。 最大权闭合子图，最大密度子图也是这种二元关系建模的特殊应用。 具体参见 彭天翼《浅析一类最小割问题》 容量上下界的可行流未完待续。 一些好题 BZOJ1305 [CQOI2009]dance跳舞 有$n$个男生，$n$个女生。有一个$n \\times n$的关系，表示是否愿意一起跳交际舞。每个人最多和$K$个不喜欢的异性跳舞。每个人不会和一个人跳多次舞。每一轮所有人都要一起跳舞。问最多能进行几轮。 二分+最大流二分图匹配。 显然需要二分答案$ans$。考虑将每个点拆分为两个，喜欢$u1$，不喜欢$u2$。考虑$S$连向$u1$容量$ans$，$u1$连向$u2$容量$K$。最后，再是喜欢的点对连接，不喜欢的点对连接，容量都为$1$。跑最大流，如果$S$到所有$u1$都是满流的，就可行。 BZOJ3630 [JLOI2014]镜面通道 有两块镜面$(0,0) \\rightarrow (X,0)$和$(0,Y) \\rightarrow (X,Y)$。中间有若干个正方形和圆形镜面。问最少拿走几块图形，使得左面的光能够通过反射照到最右面。 计算集合+节点容量+最小割。 水能过去，光就能过去。很显然的一个结论吧。。随便感受下就好了。 于是我们需要删除最少的图形，使得左右连通。也即一个割。考虑拆点，建立节点容量，为$1$。在两连通的两个图形之间，要建容量为无穷的边。下镜面作为$S$，上镜面作为$T$。跑最大流即可。 BZOJ1565 [NOI2009]植物大战僵尸 有一个$n \\times m$的矩阵，每个位置有一个植物，每个植物会保护若干个位置。僵尸只能从每一行的最右端开始进攻，而且不能进入被保护的位置。每攻击一个植物，可以获得一个价值（可能为负数），求最后能够获得多少的价值。 拓扑排序，最大权闭合子图。 发现僵尸只能从每一行的最右端开始进攻其实也是一种保护关系，每个植物保护它左边的植物。考虑拓扑排序，对于构成环的节点，我们就删去。对于剩下的DAG，运用经典的最大权闭合子图模型即可。 BZOJ3996 [TJOI2015]线性代数 给出一个$n \\times n$的矩阵$B$和一个$1 \\times N$的矩阵$C$。求一个$1 \\times N$的$01$矩阵$A$.使得$D =(A \\times B-C) \\times A ^ T$最大。其中$A^T$为A的转置。输出D。 $n \\leq 100$ 最大权闭合子图。 一看到题的时候，一脸懵逼。。这个数学题可以用网络流？？ 其实还是很水的啦。注意到，$Ans = \\sum {i=1} ^{n} \\sum {j=1} ^{n} A[i] \\times A[j] \\times B[i][j] - \\sum _ {i=1} ^{n} A[i] \\times C[i]$。 如果选择了$B[i][j]$那么一定要选择$A[i],A[j]$，就是一个最大权闭合子图啦。 算复杂度，点数$|V|=O(n^2)$，边数$|E|=O(n^2)$。所以最大流的复杂度是$O(n^6)$？？！！ WTF，复杂度直接爆炸啊！确定自己没有看错？？ 呐，这个图是二分图诶。。所以复杂度就是$O(n^3)$啦。。 BZOJ 2127# happiness 有一个$n \\times m$的班级，每个学生会选择文科或者理科，得到不同的喜悦值。如果一个人与前后左右选择的科目相同，可以获得额外的喜悦值。问喜悦值最大为多少。$n,m \\leq 100$。 根据二元关系建图。 做完这道最小割，我整个人都最小割了。。—-hzwer 应为要使答案最大化，我们一开始先将喜悦值取负。 加上$u,v$都选文科的喜悦值为$-v1$，都选理科的喜悦值为$-v2$，其他情况下喜悦值为$0$。可以发现$(u,v)$需要连$v1+v2$的无向边，$(S,u),(S,v)$连$v2$的无向边，$(u,T),(v,T)$连$v1$的无向边。已经取正数最后减去$v1+v2$，再除以$2$即可。 对于每个人自己选择文理科，另外处理。使用同样的技巧，首先把边取负，再加上$a[u]+b[u]$。最后一起求最小割，减去多余的，取负即可。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"CodeForces泛做第二轮","date":"2017-09-04T00:08:08.000Z","path":"2017/09/04/Training-CF-Round2/","text":"时间: 2017.9.4~2017.9.16 由于博主深知自己太弱了，所以又开了一个坑。作为文化课划水选手，还是坚持每天刷个2~3题吧。。 UPD 2017.9.17 弃坑辣。。 未完成: Codeforces Round #200 (Div. 1) CF343A。你有无限个阻值为$1$的电阻。需要组成(并联，串联)成一个$a/b$的电阻。求最少需要多少电阻。$a,b \\leq 10^{18}$ GCD。注意到，一个阻值为$a/b$的电阻，与$1$串联，得到$(a+b)/b$；与$1$并列，得到$a/(a+b)$。这个过程类似与GCD，只要求$\\gcd(a,b)$时加上$a/b$即可。 至于为什么这样是最优的，窝也不知道QAQ。 CF343B。有两条分别为红色，蓝色的线，波浪形排列（具体可以看原题）。在$n$处位置相交，给出每个位置是哪种颜色的线在上，问两条线能否解开。$n \\leq 10^5$ 栈。考虑怎样的两条线能解开，只要存在”++”或者”–”，那么这两个位置的线可以分开。分开之后就可以删除了。整个过程用栈维护即可。 CF343C。一条水平的磁道上有$n$个磁头和$m$个待扫描的点，磁头可以左右互不干扰的移动去扫描点，每秒移动一个单位，求最少要花多少时间。$n,m \\leq 10^5$ 二分答案，贪心。二分时间$T$，从左往右考虑每一个磁头。显然最左端的点一定是被当前的磁头去扫描，贪心地尽可能多选即可。注意一开始，磁头也可以先往右。 CF343D。给定一棵有根树。每个点的权值可以为$0$或$1$。有3种操作；$1,u$。$u$所在的子树所有点的权值赋为$1$。$2,u$。$u$到根的链的所有权赋为0。$3,u$。询问$u$的权。$n,m \\leq 5\\times 10^5$ DFS序，树链剖分。树剖也可以做，不过比较优美的做法是DFS序+线段树维护。对于操作1，3，由于DFS序之后可以维护子树信息和节点信息，所以就没有问题。比较麻烦的是操作2，需要更新链的信息。 考虑用线段树维护子树内是否进行过操作2的清除标记。当进行过操作1后，如果$u$的子树有清除标记，那么把$u$子树的所有标记清空，同时，给$fa[u]$打上标记。对于操作3，只要判断$u$的子树中是否有标记即可。 注意因为一开始所有权值都为0，所以一开始需要对每个节点都打上标记。 Codeforces Round #201 (Div. 1) CF346A。给定$n$个数，有$A,B$两个玩家轮流操作。选择集合中的数$x,y$，如果$|x-y|$没有在集合中出现，则将$|x-y|$加入集合。无法进行操作的人输。 GCD。假设$g=\\gcd{ai}$，那么对于所有小于等于$\\max{ai}$的$g$的倍数，以后一定都能在集合中出现。只要判断当前未在最终集合出现的数的个数的奇偶性即可。 考虑为什么这个操作不会中断。对于每一种状态，通过类似辗转相减的方式，一定能操作。在某一刻一定能得到$g$，通过每个数和$g$相减就能填补完剩下的数。 CF346B。给定两个字符串$s1$和$s2$，以及一个病毒串$v$。求$s1$与$s2$的最长公共子序列，使得病毒串不是它的子串。$|s1|,|s2|,|v|&lt;=100 $ KMP，DP。其实这题挺套路的，一开始看错题了QAQ，怎么都和KMP联系不上。 其实我们只需要在原本经典$O(nm)$求$LCS$的算法之上，附加一维状态$[k]$，表示当前匹配到了病毒串的第$k$位。然后转移的时候根据$next[]$搞一搞就好了。 CF346C。给定一些数字$xi$。有两个数$a&gt;=b$。可以执行两种操作：令$a–$； 对于$xi$，令$a=a-a\\%xi$；求最少几次操作可以使得$a=b$。$b-a \\leq 1e6, n \\leq 10^5 $ 单调性，贪心，暴力，复杂度证明。非常巧妙的一道题。令$f(i)$表示从$b+i$变为$b$最少操作次数，不难注意到$f(i)$具有单调性，于是，我们需要贪心地使得每一次减少得尽可能大。看上去这个复杂度是平方级别的，事实上这个的复杂度只有$O(b-a)$。为什么呢？ 假设$x’$是最大的$xi$，通过至多2次操作，我们就可以让$a$减小$x’$。而不超过$x’$至多有$O(x’)$个，所以每次$a$减小1是均摊$O(1)$的。为了防止复杂度退化，我们需要一开始就去重，同时对于操作后会令$a&lt;b$的$xi$要及时删除。 Codeforces Round #202 (Div. 1) CF348A。有$n$个人玩游戏，每轮需要$1$个主持人，$n-1$个玩家，给出每个人想当玩家的局数，求满足条件的最少局数。$n \\leq 10^5$ 二分答案，贪心。二分需要玩的局数，对于一个人，我们可以让他玩到需要的局数，对于剩下的局数，全部都当主持，这样就可以判定了。 CF348B。给定一颗树，和所有叶子的权值。需要对于所有节点$u$，$u$所有儿子$v$的权值都相等。一个节点的权值是所有叶子的权值之和。问最少减少多少叶子的权值。$n \\leq 10^5$ GCD，树相关，贪心。考虑转化为最多保留多少权值。 考虑节点$u$和他的所有子节点$vi$（共$k$个）。对于每一个字节点，首先求出至少保留多少权值，记为$f[vi]$，为了使$u$满足条件，所有子节点的权值都要变为$lcm{f[vi]}$。那么，$f[u]=k\\times lcm{f[vi]}$。 之后再进行第二次DFS。记$s[i]$为当前$i$子树中的节点数，对于$u$，我们需要选取最小$s[v]$，把所有$s[vi]$都变成$s[v]/(f[u]/k)*(f[u]/k)$。DFS过程中记录删除的总和即可。 CF348C。给定一个包含$n$个数的数组$ai$，和$m$个集合$S1,S2,..,Sm$。每个集合包含若干下标$Sk,i$。有两种询问：对于集合$Sk$，求$S[k,i]$所对应的$a[S[k,i]]$之和。对于集合$Sk$，使得$S[k,i]$所对应的$a[S[k,i]]$都加上$x$。对于询问$1$，输出答案。 所有集合的大小总和不超过$10^5$，$n,m,Q \\leq 10^5$ 暴力，分块（分类？？），复杂度分析。考虑首先从暴力入手，复杂度是$O(n^2)$的（这里假设$n,m,Q$同阶）。 考虑暴力的复杂度瓶颈，是因为操作的集合非常大，考虑以$T=\\sqrt n$为界限分类解决。注意到一个性质，集合大小超过$T$的只有$O(T)$个。我们称大小超过$T$的为重集合，否则为轻集合。 首先我们要任意一个集合与每一重集合的交集大小，这个可以$O(n \\sqrt n)$解决。接下来考虑两类集合的四种贡献： 对于轻集合对轻集合的贡献，我们只需要暴力修改/查询即可。复杂度$O(\\sqrt n)$。 对于轻集合对重集合的贡献，我们只需要枚举每一个重集合，根据交集大小更新即可。复杂度$O(\\sqrt n)$。 对于重集合对轻集合的贡献，由于轻集合个个数太多了，所以可以在这个重集合上打上标记，同时在轻集合询问的时候计算贡献即可。复杂度$O(1),O(\\sqrt n)$。 对于重集合对重集合的贡献，暴力枚举重集合即可。复杂度$O(\\sqrt n)$。 Codeforces Round #204 (Div. 1) CF351A。给定$2n$个实数，执行$n$次操作：选择两个未选择的位置$i,j$，使得$a[i]$向上取整，$a[j]$向下取整。问变化前后的总和之差，最小为多少。$n \\leq 1000$ 贪心。注意到一个性质，对于一个非整数$a$，$\\lceil a \\rceil - \\lfloor a \\rfloor=1$。假设其中存在$cnt$个整数。然后枚举向下取整的个数，取最大值即可。 CF351B。给定一个序列$a[]$，$A$和$B$轮流进行操作：对于$A$，选择相邻的两个数$a[i],a[i+1]$并交换。（采用最优策略） 对于$B$，有$1/2$的概率，任意选择$i$，满足$a[i]&gt;a[i+1]$并交换；有$1/2$的概率，任意选择$i$，满足$a[i]&lt;a[i+1]$并交换；如果不存在这样的$i$，就$B$重新操作（步数$+1$）。 如果序列变为增序，游戏结束。$A$希望游戏尽快结束，求结束游戏的期望步数。$n \\leq 3000$ 逆序对，期望。注意到序列最终变为升序，逆序对为0，而交换相邻的逆序对可以使逆序对数量减一。于是我们只需要关注逆序对数量。推一发公式即可。 CF351C。给定$n,m$和长度为$n$的数组$ai,bi$。请构造一个长度为$nm$的匹配序列，如果第$i$个位置为’(‘，代价为$a[i\\%n]$，否则，代价为$b[i\\%n]$。求最小代价。$n \\leq 20,m \\leq 10^7$ 动态规划，矩阵快速幂。首先可以证明一个结论：对于任何位置，未匹配的左括号数量一定不会超过$n$（可以通过反证法，按照模$n$分类来证明）。注意到$m$非常大，所以不难想到矩阵快速幂，不过此处的矩阵为$floyd$矩阵。考虑用动态规划求出转移矩阵$T[i][j]$——从$i$个未匹配左括号到$j$个未匹配左括号的最小代价。 CF351E。给定一个长度为$n$的序列$a[]$。你可以对$a[]$中的一些数乘上$-1$，使得序列$a[]$的逆序对个数最少。求逆序对个数的最小值。$n \\leq 2000$ 脑洞，贪心。考虑到所有数都能变为相反数，所以一开始可以把所有数都变为正数。考虑一个逆序对中的绝对值较大数对答案产生贡献。如果位置$i$的数为正数，$j&gt;i$且$a[j]&lt;a[i]$会对答案产生贡献，因为不管$a[j]$是否改变符号，都是一对逆序对；$a[i]$改变后为负数同理。对于每一个$i$，只要加上较小的贡献即可。 Codeforces Round #206 (Div. 1) CF354A。给定长度为$n$的序列$wi$，参数$l,r,ql,qr$。对于每一次操作，可以删除左端的数字，代价为$wi\\times l$。如果上一次操作也是删除左端的数字，那么代价需要增加$ql$。删除右端的数字同理。求删除所有数字的最小代价。$n \\leq 10^5 $ 水。枚举左端删除的个数。为了使代价最小，所以需要交替从两端选取。 CF354B。给定一个$n\\times n$的字母矩阵。从$(1,1)$开始，每步往下或往右走，得到的任意长度字符串，称之为好串。 现在有两个人$A,B$玩一个游戏：一开始有一个空串， 轮流在字符串中添加一个字母，要求每次得到的都是好串，2n-1次后，游戏结束。如果a的个数比b的个数多，则A胜；反之，B胜。如果相等，为平局。假设A，B都以最优策略执行。游戏的结果。$n \\leq 20$。 博弈，状压DP，记忆化搜索。 本题有一个坑点：不能用$f[i][j]$表示$(i,j)$到$(n,n)$的最优解，并以此来DP。 因为只要求是好串，不一定是矩阵上的路径，比如， bac dce aba 在位置$(1,3)$时，也能到达位置$(3,2)$。 同时注意到，对于第$i$步，一定是在第$i$条对角线上。而最多只有$n$个位置，可以考虑状压$DP$，$f[i][j]$表示第$i$根对角线上的等价情况为$j$时，到达$(n,n)$。先手能比后手多得的分数的最大值。 通过位运算以简化代码。具体参见代码。 CF354C。给定一个长度为$n$的序列$ai$。可以减少其中的某些数，但是减少不能超过$k$。求修改后，所有序列的$gcd$的最大值。$n,k \\leq 10^6$ 暴力，调和级数，前缀和。一个直观的想法就是暴力枚举GCD，同时判断每个数是否能变成GCD的倍数，复杂度为$O(nk)$。瓶颈出现在第二步，考虑如何优化。 对于一个GCD的倍数$x$，对于$[x,x+k]$内的数都是满足条件的。也就是说我们求出所有在区间内的数的个数之和，如果就是$n$，那么这个GCD是满足条件的。由于调和级数，时间复杂度$O(k\\log k)$。 CF354E。给定一些数$n$，求是否能表示为6个数之和，每个数仅由4或7构成。$T \\leq 5000,n \\leq 10^{18}$ 暴力。注意到4或7在哪个位置并没有关系，只要枚举每一位4或7的个数即可。 Codeforces Round #207 (Div. 1) CF356A。有$n$个骑士进行$m$轮PK。对于第$i$论，$xi$站在台上，将$[li,ri]$的骑士都打败。如果一个骑士被打败，就出局。输出每个骑士是被哪个骑士打败的。胜利者输出0。$n \\leq 3\\times 10 ^5$ Set。用set维护未打败的骑士集合，每次lower_bound和upper_bound找出区间。由于每个只会被删除一次，所以复杂度为$O(n\\log n)$ CF356B。给定$n,m$，和两个串$x,y$。由$x$重复出现$n$次得到串$a$，由$y$重复出现$m$次得到串$b$。问存在多少个$i$，满足$a[i]\\not =b[i]$。$n,m \\leq 10^{12},lenX,lenY \\leq 10^6,n\\times lenX = m\\times lenY$ GCD。注意到我们只需要考虑$lcm(lenX, lenY)$的答案。令$g=\\gcd (lenX, lenY)$。 注意到对于$i,j$，当且仅当$i \\equiv j \\pmod g$，$x[i],y[j]$才有可能产生贡献。同时，注意到$\\gcd (lenX/g, lenY/g)=1$，也就是说$x[i]=y[j]$时，恰好在$lcm$中出现一次。 Codeforces Round #210 (Div. 1) CF360A。有一个长度为$n$的数组$ai$，两种操作：$1,l,r,d$，令区间$[l,r]$内的数增加$d$。$2,l,r$，询问区间$[l,r]$内的最大值。 现在给定所有操作，和询问$2$的结果。请还原数组$ai$。$n,m \\leq 5000 $ 贪心，模拟。考虑时光倒流，倒序处理所有询问，于是我们可以得到每个位置初始的最大值。于是我们再对这些初始数进行模拟，如果能完全符合回答的，则一定可以，否则一定不存在。 为什么说，不符合就一定不存在呢？因为我们一开始求出的是最大值，如果不符合，那么一定是没有达到最大值。如果再使得初始的序列变小，肯定也会不符合。 CF360B。给定一个长度为$n$的数组$ai$，可以修改至多$k$个数。令$c(a)=\\max(|a[i+1]-a[i]|)$，求$c(a)$的最小值。$n,K \\leq 2000$ 二分答案，DP。首先显然需要二分答案，通过DP来判定。 一种比较套路的定义方式为，定义$f[i]$表示，以第$i$个数结尾且不改变时，相邻绝对值都不超过$limit$的最小操作次数。转移的时候，只需要枚举上一个不改变的数$j$，只要满足$|a[i]-a[j]|&lt;=limit*(i-j)$就能转移。 CF360C。给定一个长度为$n$的字符串$s$和$K$。一个字符串$t$(长度为$n$)的美丽度定义为：存在多少对$i,j(i s[i..j]$(以字典序比较)。求存在多少字符串的美丽度为$K$。$n,K \\leq 2000$ DP好题，前缀和优化，调和级数。很好的DP题啊，我太弱了，抄一波官方题解。。 首先考虑$t$确定时，$t[i]$与$s[i]$对答案的贡献。 若$t[i]&lt;s[i]$, $0$ 若$t[i]&gt;s[i]$, $n-i$ 若$t[i]=s[i]$, 找到最小的$k(k&gt;i)$满足$t[i]\\not =s[i]$ 若$t[k]&lt;s[k]$,$0$ 若$t[k]&gt;s[k]$, $n-k$ 也就是说，若$t[i]&gt;s[i]$，对答案贡献了$(pre+1)(n-i)$。其中，$pre$是$s[1..i-1], t[1..i-1]$的最长公共后缀。 $f[i][sum]$表示$s[i]\\not =t[i]$时，前$i$个对答案贡献$sum$的方案数。(如果$s[i]=t[i]$，则枚举$pre$时得到错误的贡献，正是状态定义精妙之处)，枚举$pre$进行转移，于是有： 当$t[i]&lt;s[i]$时，$f[i][sum]+=f[i-1-pre][sum](s[i]-‘a’)$当$t[i]&lt;s[i]$时，$f[i][sum]+=f[i-1-pre][sum-(pre+1)(n-i)]*(‘z’-s[i])$ 前一部分可以通过前缀和优化，而对于后面一部分，$pre$枚举量为$O(k/1+k/2+..+k/k)=O(k \\log k)$。所以，总的时间复杂度为$O(k(n+k log k))$。 Codeforces Round #213 (Div. 1) CF364A。给定一个长度为$n$的数组$s$，和数字$a$。构造矩阵$B$，其中$B[i][j]=s[i]*s[j]$。求矩阵$B$存在多少子矩阵，子矩阵的和为$a$。 前缀和。没啥好说的，注意$a=0$的情况。","tags":[{"name":"训练","slug":"训练","permalink":"https://xuzhean.github.io/tags/训练/"}]},{"title":"CodeForces乱做-图论","date":"2017-08-27T02:00:00.000Z","path":"2017/08/27/Training-CF-Graphs/","text":"嗯，图论么？我知道，就是dalao口中的简单题罢了。 未完成: 这是一些CF上的simple??的图论题。QAQ 第一波-2017.8.27 CF208C。给定一个有$n$个节点的无向图。选一个点成为特殊点，与特殊点相连的边称之为特殊边。求，对于所有$1 \\rightarrow n$的最短路，经过的特殊边数量的平均值，的最大值。$n \\leq 100, m \\leq n(n-1)/2$ 最短路，拓扑图的DP。考虑到有两种情况，一种是$1$或$n$成为了特殊点，此时答案一定为$1$。否则我们可以求出经过每个点的最短路条数，即可。在BFS之后，按照距离来排序就完成了拓扑排序。 CF154C。有编号为$[1,n]$的$n$个人，并给一些相识关系。对于两个人$(i, j)$有，对所有剩下的人，$k$要么与$i,j$相识，$k$要么与$i,j$不相识，求这样的$(i,j)$有多少对。 图上的HASH。考虑到我们可以将点连出去的边进行$Hash$，如果两个点的$Hash$值相同，则这一对点满足条件。还存在着一个问题，就是说，如果$(i,j)$本身存在连边，他们的$Hash$值不同，于是它们可以把自己加入各自的$Hash$。由于这个$Hash$函数要求与顺序无关，所以我们可以对每个点赋予一个值，然后加起来或者异或，即可。 CF825E。给定一个有$n$个节点的$DAG$。所有的点权是一个$[1,n]$的置换，如果存在$u \\rightarrow v$的一条有向边，需要满足$u$的点权比$v$的点权小。求这个置换，要求最小字典序最小。 贪心，堆，拓扑排序。显然需要贪心，我们有如下两种贪心策略： 按照原图进行拓扑排序，每一次将位置最靠前的赋值为最小值。 按照原图的反图进行拓扑排序，每一次将位置靠最后的赋值为最大值。 哪一种贪心是正确的呢？考虑第一种贪心，不难发现，如果位置最靠前的没有赋值为最小值，对答案或许不造成影响。考虑第二种贪心，如果位置最靠后的没有赋值为最大值，也就是最大值不是在位置最后的点，导致答案的字典序更大。于是用一个堆维护最靠后的位置即可。","tags":[{"name":"图论","slug":"图论","permalink":"https://xuzhean.github.io/tags/图论/"}]},{"title":"CodeForces乱做-动态规划","date":"2017-08-27T02:00:00.000Z","path":"2017/08/27/Training-CF-DP/","text":"专治数据结构学傻。 未完成: 这是一些CF上的simple??的动态规划题。QAQ 第一波-2017.8.27 CF67D。两条直线，各有$n(1≤n≤10^6)$个点，每个上面的点会和下面的一个点相连，构成一条线段，共$n$条线段，问这$n$条线段中，最多有多少线段，它们两两相交？ 最长上升子序列。考虑两两相交的条件，对于第一行一些点$(a,b,c,..)$，如果它们的线段互相相交，则在第二行一定是以$(..,c,d,a)$的顺序出现。将第二行倒序，就变成了裸的LIS问题。 CF398B。给出$n$和$m$，在一个$n\\times n$的平面上有$n\\times n$个瓷砖，其中有$m$块已经涂色。现在随机选中一块进行涂色（如果已经涂色跳过，也消耗时间），消耗$1$个时间。终止条件为每行每列都有至少有一块瓷砖被涂色。问说涂成满意的情况需要时间的期望。$n \\leq 2000$ 期望DP。定义状态$f[i][j]$表示剩余$i$行和$j$列没有涂色，直到满足条件的期望时间。划分为四类转移即可。 CF762D。你有一个$3\\times n$的格子，每个格子都有权值，问从$(1,1)$出发，到$(3,n)$，路上经过的权值最大是多少。 巧妙的状态转移。注意到一个性质，一定是在中间一行往回走的。类似与$S$形的路线。同时可以知道，一定至多往回走一次，因为往回走多次都可以等效地代替。 考虑$f[i][j]$表示走到第$i$行第$j$列时，权值的最大值。于是从$f[i][j]$可以转移到$f[k][j]$，只要加上经过的若干个权值。同样的，如果我们往回走一次，可以从$f[1][j]$转移到$f[3][j+2]$，从$f[3][j]$转移到$f[1][j+2]$。 第二波-2017.10膜一膜敦爷的题单Orz。 446A,463D,455A,467C,392B,383D,404D,429B,459E,479E,348D,403D","tags":[{"name":"数论","slug":"数论","permalink":"https://xuzhean.github.io/tags/数论/"}]},{"title":"CodeForces乱做-数据结构","date":"2017-08-26T02:00:00.000Z","path":"2017/08/26/Training-CF-Data-Structures/","text":"听说学数据结构会学傻？ 未完成: 这是一些CF上的simple??的数据结构题。QAQ 第一波-2017.8.25~26 CF538F。现在有一个长度为$n$的数组$a1, a2, …, an$。然后对于$k$从$1$到$n-1$别对该数组建$k$叉堆。现在要统计对于每一个$k$叉堆，里面有多少结点是不满足最小堆的性质的。即值比父亲的要小的结点有多少个。他的$k$个儿子编号是$k(v − 1) + 2, …, kv + 1$。 $k$叉堆的性质，调和级数，树状数组。注意到一个性质$k$叉堆的父亲只有$n/k$，也就是说父亲的总数不会超过$O(n(1+1/2+1/3+…+1/n))=O(n\\log n)$。这就成为了本题的突破口。 考虑从小到大加入每一个数到树状数组，可以枚举这个点作为$k$叉堆的父亲。由于属于它的儿子一定是一个区间，所以我们可以用树状数组在$O(\\log )$的时间内统计出贡献。总的复杂度为$O(n \\log^2 n)$。 CF101B。给定$n,m$。需要从$0$到$n$，有$m$种公交车。第$i$辆公交车从$si$走到$ti$（可以在中途上车），问有多少种方案可以选择。注意人只能坐车，不可以走。$m \\leq 100000$ 动态规划，树状数组。首先离散化，按$t$来排序，我们可以$DP$。注意到可以转移的状态是一段区间，所以直接用树状数组即可。 CF677D。给定一个$n\\times m$的地图，标有数字$[1,p]$。需要从$1$出发，依次经过一个$2,3,4…$直到$p$。求最少所需要的步数。$n,m \\leq 300$ 二维树状数组。考虑从数字$k-1$走到$k$的转移。存在四种转移的方向，以从左上角转移为例。于是转移方程即为$f[i][j]=f[x][y]+i-x+j-y$ ，可以拆开使得与$i,j$无关。$f[x][y]-x-y$于是把这个东西放在树状数组里，询问二维前缀最小值即可。细节较多，代码较长QAQ CF372C。有$n$个点，$m$个烟花要放。给定放的地点$a[i]$、时间$t[i]$，如果你当时在$x$，那么可以获得$b[i]-|a[i]-x|$的高兴值。每个单位时间可以移动不超过$d$，初始位置是任意的，求通过移动能获取到的最大的值。$$n \\leq 150000, m \\leq 300$$ DP+单调队列。设$f[i][j]$表示在放第$i$个烟花的时候，站在位置$j$能得到的最多的高兴值。于是有状态转移方程：$f[i][j]=\\max(f[i-1][k])+b[i]-|a[i]-j|$，其中，$\\max(1,j-td)&lt;=k&lt;=\\min(n,j+td)(t是两次烟花的时间差)$。这个复杂度是$O(n^2m)$。 考虑优化，发现每一次转移的$k$都是一个区间，于是我们可以用单调队列维护。注意使用滚动数组。 CF827C。给定一个只包含$A,T,C,G$的字符串$S$,有如下两种操作。1)$\\ x,c$，修改第$x$个字母为$c$。2)$\\ l,r$,字符串$e$，生成一个由$e$重复组成的新串，像$eee…$，问$[L,R]$中有几个字母跟这个新的字符串对？$|S|,Q \\leq 100000，|e|&lt;=10$ 树状数组，剩余类。考虑对$S$为$4$个字符，分别建立$10\\times 10$的树状数组。表示第$i$个字符在位置$x$满足$x\\%j=k$的个数之和。看上去很暴力，对吧？接下来分析复杂度。对于一个修改操作，我们需要修改在$O(|e|)$个树状数组中的值，每次修改的代价为$O(\\log n)$。对于一个询问操作，我们需要询问$O(|e|)$询问的代价为$O(\\log n)$。所以总体的复杂度为$O(Q\\times \\log |S| \\times |e|)$。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://xuzhean.github.io/tags/数据结构/"}]},{"title":"CodeForces乱做-树相关","date":"2017-08-25T04:00:00.000Z","path":"2017/08/25/Training-CF-Tree/","text":"听dalao说，树能吃。 未完成: 这是一些CF上的simple??的树相关的题。QAQ 第一波-2017.8.25~26 CF543D。输入给出$N$和一些边的关系$(p2，p3，p4,…,pn)$表示$i$和$pi$有连边。对于以任意$i$为根时，把树边黑白染色，使得任意点走到根的路径上不超过一条黑边，输出染色的方案数。$n \\leq 200000$ 树形DP，DFS转移。考虑以$1$为根的情况，定义$f[i]$表示以$i$为根的方案数，于是有$f[i] = \\prod (f[j]+1)$。 那么，如何将答案转移到子节点上呢？假设$u$的祖先（非子树）的方案为$x$，需要转移到$u$的子节点$v$。假设$u$到$v$的边的颜色为黑色，显然只有一种；为白色时，有$\\large \\frac {x \\times f[u]} {f[v]+1}$种方案。两者之和作为新的$x’$转移到子节点即可。每个节点的答案为$x \\times f[u]$。 值得注意的是，由于涉及到除法和取余，所以需要我们计算逆元。但是，特别的，如果$f[v]+1=MOD$，则不存在逆元，所以需要我们暴力重新计算。 CF396C。给定以$1$为根的树，从节点$2$开始给出每个节点的父节点。$m$次操作，操作分为两种，$1\\ u, x, k$，表示在以$u$为根的子树上，对于所有其它与$u$节点的距离为$i$的点$v$，加上$x-i\\times k$。$2\\ v$，查询节点$v$值。$n,m \\leq 300000$ DFS序，树状数组。从$x-i\\times k$这个式子入手，显然$x$可以用DFS序来维护，那么如何处理后一个数字呢？考虑拆开：$x-i \\times k = x - (d[v] - d[u]) \\times k = (x + d[u] \\times k) + d[v] \\times k$。可以发现，我们将答案分为了两部分，一部分与$v$的深度无关，可以用树状数组维护。另一部分与$v$的深度有关，于是维护$k$之和即可。区间修改可以差分化，然后用树状数组维护。 CF696B。给定一棵以$1$为根的树，在时刻$1,2,3…$访问节点。一开始在$1$，之后以随机的方式$DFS$（保证不重复访问）求对于每个节点，访问它的期望时间。$n \\leq 100000$ 期望的线性性，树形DP。假设一个节点$u$已经知道访问父节点$fa$的期望时间$ans[fa]$，那么这个节点$u$的期望时间为多少？考虑到，$u$的兄弟节点各有$50\\%$在$u$的前面访问，而且需要的代价为整颗子树的$size$。由此我们可以得到在子树$fa$访问$u$的期望时间。再根据期望的线性性，于是， $\\large ans[u]=ans[fa] + 0.5 \\times (size[fa] - size[u] - 1) + 1$","tags":[{"name":"树相关","slug":"树相关","permalink":"https://xuzhean.github.io/tags/树相关/"}]},{"title":"CodeForces乱做-组合计数","date":"2017-08-24T02:00:00.000Z","path":"2017/08/24/Training-CF-Combinatorial-Mathematics/","text":"组合？？不就是一群无聊的数学家在数数吗？ 未完成: 559D 首先，安利一篇博文，Codeforces 上的一些组合计数问题。 这是一些CF上的simple??的组合计数题。QAQ 第一波-2017.8.24 CF57C。给定$n$，求存在多少长度为$n$的序列满足：所有数在$1$到$n$之间，这个序列是非递增或非递减的。$n \\leq 100000$ 组合数的格路模型。不失一般性，我们考虑序列是非递减的方案数。可以注意到，假设最后一个数字是$n$，其等价于从$(0,0)$走到$(n-1,n-1)$的方案数。为什么呢？我们可以把向右走看作是到下一个数，向上走可以看成是当前位置的数$+1$，并且，序列的数是非递增的。最后一个数可以是$[1,n]$，同理求出。 CF689E。给定$n$和$K$，然后给定$n$个区间，在$n$个区间中选择$K$个，求它们的交集总和。$n \\leq 100000$ 离散化，贡献。本题似乎难以直接穷举所有的情况，考虑离散化，并计算每一条线段被多少个区间覆盖。假设某一段被$x$条线段覆盖，那么，我们只需要从这$x$条中选取$K$个，就会对答案产生贡献。即为$len \\times C_{x} ^{K}$。 CF28C。有$n$个人等概率随机进入$m$个房间，一个房间可以有多个人，第$i$个房间有$ai$个水龙头，在一个房间的人要去排队装水，他们会使得最长的队尽可能小，求所有房间中最长队列长度的期望。$n,m \\leq 50$ 概率，动态规划。注意到，一个房间内原来有多少人到达最长是无法记录在状态中的，所以直接求概率十分困难。考虑概率的原始定义：方案数除以总方案数。也就是说我们求出状态的方案数即可。 用$f(i,j,l)$表示已经分配了前$i$个房间和$j$个人，最长队列长度为$l$的方案数。首先$f(i,0,0)=1$。 状态可以有两种决策转移，一种是当前房间队列到达$l$，前面的房间任意；另一种是前面有房间队列到达$l$，但当前的房间任意，于是， $$\\large f(i,j,l) = \\sum {k=0} ^{l} \\left( ^{n-j+p} {\\ \\ \\ \\ p} \\right) f(i-1,j-p,k) \\ \\large + \\sum {k=0} ^{\\min p -1} \\left( ^{n-j+k} {\\ \\ \\ \\ \\ k} \\right) f(i-1,j-k,l)$$ 其中$p$为使得第$i$个房间队列长度为$l$的数的集合，需要枚举。 CF15E。给定一个整数$N$，当$N=12$的时候是这样一幅图： 然后你要从最上面的$H$点出发，走一条道路，这条道路中间不包括任何灰色三角形，最后回到$H$。$N$是偶数，$n \\leq 10^6$，问有多少情况，答案对$1e9+9$取模。 递推。为了方便起见，我们以下图所示的阶段划分。 由于整个图是对称的，所以我们考虑左半部分。除去几种特殊情况，我们都需要从绿点出发回到紫点，方案数记为$g[1]$。令$f[i]$表示陷进去$i$层的方案数（强制不能从洞口经过，防止重复计数）。令$g[i]$表示第i个蓝点到红点的方案数，于是显然有， $$\\large f[0] = 0,\\ f[1] = 4,\\ f[i] = 4 + 2 \\times f[i-1]$$ 通过$f[]$我们可以很容易地递推出$g[]$。首先， $$\\large g[n/2] = 1$$ $g[i]$可以从哪些方面转移呢，第一种是从蓝点$i$不经过蓝点$i+1$回到红点$i$，根据是否进入洞穴来分；第二种是经过了蓝点$i+1$。综上，即为， $$\\large g[i] = 3 \\times f[i-1] + 4 + g[i+1] \\times (f[i-1]+1)$$ 如何根据$g[1]$来计算答案？可以注意到，一种是从绿点到紫点再到绿点；一种是从绿点到紫点再直接回去；还有$2$种情况是不经过绿点。于是答案即为： $$\\large ans = 2 \\times (g[1] \\times g[1] + 2 \\times g[1] + 2)$$ CF40E。给出一个$n\\times m$的矩阵，每个元素都是$1$或$−1$，其中有$k$个位置元素已经确定，并且这个矩阵满足每一行、每一列元素的乘积都是$−1$，问有多少种不同的矩阵。$1≤n,m≤1000,0≤k&lt;\\max(n,m)。$ 组合，观察。注意到乘积为$-1$的等价条件为$-1$有奇数个。需要注意一个条件$k&lt;\\max(n,m)$，这意味至少存在一行（或列）是空的。这是极其重要的一条性质。 假设空的一行为$x$，我们可以先去填上其他行。此后满足其他行的乘积都为$-1$，这个可以通过组合数很容易地算出来。然后，我们要求列的乘积也是$-1$，不难发现，第$x$的每一个数都是唯一确定的。也就是是说，其他行方案的乘积就是总的方案数。 但是这样还没有完，我们仍需要保证第$x$行的乘积是负数，如何确定呢。注意到，所有数的乘积是$(-1)^m$，如果$(-1)^m \\not= (-1)^n$则一定无解，否则第$x$行的乘积一定是负数。 CF830D。给定$n$，现有深度为$n$的满二叉树，对于一个节点，给它与它的所有父亲连一条边。 问得到的新的图有多少条不同的简单路径（1-&gt;2和2-&gt;1算不同路径） 。$n≤400$ 树形DP，巧妙非常规的状态定义。首先考虑一个错误的算法，通过对错误的分析，可以得到正确的算法。 假设状态$f[i]$表示深度为$i$的满二叉树，方案的个数为$f[i]$。我们考虑按照是否通过根结点来讨论。一种是根经过根据所在子树不同，有$f[i-1] \\times f[i-1] \\times 4$种情况，一种是从根出发或结束，有$f[i-1] \\times 4$种情况，还有一种是不经过根$f[i-1] \\times 2$，当然，只包含$1$的简单路径也算，就是要$+1$。 可以发现，这比答案大很多。问题出在哪里呢？可以发现，如果我从左子树到根再到左子树，就会发生方案不合法，同时注意到$n$比较小，考虑附加一些状态来避免非法。 我们需要在同一个子树中选择两个不相交的路径，然后与根相连。此后不相交的路径条数会不变或减小。 这就启发我们还要记录一个状态：此时树中有多少个不相交路径。即$f[i,j]$表示从深度为$i$的树中，选出$j$条不相交的路径的方案数。那么答案就是$f[k,1]$，按照根所在路径，枚举$f[i-1,j]$和$f[i-1,k]$转移如下： 如果让根成为单独的一条路径，那么$f[i,j+k+1]\\ += f[i−1,j] × f[i−1,k] $ 如果不选根，那么$f[i,j+k] += f[i−1,j] × f[i−1,k] $ 让根与左儿子中的一条路径结合或和右儿子中的一条路径结合，那么$f[i,j+k] += f[i−1,j] × f[i−1,k] × 2 × (j+k)$ 从$j+k$条边中选出两条，让这两条边与根结合形成新的一条边，那么$f[i,j+k−1] += f[i−1,j] × f[i−1,k] × C(j+k, 2) × 2$ 真的是一道DP神题！","tags":[{"name":"组合","slug":"组合","permalink":"https://xuzhean.github.io/tags/组合/"}]},{"title":"CodeForces乱做-数论","date":"2017-08-23T02:00:00.000Z","path":"2017/08/23/Training-CF-Number-theory/","text":"膜一膜欧拉，您就能把这道数论题A了！ 未完成: 这是一些CF上的simple??的数论题。QAQ 第一波-2017.8.23 CF222C 给出两个集合，第一个集合数的乘积是分子，第二个集合的数的乘积是分母，要求够造一个同样大小的集合，但是得到的分数是化简过的。$1≤n,m≤10^5,ai,bi \\leq 10^7$ 质因数分解，构造。考虑首先筛出$10^7$内的所有素数，然后对所有数质因数分解。最后暴力消除即可。为了保证一定能存在答案，只需要在原来数的基础上消除即可。 CF446C 给定$n$个元素的数组$a[]$。操作$1, l, r$。要求对于$l \\leq i \\leq r$，$a[i] += f[i-l+1]$。询问$2,l,r$。返回$\\sum_{i=l}^{r} a[i]$，对$10^9+9$取模。其中$f[i]$为斐波那契数列，$f[1]=1,f[2]=1$。$n,m \\leq 300000$ 斐波那契数列，线段树维护等比数列。本题似乎无从下手，因为每一个数增加的值不同。事实上，我们可以利用斐波那契数列的的通项公式（可以用母函数证明，是线性常系数其次递推关系，可窝不会）。 $$\\large fib(i) = \\frac {1} {\\sqrt{5}} \\left( \\left(\\frac {1+\\sqrt{5}} {2}\\right)^n + \\left( \\frac {1-\\sqrt{5}} {2} \\right)^n \\right)$$ 令$\\large q1= \\frac {1+\\sqrt{5}} {2}, q2 = \\frac {1-\\sqrt{5}} {2}$，于是我们只需要维护两个等比数列即可，由于公比是$q1,q2$不变，所以直接利用等比数列求和即可，用线段树维护区间和。注意，本题需要得到$q1,q2$在模意义下的值，只需要暴力算出$\\sqrt5$即可。 顺便提一下，我们需要利用等比数列求和公式$\\large \\frac {q^n-1} {q-1}$ ，但是本题中$q1,q2$满足$q^2-q-1=0$，就是说$rev(q-1)=q$，原来的公式就变为了$q^{n+1}-q$，足以见得斐波那契数列的神奇。 CF711E,2A。给定$n,k$，已知一年有$2^n$天，选取$k$个人，两个人的生日是在同一天的的概率。要求答案写成最简分数。$n,k \\leq 10^{18}$ 欧拉定理降幂，组合相关。首先需要特判一个情况，就是$k&gt;2^n$概率就是$1$。从反面情况入手，总共生日的方案数为$A=2^{nk}$，所有人的生日互不相同的情况为$B=A_{2^n}^{k}$。答案即为$\\large \\frac {A-B} A$ 。注意到，$A$的质因数仅有$2$，所以我们需要知道$B$中质因数$2$的个数即可。考虑其展开式， $$\\large B = A_{2^n}^k = 2^n \\times (2^n-1) \\times (2^n-2) \\times … \\times (2^n-k+1)$$ 首先，$2^n$中有$n$个，然后若存在$2^n-a2^b(b&lt;n)$，那么显然这一项含有$b$个质因数$2$，所以我们只要统计$(k-1)!$的质因数$2$的个数即可。 但是$A=2^{nk}$，指数过大，应该如何处理。考虑降幂大法，欧拉定理： $$\\large a^{\\varphi(m)}\\equiv a^{0} \\pmod m$$ 所以指数对$\\varphi(m)$取模即可。 CF121C,1A。对于一个数，如果它仅包含$4$或$7$，则称之为幸运数。求$[1,n]$的第$K$个置换，有多少幸运数位于的位置也是幸运数。$n,k \\leq 10^9$ 观察，求第$K$排列。注意到$k$很小，当$n&gt;=14$时，最前面的$n-13$位是不发生改变的。而且$10^9$内的幸运数只有$1023$个，所以，对于前面的数字，我们暴力计算，后面的，暴力求出第$K$排列即可。 CF772C,1A。给定$m$和$n$个整数$ai(0 \\leq ai \\leq m-1)$，请您构造一个最长的序列，满足对于所有前缀积对$m$取模，它们互不相同，且不等于任意一个$ai$。$n,m \\leq 200,000$ GCD，DAG最长路。考虑最后一个数与$m$的$\\gcd\\ t$，可以注意到，这个数通过乘与$m$互质的数，可以得到任意一个与$m$的$\\gcd$为$t$。同样我们也可以乘上一个与$m$不互质的数，得到与$m$的$\\gcd$为$kt$的数。DP得到最长路后，dfs输出答案即可。 考虑证明这一点。其中$kax \\equiv bcx \\pmod m$，$x$是原来最后一个数与$m$的$gcd$（所以$a$与$m$互质），$cx$是新的$gcd$，由乘上一个$k$得到。然后$ka \\equiv bc \\pmod {\\frac m x}$ ，因为$a$与$m$互质，所以一定存在$k$。 CF396B,1A。定义函数$v(n)$为不大于$n$的最大素数。定义函数$u(n)$为大于$n$的最小素数。求$\\large \\sum \\frac 1 {v(i) \\times u(i)}(2 \\leq i \\leq n)$。$T \\leq 500,n \\leq 1e9$ 裂项，素数判断。思路很巧妙，考虑到， $$ (u(n)-v(n)) \\times \\frac 1 {v(n) \\times u(n)} = \\frac 1 {v(n)} - \\frac 1{u(n)}$$ 所以我们就可以裂项相消了，于是， $Ans = 1/2 -1/3 + 1/3 - 1/5 + …….. -1/v + \\frac 1 {v\\times u\\times (n-v+1)}$ 消掉，约分即可。 CF283D。对于$(x,y)$，如果满足$x$可以表示为连续$y$个整数之和，则它是酷的。如果$(a1,a2),(a2,a3),..,(an-1,an)$都是酷的。那么整个序列就是酷的。给定长度为$n$的序列，求最少改变几个数字，使得整个序列是酷的。$n \\leq 5000$ 数论，动态规划。首先考虑$(x,y)$符合要求的条件，根据等差数列求和公式，可以知道：当$y$为奇数时，只要$x$是$y$的倍数；当$y$为偶数时，只要$2x$是$y$的奇数倍即可。观察第二个条件，也就是说$x$质因数$2$的个数比$y$质因数$2$的个数少$1$，对于其它部分$x’$是$y’$的倍数。受此启发考虑令$a[i]=2^{x[i]}\\times y[i]$，以方便状态的转移。 定义$f[i]$表示$i$是不变的，以$i$结尾的序列，需要满足条件，可以不改变的最长子序列。于是对于一个状态$i$我们寻找$j$同样是不改变的。 如果$a[i]$是奇数($x[i]=0$)，且$y[j] \\bmod y[i] = 0$ ，则$f[i]$可以由$f[j]$转移过来 如果$x[i]!=0$，条件就比较复杂。首先$y[j] \\bmod y[i] = 0$是一个必要条件，接下来考虑$x[i]$与$x[j]$ 考虑$x[i]$向前移动，如果向前移动一位，则$x$必定会减一，于是会出现两种情形。- 一是$x$还没有到$j$已经变为了$0$（也就是$x[i]&lt;i-j$），变为了奇数，一定能够在最后一次变为$x[i]$。 二是$x$到$j$时仍然不是$0$，这就要求$x=x[j]$，也就是说$x[i]-x[j]=i-j$。 至此，问题得到完整的解决。注意一点，我们可以在序列的最后增加一个数$1$使得之前所有状态的答案会聚到这一状态。 CF172D。给定$a,n$，求$[a,a+n-1]$所有数的贡献总和。一个数的贡献是其除掉所有平方因子后的部分。$n \\leq 10^7$ 莫比乌斯函数。考虑求出$[1,x]$的贡献，考虑首先$O(\\sqrt x)$枚举所有平方因子$p^2$。于是我们就需要知道$[1,\\frac x {p^2}]$中不是完全平方数的倍数的数之和，于是可以$O(\\sqrt {\\frac x {p^2}})$的容斥求出答案，容斥的系数就是莫比乌斯函数。复杂度$O(n)$。 CF451E。有$n$种颜色的❀，第$i$种❀有$fi$朵。求选出$s$朵❀的不同方案。$n \\leq 20,s \\leq 10^{14},fi \\leq 10^{12}$ 容斥原理，卢卡斯定理。考虑如果有$a$种颜色，选$b$朵，那么方案数就是$C(a+b-1,b)$。但是本题中❀数量的限制，所以考虑容斥。答案即为至少0个超过-至少1个超过+至少2个超过-…。 比如至少1个超过的是$i$，那么我们强制选择$i$所有的❀。组合数的计算可以利用卢卡斯定理。 CF448E。给出一个$x,k$，每次操作都会将$x$分解因数，得到新的序列，然后每次再分解序列中的每一个数，按照每一个数分解因数从小到大排，整体顺序不做调整。$x \\leq 10^{12}, k \\leq 10^{18}$ DFS+剪枝。为了加速分解，我们可以预处理$x$的所有因数。DFS(x,k)表示将$x$分解$k$次，只要枚举$x$的因数，如果可以整除继续DFS，如果超过$x$直接跳出。加了这个优化以后就很快了。 CF216E。给定一个进制$k$和一位数$b$。以及长度为$n$的序列（均小于$k$）求这个序列存在多少子序列，能通过变换变为$b$？这里的变换指的是，每次将k进制数x的每一位相加（k进制加法）得到一个新的数$x’$，直到最后得到一个一位数。$0 \\leq b&lt;k \\leq 1e9, n \\leq 100000$ $k$进制下模$k-1$的性质。注意到一个性质：对于一个$k$进之下的数，模$k-1$后的余数等于，各个数码之和模$k-1$的余数。考虑用$ans[i]$表示前$i$个数之和模$k-1$后的余数，若满足$ans[i]-ans[j-1]$模$k-1=b$则$[j,i]$是符合答案的，于是在扫描过程中记录一个数组$cnt[i]$表示$ans[j] \\mod k-1=i$的$j$的个数。注意特殊处理$b=0,k-1$的情况。 CF703E。给定$n,k$，和$n$个数$a[]$。求任意一个最短的序列${i}$满足$a[i1]\\times a[i2] \\times … \\times a[im]$是$k$的倍数。输出方案，当存在多种方案时，选择$\\sum i$最小的序列。$n \\leq 1000,k \\leq 10^{12}$。 GCD,动态规划。考虑到对于一个$10^{12}$数量级的数，其因数个数不超过$10^4$，而且本题中$a[]$是否满足条件是其乘积与$k$的GCD决定的。首先，预处理出所有$k$的因数$d[]$，定义状态$f[i][j]$表示前$i$个数中，乘积与$k$的GCD为$d[j]$所需要选择的最少数字。按照$i+1$是否选择转移即可。","tags":[{"name":"数论","slug":"数论","permalink":"https://xuzhean.github.io/tags/数论/"}]},{"title":"CodeForces-Educational-Round泛做&记录","date":"2017-08-22T02:00:00.000Z","path":"2017/08/22/Training-CF-Educational/","text":"未完成: 818G, 598F, 837D/F/G, 609F, 612F, 616F, 620F 呃，主要是把之前没有参加的Educational Codeforces Round补一补。QAQ。。。 Educational Codeforces Round 1-2017.8.22C:【题意】给定$n$个向量，求夹角最小的两个。 【题解】用$atan2(x,y)$可以求出向量与$x$轴的夹角，排序即可。卡精度！！ E:【题意】给定一个$n\\times m$的巧克力，划分一个巧克力的代价为长度的平方，求划分出$K$个小巧克力块的最小代价。 【题解】定义状态$f[i][j][k]$如题意，暴力转移，$O(n^3K^2)$的暴力可过。 Educational Codeforces Round 3-2017.8.23E:【题意】给定一个无向图，求必须包含某个点的最小生成树。$n \\leq 200000$ 【题解】这题可以倍增或者并查集按秩合并。其中并查集按秩合并常数较小。 Educational Codeforces Round 4-2017.8.24E:【题意】给定一个置换，求这个置换的平方根。$n \\leq 10^6$ 【题解】显然，我们需要将置换分解为若干个循环的乘积。如果一个循环的长度为奇数，那么它一定存在平方根。以一个$5$边形为例，它的平方根类似于一个五角星；如果一个循环的长度为偶数，单独的一个循环不存在平方根，如果有两个相同长度的循环，我们可以将这两个循环合并，得到他的平方根。 Educational Codeforces Round 5-2017.8.25E:【题意】给定$n,m$，求$n\\%1+n\\%2+n\\%3+…+n\\%m$的值。$n,m \\leq 10^{13}$。 【题解】一道数论好题。一开始无从下手，考虑打表。以$n=100,m=100$为例，发现前$10$项毫无规律，从$100$项到第$51$余数以公差为$1$递增，从$50$到$34$项，余数以公差为$2$递增。可以得到规律在第$\\large \\lfloor \\frac n r \\rfloor$到第$\\large \\lfloor \\frac n {r+1} \\rfloor$以公差为$r$递增，首项为$n \\%r$。于是利用等差数列求和公式即可。对于前面的$sqrt(n)$项暴力计算即可。 Educational Codeforces Round 6-2017.8.26D:【题意】给定两个长度分别为$n,m$的序列，要求至多交换两对不同位置数，使得$|Sa-Sb|$最小，这里的$Sa,Sb$分别表示两个序列的和。 【题解】对于不交换或只交换一对，直接暴力即可。如果交换两对，可以这么做：将所有对列举出来$(Ai,Bj)$。求出它们差，放在一个数组中。考虑首先排序，左指针从左往右扫，同时，右指针单调往左移。当右指针满足一定会使结果大于当前答案时，左移。每一次移动后，只要在可能的答案区间里扫一下即可。可能无法计算复杂度？ E:【题意】给定一颗树，每个节点有一个颜色$c(c \\leq 60)$。每一次可以修改一个子树的颜色，或者询问一个子树存在多少不同的颜色。 【题解】注意到颜色数很小，所以可以直接压成一个$long\\ long$，求出$DFS$序，并用线段树维护区间出现了哪些颜色。 Educational Codeforces Round 24D:【题意】给定n个数${c1,c2…}$和A，用$cntX(i)$表示${c1,c2,…,ci}$中等于X的数。询问是否存在B，使得对于任意i，都有$cntB(i)&gt;=cntA(i)$。 【题解】考虑一个个枚举B，首先判定$cntB(n)$是否不小于$cntA(n)$ 。发现答案的条件等价于：一个个比较A和B所在的位置，对于所有第i次出现的A，都满足第i个出现的B在前面。假设A的个数为m，则每次判断为$O(m)$，而满足前提的B的个数为$O(n/m)$ ，复杂度$O(n)$ 。 E:【题意】给定$n$个数${a1,a2…}$和$k$，问存在多少有序数对$(x,y)$满足：删除前$x$个数和后$y$个数，剩下数的乘积是$k$的倍数。 【题解】将k质因数分解（最多有10个不同的质因子），只要每个质因子的个数达到$k$拥有的就可以了。直接暴力枚举左端区间，发现右区间有单调性，直接维护一个滑动窗口就好了（比赛时写了二分233…）。 F:【题意】很好玩的题。 有q组询问，每组询问给出数n。问n个节点最多能连多少条边，使得桥的数量不少于总边数的一半。 【题解】有个很显然的结论：n个节点构成的图中桥不超过n-1个。因为无向图可以看一些树连一些边构成的，而n节点数恰好只有n-1个桥，连上的边一定不会成为桥。考虑这样构造：中间构造一个“K-完全图“，剩余的节点就往“完全图“上连单一的边，不难发现这样是存在k个桥时，边数最多的方案。 实际上，内部的图最多只有$min(n-k, \\frac{k(k-1)}{2}) $ 条边，于是总边数为$f(k)=n-k+min(n-k, \\frac{k(k-1)}{2}) $ 发现这个函数$f(k)$ 是个单峰函数，用三分法求解（最值两边有严格单调性）即可。 三分法的正确姿势。 ${Lmid=(2l+r)/3}~~~{Rmid=(l+2r)/3}$ ，当L和R差小于3后，暴力找出最值。 (坑)G：网络流难题。 Educational Codeforces Round 26","tags":[{"name":"泛做","slug":"泛做","permalink":"https://xuzhean.github.io/tags/泛做/"}]},{"title":"组合数学-生成函数的应用","date":"2017-08-13T12:05:00.000Z","path":"2017/08/13/Algorithms-Generation-function/","text":"更多的坑待填… 母函数是解决计数问题强有力的工具。在OI中也时有出现，不学就跟不上时代了啊。 前置技能常见幂级数展开$$(1-ax)^{-1} = 1+ax+a^2x^2+a^3x^3+…$$ $$(1-x)^2=1+2x+3x^2+4x^3+…$$ 部分分式运用待定系数发将分式分解为若干个分式的和。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"CodeForces泛做第一轮","date":"2017-08-08T00:08:08.000Z","path":"2017/08/08/Training-CF-Round1/","text":"完结，撒花~ 时间: 2017.8.8~2017.8.22 由于博主太弱了，所以在NOIP2017之前开了这么一个坑，差不多是#301到#360，中间还有一些非常规赛。就这样吧。。 未完成: 546E 568C/D 571B/D CF573D 578D 582D 594B 601D 603B 605A 611E 613B 613D(虚树) 638E 663B/D 666B 643C(斜率优化DP)/D 671C/D 676D/E Codeforces Round #301 (Div. 2)540C,4Y。BFS判连通。注意起始点与终点重合或相邻的情况，终点经过两次，只要有两个空格与终点相邻即可。 540D,1Y。概率DP。乘上转移的概率即可。 540E,3Y。离散化+树状数组统计逆序对。设出现的数为${a}$，未出现的为${b}$，发现a-&gt;a，a-&gt;b，b-&gt;a有贡献，分类讨论即可。 反思 把所有特殊情况考虑周全，仔细分类讨论。 Codeforces Round #302 (Div. 2)544C,1Y。二维完全背包DP。其实挺套路的，要加个滚动数组。 544D,1Y。暴力BFS。注意到两个点对的最短路径若存在交集，则一定是连续的一段。暴力枚举两点即可。 554E,1Y。状压DP。其实状压DP都挺套路的:①数据范围一般不超过20.②预处理加速转移.③转移时顺序无关，强制转移$lowbit$。 反思 注意观察题目性质，从多角度思考状态的表示。 Codeforces Round #303 (Div. 2)545C,4Y。贪心。注意到能往左倒就往左倒，否则能往右倒就往右倒，并不会使答案变差。注意$n=1$的情形。 545D,2Y。贪心。发现一定是$t$升序最优，对于一定不会满意的人，显然跳过放在最后最优。 545E,1Y。最短路DAG+DAG的最小树形图。由于数据范围过大，最小树形图并不能用朱刘算法来做。考虑是一个DAG，类似Kruskal依次加入权最小的边，保证弱连通块的入度为1.正确性不难感受到。 Codeforces Round #304 (Div. 2)546C,1Y。暴力。 546D,1Y。欧拉筛。考虑类似求积性函数的方式，可以推出每个数的素因子个数。 Codeforces Round #305 (Div. 2)548C,7Y。暴力求循环节+扩欧。坑点较多，注意分类讨论。 548D,1Y。单调栈或线段树。 548E,1Y。数论，容斥。考虑到一个数的素因子个数很少，直接暴力搜索容斥。 Codeforces Round #309 (Div. 1)553D,3Y。贪心。考虑现将所有的可以的点放入集合，每次取出权值最小的，更新周围点的权值。因为只有取出最小值，最小权才有可能变大。过程用堆维护即可。 Codeforces Round #310 (Div. 1)555D,2Y。贪心+堆。将问题转化为：给定一些数轴上的点，和一些线段，每个线段要匹配一个点。于是按照左端点不断加入线段，用堆维护右端最小的即可。 Codeforces Round #Pi (Div. 2)567E,1Y。最短路。首先求出最短路，反向建图后的最短路。注意到如果所有最短路都经过某一条边，那么相当于前驱最短路条数乘后继最短路条数等于总的最短路条数。如某一条边是最短路上的边，减一就可以满足条件。否则可以继续讨论。 567F,1Y。动态规划。注意到需要构造的序列是单峰的，所以考虑从小到大逐个加入两端。对于限制，DP到较大位置时判断即可。 反思 深入挖掘单调性(单峰亦同)寻找，寻找DP的阶段。 Codeforces Round #315 (Div. 1)568B,1Y。第二类斯特林数。注意到$n$等价关系能够对于到$n$完全图。于是答案即为，选取一些点(不能是全部)，划分为几个非空集合的方案数。假设选$i$个点，划分为$j$个集合，答案即为$C(n,i)\\times S(i,j)$。其中$S(i,j)$是第二类斯特林数，可以$O(n^2)$递推。 反思 从二元关系联系到图。 Codeforces Round #317 [AimFund Thanks-Round] (Div. 1)571A,2Y。正难则反+组合计数。有一个结论，将一个长度为$n$的序列划分为$3$个(可空)子序列，方案数为$\\large \\frac {(n+1)(n+2)} {2}$ 。加上不合法的方案，总方案即为$\\large \\sum \\frac {(n+1)(n+2)} {2}$。考虑减去不合法的情况，假设$a,b,c$伸长量分别为$x,y,z$，假设$a+x$最大。当$a+x&gt;=b+c+y+z$时不符，可以得到$b+c-a \\leq x \\leq l$，且$0 \\leq y+z \\leq min(a+x-b-c,l-x)$，于是$y,z$的方案同样可以由上面的结论算出。 571B,6Y。同余分组+贪心+动态规划。考虑分为$K$组，所有$a\\equiv b\\pmod K$分为一组。设$d=n/ K$发现，前$n\\ mod\\ K$组都有$d+1$个数，后$n-n\\ mod\\ K$组都有$d$个数。排序后即可DP。 Codeforces Round #318 [RussianCodeCup Thanks-Round] (Div. 1)573A,5Y。暴力。考虑将所有数的素因子2,3都去除，判断是否相同。 Codeforces Round #319 (Div. 1)576B,1A。构造。首先将置换分解为若干个循环，注意到一个性质，长度为$x$的置换能连上长度$kx$的置换，只有长度为$2$的置换能自己连自己。且能作为根的只有长度为1或2的置换，分类讨论即可。 576C,1A。构造。考虑按$x$轴划分为$T$个区间，每个区间平均有$n/T$个，可以来回移动，最坏情况下有$T\\times[10^9+(n/T)\\times(10^9/T)]=10^9(T+n/T)$的移动距离，显然取$T=\\sqrt n=10^3$最优。 576D,1A。矩阵快速幂+floyd。考虑到$m$很小，可以逐个加边，用矩乘维护连通性，同时用floyd求连通后的最短路。矩阵乘法次数过多，会超时。但由于矩阵维护的是01信息，所以可以用$bitset$优化。 Codeforces Round #320 (Div. 1) [Bayan Thanks-Round]578A,1Y。公式。发现$a&lt;b$时无解，由于$x$要尽可能小，所以点一定都是在所有三角的右侧。根据$a/b$就可以算出属于第$t$个三角形。于是$\\large x=\\frac {a+b}{2t}$即可。 578B,1Y。贪心，暴力。考虑到$k$次操作一定是都乘在同一个数上最优，求出前缀和后缀$or$值即可。 578C,3Y。三分，贪心。考虑到答案是关于$x$的单峰函数（显然？），于是三分即可。可以同$O(n)$的贪心求出最大字段和。 Codeforces Round #321 (Div. 2)580E,3Y。HASH+线段树。发现[l,r]是周期为d的串等价于$S[l,r-d]=S[l+d-r]$，于是考虑维护区间的HASH值即可。 Codeforces Round #323 (Div. 1)582A,2Y。暴力+map。考虑每次取出最大的数$x$，一定是$a$中的元素，再将$x$与之前取出的$gcd$暴力删除即可。 582B,1Y。LIS变形。考虑保留出现次数最多的元素$x$，首先取出长度为$n^2$的段，求出$LIS$，发现$x$一定可以找到某个位置插入，所以还要加上$x(T-n)$。 583C,2Y。数论。对于好数组的元素$a[i]$有， $\\forall k\\in N, a[i]=a[i+kn],a[i]&gt;=a[i+ks]$ 。即$\\forall k \\in N,a[i]&gt;=a[i+k\\times gcd(s,n)]$。也就是说a[i]是这些a[]中的最大值。考虑枚举$d=gcd(s,n)$。求出$f[i]$表示以$i$结尾最长满足条件的长度，以及$cnt[i]$即$gcd(n,j\\times d) = d\\ (j \\leq i)$的的个数。以$i$结尾，对答案的贡献即为$cnt[f[i]/d]$。复杂度$O(n的因子数\\times n)$。 Codeforces Round #325 (Div. 1)585A,1Y。模拟。用一个优先队列直接模拟即可。 585C,3Y。GCD。引入Stern–Brocot tree，将苹果数看作分子，橘子数看作分子，每次操作可以把$\\large (\\frac a b,\\frac c d)$变为$\\large (\\frac{a+c} {b+d}, \\frac c d)$或$\\large (\\frac a b, \\frac {c+a} {b+d})$。也就是它们的和在$Stern-Brocot\\ tree$上向左或向右移动。由于得到的分数一定是互质的，所以当$gcd(x,y)\\not = 1$时，没有答案。当$x&gt;y$时，会向左子树移动$\\large \\frac x y$次，之后$x\\ mod\\ y$会成为新的$x$。整个过程和求$gcd$类似，复杂度$O(log(x+y))$。 Codeforces Round #326 (Div. 1)587A,2Y。贪心。考虑逐个处理从小到大的$wi$，如果$wi=k$有偶数个，一定能组成$\\frac k 2$个$wi+1$，反之，能组成$\\frac {k-1} 2$个$wi+1$并需要用掉一个。 587B,4Y。DP。考虑将序列复制$k$次得到长度为$nk$的序列，然后DP加前缀和优化求出第$i$块第$j$结尾的方案数。多余的部分($T-nk$)答案等同于第$k$块。 587C,3Y。树上倍增。考虑到树上路径的问题，且不存在修改，考虑使用树上倍增。$g[i][j]$表示节点$i$到他的$2^j$的祖先，路径上最靠前的10个人被编号(注意去重)。合并的方式类似于归并排序。复杂度$O(10\\times nlogn)$。 Codeforces Round #327 (Div. 1) 590A,4Y。题意：给定一个长为$n\\ (n \\leq 5\\times 10^5)$的01串，每次对于$2 \\leq i \\leq n-1$，的$ai$会变成$a[i-1],ai,a[i+1]$的中位数。问经过多少次会变成一个稳定的串(即不会发生改变)。 构造。考虑长度为2或以上的0/1段一定是不变的，于是我们可以将中间的串单独提取出来，不难发现，由于不存在连续的串，一定是010101….(或101010….)这样的。最终的结果由两端决定。 590B,1Y。题意：要从$(x1,y1)$到$(x2,y2)$。一开始风速为$(vx,vy)$，$t$秒后$(wx,wy)$。速度不超过$Vmax$，求最少到终点的时间。保证风速小于你的速度，风速和你的速度都是向量。 二分答案。显然二分答案啊。事实上，可以看作空气是不动的，而目标点是逆风移动，对于答案$T$，只要新的距离$d \\leq Vmax\\times T$即可。注意按照$T,t$的大小关系分类。 590C,5Y。题意：给定一个$N\\times M$的矩阵，这个矩阵里有’1’, ‘2’, ‘3’, ‘.’, ‘#’，可以把’.’改成桥，使得所有1,2,3四联通，问最少把多少个’.’改变，如果不能输出-1。其中’1’,’2’,’3’本身是连续的。$N,M \\leq 1000$ BFS+分类讨论。 考虑到答案只存在于两种情况。一种是三个连通块都会聚到一点。还有一种是两个连通块连向同一个连通块。于是BFS求出123到所有格子的最短距离即可。 590D,2Y。题意：给定$n$个数，最多相邻交换$s$次，求前$K$个数能达到的最小值。 动态规划。注意到一个性质，当$\\large s&gt;=\\frac {n(n-1)} 2$时，一定能取到$n$个数中最小的$K$个。定义状态$f[i][j]$表示固定前$i$个位置，交换$j$次能得到的最小的和。然后，为了取消后效性，依次考虑我们从1到n位置上的数。状态$f[i][j]$能转移到状态$f[i+1][j+k-(i-1)]$，$k$代表放在$i+1$位位置的数。 Codeforces Round #330 (Div. 1)594A,1Y。博弈，贪心。注意到后手一定会去掉最外层的$\\large \\frac {n-2} 2$个点，排序后扫描即可。 594C,2Y。暴力，贪心。显然我们只需要删除最左/上/右/下的点即可。考虑按$x,y$分别排序。因为$k$不大，所以我们暴力枚举两端取了多少，之后上下同样处理。注意长宽都至少是1。 594D,1Y。题意：给定$n$个数，有$Q$个询问，每个询问要求您回答$\\large \\varphi(\\prod \\limits ^{r} _{i=l} a[i])$的值。$n,Q \\leq 2\\times 10^5$ 离线，线段树，数论。考虑到$n,Q$的范围过大，我们考虑离线。 根据欧拉函数$\\varphi$的定义，$\\large \\varphi(n) = n\\times \\frac {p_1-1} {p_1} \\times \\frac {p_2-1} {p_2}\\times …$，我们只需要求出区间内有那些质因数一颗。考虑按照询问的左端点排序，扫描过程中维护区间$[l,n]$，对于区间$[l,n]$内的每一个质因子，我们只需要在线段树内保留最靠前的一个，因为后面对答案没有影响。 删除$[l]$时，我们只要对于$a[l]$的每个质因子找出它后面的第一个质因子，在线段树上更新即可。复杂度$O(a\\times loga+Q\\times logn\\times loga)$。 Codeforces Round #333 (Div. 1)601A,3Y。最短路。注意到由于是一个完全图，所以一定存在某一种交通工具可以直达，剩下一个交通工具floyd即可。 601B,1Y。题意：给定$n$个数字$h[1..n]$。定义$\\large L(h)=max \\lceil \\frac {|h[j]-h[i]|} {j-i} \\rceil$给定$Q$个询问，每个询问给定$li,ri$求$[li,ri]$所有子序列的$L(h)$之和。 单调栈。可以将$(i,h[i])$看作平面直角坐标系上的点。发现定义的就是两点间斜率的最大值。考虑不管这些点是凸或者凹的，斜率的最大值一定是由相邻的两个点产生的。于是，我们只需要用单调栈求出每个$h[i]$的作用域即可。 601C,3Y。题意：有$n$场比赛，每一场比赛都有$m$人参与。每场比赛的得分都是这个人的排名（没有相等的）总分是$n$场比赛的分数之和。总排名定义为：总分严格小于他的人数+1。已知小K在n场比赛中的排名。所有人的水平相同，求小K的期望总排名。 期望DP。考虑到直接求出小K的排名过于困难，按照定义，只要求出总分严格小于他的期望人数。于是就想到，用$f[i][j]$表示$i$场比赛之后总分为$j$的期望人数。故有$\\large f[i][j]=\\sum \\frac{f[i-1][j-k]} {m-1} \\ (1 \\leq k \\leq m, k\\not = a[i])$观察式子，考虑到可以前缀和优化转移。 Codeforces Round #334 (Div. 1)603A,1A。贪心，DP。观察到，一个位置对答案产生了贡献，当且仅当这个位置的数与前面一个数不同。又由于只能翻转连续一段，所以DP时定义三种状态即可。 603C,3A。博弈论+SG函数。考虑引入SG函数，当$i$为奇数时，$SG[i]=mex{ SG[i-1]}$。当$i$为偶数时，能够进行第二种操作，$SG[i]=mex{SG[i-1], SG[i/2]\\ xor\\ SG[i/2]… }$，共有$k$个SG[i/2]的异或和，注意到这只和$k$的奇偶性有关。 考虑寻找规律。当$k$为奇数时，由于$SG[i]=mex{ SG[i-1], 0}$，所以之后的$SG[i]$一定是0/1间隔出现的。当$k$为偶数时，$SG[i]=mex{ SG[i-1], SG[i/2]}$，并且注意到$i$为奇数时，$SG[i]=0$，所以只要$log\\ a[i]$次递归调用即可。 Codeforces Round #335 (Div. 1) 605A,1A。题意：给定$n$的一个排列，每次可以把一个数放到开头或末尾，求变为升序的最少步骤。 贪心。考虑那一段是可以不用变化的，发现就是数字连续上升的最长字段（例如,..,1,2,..,3,..,4,…）于是$O(n)$扫一遍即可。 605B,1A。题意：有一个$n$个点，$m$条边的图，然后$m$条边中有$n-1$条边构成了最小生成树，然后边权与是否作为MST的边告诉你，要构造出这个图。 最小生成树的性质，贪心。考虑首先构造出他的最小生成树，再往上面加边。考虑到最小生成树的边不能被新加入的边$(u,v)$代替，所以需要$u,v$之间的路径的边尽可能少，所以可以强制$root=1$剩下的$n-1$个点直接连到$root$。将最小生成树的边与其他边按照边权排序。 每加入一条MST的边，可以与前面的节点产生一些新的点对，由于边权是升序的所以之后的其他边一定不会产生冲突。注意我们只需要保留最小的$m$条即可。 605C,3A。题意：有$n$项工作，第$i$项工作每天可以带来$ai$的经验，$bi$的钱。问最少几天可以得到$p$的经验和$q$的钱。工作天数可以是小数，每次只能进行一种工作。 二分答案，凸包。首先考虑二分答案$T$。如何$O(1)$来check？我们将$(ai,bi)$看成坐标系上的一个点$Pi$，由于工作时间可以是小数，通过线性变换，$Pi,Pj$可以变换为线段$PiPj$上的点。所以可以先求出凸包，然后二分答案判断即可。 605D,1A。题意：玩家有两个属性$x,y$，有$n$个魔法。对于第$i$个魔法，用$(ai,bi,ci,di)$描述。当$ai \\leq x, bi \\leq y$时，玩家能使用这个魔法。之后玩家的属性$x=ci, y=di$。求施展第n个魔法最少需要多少次。输出方案，答案不唯一。 线段树（树状数组）+set，BFS。由于需要求出最小的步数，所以需要用到BFS。考虑到达了点$(x,y)$，我们可以到达在它左下角的点$(x’,y’)$，所以就需要用一个数据结构求出。树套树显然可以，不会写。考虑线段树（树状数组）套set，访问过后暴力删除。考虑其时间复杂度。由于每一个点最多在$O(logn)$个$set$中出现，单次操作复杂度$O(logn)$，所以总的时间复杂度$O(n\\times logn \\times logn)$，不会超时。 Codeforces Round #336 (Div. 1) 607A,4A。题意：有$n$个点，点有位置和能量，$i$个点被选择，那么在$i$左边它这个能量的位置内的所有点都不能选择，如果现在从右到左依次选择点。现在可以在最右边放置一个点，能量和距离随意，问各种情况下最小摧毁的点的个数。$N \\leq 100000,ai \\leq 1000000$ DP。考虑到点的坐标范围较小，令$f[i]$表示到位置$i$时，最多能放的点。于是$f[i]=max(f[i-1],f[i-d[i]-1]+1)$。 607B,1A。题意：长度为$n$的字符串，每次消去一段连续的回文串，剩下的两端重新拼接成一个新的串，问最少需要消去多少次。$n \\leq 500$ 区间DP。令$f[i][j]$表示区间$[i,j]$需要消去的最少次数。发现有两种决策：一种是从$f[i][k]+f[k+1][j]$转移过来，将$[i,j]$划分为两个更小的子段；还有一种是从$f[i+1][j-1]$转移，因为中间肯定存在其他回文串，所以不用$+1$。 607C,3A。题意：有两个独立的坑道，由“NSWE”表示。两个球在各自坑道的起点。之后对两个球做相同的操作，上下左右。保证两个小球保持一致的动作，其中一个撞墙的话不用管。问能不能保证两个小球都能从起点到达终点。到达终点后，还有可能因为操作而退出。 脑洞，HASH。考虑依次让两个球分别到达终点，可以猜测一个结论，无法到达当且仅当第一个球达终点后，第二个球需要到达终点的步骤，恰好使得第一个球退出（证明有些困难）。于是可以改变第一个球轨道的方向，就变成字符串匹配的问题。 Good Bye 2015 611C,1A。题意：有一个$n\\times m$的网格，‘#’不能摆。有$Q$个询问，每个询问$(r1,c1,r2,c2)$求出这个子矩形内可以有多少种方式放一个$1\\times 2$的骨牌。$n,m \\leq 500,Q \\leq 100000$ DP，容斥。注意到，对于一个询问，我们可以将其拆成4个前缀询问。而这个前缀询问可以预处理，令$f[i][j]$表示$[1,1]$到$[i,j]$骨牌的摆放方式。$f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]-[i,j]$能放的骨牌数。对于查询，我们只需要再次容斥，暴力删除边界的答案即可。复杂度$O(n^3+nQ)$。 611D,1A。题意：把一个长为$n$的数字串拆成多个串，要求这些串的数值递增的，并且没有前缀0，问有多少种分法。$n \\leq 5000$ DP，LCP。定义状态$f[i][j]$表示$[1,i]$中划分了最后$j$个的方案数。发现状态难以优化，考虑从加速转移入手。假设前一段划分的长度为$k$，注意到当$k \\leq j-1$时，显然能够转移，即$f[i][j]=\\sum _{k=1} ^{j-1} f[i-j][k]$，这一部分可以前缀和优化。还有可能是从$f[i-j][j]$转移到$f[i][j]$，就需要比较$[i-2j+1,i-j],[i-j+1,i]$的大小。由于长度相等，实际上就是在比较字典序。而比较字典序有一个常用的方法，可以求出以$i,j$开头的最长公共前缀，记为$lcp(i,j)$，这样预处理后就可以$O(1)$转移了。 Codeforces Round #339 (Div. 1) 613A,1A。题意：有个$n$边形，给定了所有点的坐标。有一个点$P(x,y)$。这个$n$边形会绕着点$P$旋转。求这个多边形扫过的面积。 计算几何。发现我们只需要求出点到多边形的最近和最远距离，对于最远距离，一定是在某个点上，而对于最近距离，还有可能在边上。发现一定是做垂线最优，利用三角形面积公式和叉积即可，但垂足一定要在多边形上，用点积判断是否是钝角即可。 613C,5A。题意：有$n$种颜色的珠子，每个珠子有$A[i]$个，要把这些珠子串成一个环，你可以在其中一些地方断开，如果断开后是回文，$Ans+1$，问最大$Ans$。 脑洞，GCD，构造。首先特判$n=1$的情况，就是$A[1]$。注意到，若存在两种以上的珠子数目为奇数，则一定无法构成回文串。 不难发现我们可以划分为$gcd$段，考虑$gcd$的奇偶性。若$gcd$为偶数，在每一段内，我们可以任意放置，之后的每一段，间隔着倒置即可，$Ans=gcd$。若$gcd$为奇数，由于不存在两个以上奇数，所以每一段内恰有一个奇数，我们只需要把这个奇数放在中间，两边对称放置即可。 Wunder Fund Round 2016 (Div. 1 + Div. 2 combined) 618C,2A。题意：给定$n$个点$(xi,yi)$。求一个三角形$ABC$。满足其他的点都在三角形以外。输出任意一个三角形三个点的下标。$n \\leq 100000$ 乱搞，计算几何。考虑按照$x$轴排序，任意三个点形成的区域一定不包含其他点。只要并满足三点不共线即可。 CF618E,2A。题意：给定$x$正半轴上的$n$段线段。有$m$个操作，操作1是给定$x$，然后把第X段延长$y$。操作2是把某&gt;一个段按照原先的左端点旋转α°。每次操作询问原先最右边的端点的位置。$n,Q \\leq 100000$。 线段树，计算几何，矩阵。有很多方法可以解决此题。考虑使用线段树求解，考虑维护线段另一端到这端的相对位移。对于操作一，只需要求出原长，然后新的$(x’,y’)$可以通过比例求出。需要注意的是操作二，对于某一点$(x,y)$绕原点$O$逆时针旋转$a$的弧长，有如下公式（窝不会证）。 $$x’=x\\cdot \\cos\\alpha - y\\cdot \\sin\\alpha$$ $$y’=x\\cdot \\sin \\alpha + y \\cdot \\cos \\alpha$$ 事实上，我们需要旋转$[x,n]$所有线段，这样就能解决了。 还有一种方法使用矩阵。维护区间的转移矩阵即可。 CF618F,1A。题意：给定两个多重集$A,B$，每个数$\\in [1,n]$。在$A$中选取一个含$Ka$个元素的非空子集。在$B$中也是如此（有$Kb$个元素）。要求使得两个子集之和相等。$n \\leq 100000$。 构造，抽屉原理。如果不存在范围的限制，这是一个NP问题？考虑构造，首先我们按照元素大小升序排一遍序，分别求出其前缀和$SA[i],SB[i]$，下标为$[0,n]$共$n+1$个。不失一般性，我们令$SA[n]&gt;=SB[n]$。考虑$i$从$0$扫到$n$，每一次求出$SB[j]&lt;=SA[i]$最大的$j$。不难发现$0 \\leq SA[i]-SB[j]&lt;=n-1$，而总共$i$有$n+1$种。所以，根据抽屉原理，一定存在两个不同的$i,i’$使得$SA[i]-SB[j]=SA[i’]-SB[j’]$。移项得， $$SA[i]-SA[i’]=SB[j]-SB[j’]$$ 于是在$A$中取$[i’+1,i]$，在$B$中取$[j’+1,j]$就是一组解。 AIM Tech Round (Div. 1) CF623A,4A。一个由$a,b,c$组成的字符串，可以这样生成一张图，当$s[i]$与$s[j]$不是一个$a$一个$c$时，$i$与$j$连一条边。给定生成的图，求是否存在字符串能生成这张图。$n \\leq 500$ 二分图染色。考虑到其反图，一定是由$a,c$组成的，且相邻的边不同。对于不在反图中的点，考虑改为$b$。这样似乎就好了？事实上，若原来的图中存在一条边，在新生成的字符串中为$a,c$，答案是不符的。 CF623B,2A。有一个数列，可以删除其中一段，删一个代价为$a$。也可以选择对其中一些数进行增加或者减少1，每次代价为$b$，问最后使得所有的$gcd$比1大，最小代价是多少。 gcd相关，动态规划。注意到，由于并不能删光全部的，而且删除的是连续一段，所以$a1,an$中必定存在一个剩余，于是对$a_1-1$，$a_1$，$a_1+1$，$a_n-1$，$a_n$，$a_n+1$操作找到其质因数，用DP求出都变为这个质因数倍数的最小代价。状态定义可参考CF603A。 CF623C,10A。平面上有$n$个点$(xi,yi)$。每个点可以变成$(xi,0)$，或$(0,yi)$。所有的点变换之后，两点最大距离的平方的最小值是多少。$n \\leq 100000$ 二分答案。细节非常多的一题，需要注意的地方很多。首先按照$x$排序，求出前缀后缀的$y$最大最小值。二分答案$ans$，考虑如何通过$O(n)$扫描判断可行性。答案会有三部分影响，一是$x$轴之间的，取决于$x$轴上的最高最低点，二是$y$轴上的，同样如此，三是$x,y$之间的，取决于$x$和$y$的绝对值最大值。 我们需要从左往右，从右往左各进行一次扫描。假设$l$是选取最左端在$x$轴上的，显然我们一定是选择连续的一段最优，且右侧的不对答案产生影响，$r$处是满足$|x[l]| &gt;= |x[r]|$最右侧的点，对于每对$(l,r)$还要进行判断。显然$l,r$都是单调移动的，所以整体判断的复杂度是$O(n)$。注意到，移动过程中可能出现一些非法情况，需要通过缩小范围解决。具体参见代码。 CF623D,1A。题意：给定$n(≤100)$个人，每轮随机猜一个人，每个人被猜中的概率为$pi\\%,\\sum pi\\%=1$，游戏结束当且仅当每个人被猜中一次或以上。问在最优策略下，期望结束轮数是多少。 贪心，DP，神题。以下抄自dalao的博客。设$f[i][j]$表示第$i$轮结束之后，第$j$个人被抓过的概率。设$g[i]$表示第$i$轮结束之后，所有人都被抓过的概率。 首先，考虑到$g[i] = \\prod ^{n} _{j=1} f[i][j]$ ，答案即为 $$Ans = \\sum ^{+∞} _{i=1} i\\times(g[i]−g[i−1])$$ 于是最优策略即为，尽量使得$i$较小时，$g[i]−g[i−1]$较大。注意到$f[i][j]$和$f[i−1][j]$的关系。 第$i$轮不选$j$，$f[i][j]=f[i−1][j]$ 第$i$轮选$j$，$f[i][j] = f[i−1][j] + (1−f[i−1][j]) \\times pj$ 所以，$\\large g[i] = g[i−1] \\times \\frac {f[i][j]} {f[i−1][j]}$ 。只要求$\\large \\frac {f[i][j]} {f[i-1][j]} $最大即可，这个可以枚举。其实$3 \\times 10^5$轮过后答案就不会再有大于$10 ^{−6}$的误差了。误差分析窝不会。 8VC Venture Cup 2016 - Final Round (Div. 1 Edition) CF634A,1A。有$n$个岛屿，1连2,2连3,…..n-1连n,n连1。初始有n-1个岛屿上有雕像，只有一个岛屿没有。若两个岛屿相邻且一个无雕像、一个有雕像。则可以将雕像移到无雕像的岛屿。给定初状态和末状态，问可不可以达到。$n \\leq 200000$ 暴力。发现空的岛屿可以忽略，对于剩下的岛屿，只要初末状态循环同构即可。可以强制将雕像1放在岛屿1。 CF634B,1A。给定$S$和$X$，问有多少对$(a,b)$满足$a+b=S, a \\oplus b = X$。 位运算的性质。注意到异或是没有进位的加法，两个二进制位$a,b$发生进位，$a=b=1$。所以有， $$a + b = a \\oplus b + a\\ \\&amp;\\ b $$ 也就是说，我们可以求出$a\\ \\&amp;\\ b$的值。逐个考虑$a\\oplus b$的每个二进制位。若某一位为0，此时只要令$x=y=x\\ \\&amp;\\ y$恰好仅有一种方案。若某一位为1，则$x,y$一定是一个1，一个0。当且仅当$x\\ \\&amp;\\ y=0$时存在两种情况，否则无解。注意，题目中要求的是正整数，所以$S=X$时，答案需要减2。 CF634C,1A。题意：工厂每天产出$a$件商品，设备需要维修，维修前每天产出$b$件商品，维修需要$k$天。这$k$天没有产出。给出一些订单的日期和数量以及一些查询，每次查询给出一个维修开始日期$p$，表示第$p$天开始维修在$n$天内最多可以接多少单（商品数量），注意订单只能当天完成。$n,Q \\leq 200000$ 树状数组。考虑建立两个树状数组，一个是维修之前，一个是维修之后，能最多完成的商品数量。只要不超过上限即可。 Codeforces Round #345 (Div. 1) CF650A,2A。题意：给定$n$个点，求存在多少点对，满足它们的欧几里德距离等于曼哈顿距离。可能包含相同的点。 容斥原理。注意到仅有当两个点在同一行或列时，满足条件。所以只需要求出每一行或列的个数即可。相同位置的点会计算多次，减去即可。 CF650B,1A。题意：有$n$张图片，有$T$时间。每次可以往左者往右翻阅，1的左边是$n$。然后，每张图片有2种阅读方式，一种是w，一种是h，其中w的照片需要花费$b$的时间翻转然后变成h，花费1的时间看。问最多能看多少照片。 滑动窗口。因为存在环，所以首先考虑倍长。可以看照片一定是一段区间，所以维护左右指针，单调移动即可。 CF650C,3A。题意：给定一个$n \\times m$的表格，您需要压缩它，压缩后仍是$n \\times m$的表格。需要保证压缩前后，同一行，同一列，它们的相对大小关系不变（小于还是小于，等于还是等于）。求压缩后表格最大数的最小值。压缩前后的表格上的数都是正数。$nm \\leq 10^6$ 贪心，并查集。依次考虑从小到大的所有数。对于一个数$a[i][j]$它需要大于第$i$行和第$j$列所有已经加入的数，对于所有相等的$a[i][j]$，因为在同一行或列时必须相等，可以使用并查集将所有点连起来，找到这些点至少需要的新的值。 CF650D,1A。题意：给定一个长度为$n$的数列，和$m$个询问，每个询问给出$Ai,Bi$表示把第$Ai$个数改成$Bi$之后，这个数列的最长上升子序列（严格大于,询问相互独立）。$n,m \\leq 400000$ LIS，树状数组，离线。考虑离线，对于一个询问，可以发现答案由两部分。一是改为$Bi$后，经过$i$的LIS，这个只需要从前到后，从后到前各扫描一遍即可。二是不经过$i$的LIS。如果$i$不一定是原序列LIS一定经过的数，则该部分的答案为LIS，否则为LIS-1。 考虑如何判断一个位置是否一定是LIS要经过的。如果满足$pre[i]+suf[i]=LIS+1$，存在LIS经过$i$。如果还满足$pre[i]=pre[j]\\ (i\\not = j),pre[j]+suf[j]=LIS+1$则说明$i,j$是可以互换的，则不是LIS一定经过的数。 CROC 2016 - Elimination Round CF645C,1A。题意：有一个有$n$个房间的酒店，FJ带上了他的$k$头cow。有一些房间是空闲的，FJ要订$k+1$间房间，使得FJ到最远的奶牛距离最小。$n \\leq 100000$ 二分答案。考虑枚举FJ所在的位置，二分答案$d$。只需要满足区间内空的房间数大于等于$k+1$即可。只需要预处理前缀和。 CF645D,1A。题意：有一个有向图，如果不构成唯一的拓扑排序，输出$-1$，否则输出最小的$k$，使得前$k$条边就能满足唯一的拓扑排序。 二分答案，拓扑排序。发现显然答案具有单调性，考虑二分答案$k$。只要有向图的最长链为$k$，就存在唯一的拓扑序。 CF645E,2A。题意：给定$n,k$，和一个字符串$t$，要在$t$后面加上n个不超过’a’+k-1的字母。问不同的子序列最多能有多少。$n,|t|&lt;=1000000,k \\leq 26$ 动态规划好题，单调性。考虑如何求一个给定字符串的不同子序列个数。其实，难点就在于如何避免重复计数。定义$f[i][j]$表示前$i$个字符串中取出，且结尾字符为$j$的方案数。两种情况： $$\\forall str[i] \\not = j, f[i][j] = f[i-1][j]$$ $$\\exists str[i] = j, f[i][j] = \\sum _{t=1} ^{k} f[i-1][t]+1$$ 如何理解第二种转移？事实上就是在前$i-1$个的基础上，强制增加了$str[i]$，加一指的是单个的$str[i]$，不难发现，对于每一个$i$，都不存在重复计数的情况。通过维护$sum = \\sum f[i][j]$可以在$O(n)$的时间内求出所有的$f[]$。 如何才能使得新增$n$个字符后最优，还是从状态转移方程入手。要使得$sum$尽可能地大，就要使得$f[][j]$最小，因为这样增加的值最大。可是这里是取过模的，如何比较大小？注意到$f[i][str[i]]$是随着$i$单调递增的，所以我们只需要维护所有字符上一次出现的位置即可。 IndiaHacks 2016 - Online Edition (Div. 1 + Div. 2) CF653E,2A。题意：有$n$个点，$m$条不是树的边，其中节点1的度数为$k$。问能不能构成这样一棵树。 set优化BFS。考虑从2到n的点构成的连通块。发现存在三种情况会无解： 1连出去的边少于$k$； 存在连通块，不能和1相连； 存在多于$k$个连通块，一定有连通块无法连接。 如何求出所有连通块？朴素的BFS由于需要寻找出边，复杂度$O(n)$。考虑到有很多点已经访问过，所以用set维护未访问的点，记为$list$。如果是无法连接的点，则需要跳过，为什么这样复杂度仍是对的？注意到，这种情况只会出现$O(m)$次，所以总的时间复杂度$O((n+m)\\times \\log n)$。 VK Cup 2016 - Round 1 CF639B,4A。给定$n,d,h$，请构造一颗有$n$个节点的树，满足其高度为$h$，深度为$d$。 构造。首先判断无解的情况，如果满足$d&gt;=2h$，或$d=2$且$n \\not = 2$，则一定无解。首先构造长为$h$的链，再构造长为$d-h$的链，剩下的都连到1即可。注意要特判$d=h$的情况。 CF639C,1A。定义一个合法的$n$次多项式$f(x)$，满足最高项系数$a[n]\\not=0$，所有系数$ai$都是整数，且绝对值不超过$K$。现在给您一个合法的$n$次多项式$P(x)$，但$P(2)\\not=0$。您需要改变其中一个系数，得到一个$n$次多项式$Q(x)$。满足$Q(2)=0$。求方案数。$n \\leq 200000$ 贪心，脑洞。考虑从低位到高位上传系数，使得系数$ai$变为$1,-1,0$，只有$an$不满足。不难发现，如果我们需要更改系数$ai$，若$\\exists j&lt;i,a[j] \\not = 0$则无法通过改变$ai$使得满足答案，记最大能够满足的为$flag$。 从高位向低位扫描，每一次维护更高项的等价系数$sum=sum \\times2 + a’[i]$，也就是说高位的数字之和等于$sum \\times 2^i$。若$i \\leq flag$可以尝试将原来的$a[i]$改为$a[i]-sum$，若其绝对值不大于$K$，是满足条件的。注意最高项的新系数不能为0。 CF639D,2A。有$n$个人，每个人都有自己的贡献$ti$（任意整数）可以花费$b$，使得某个人的贡献$+5$。花费$a$，使得某个人的贡献$+1$。求至少使得k个人的贡献相等，最少需要的花费。$1 \\leq k \\leq n \\leq 200000$ 模意义下分类，贪心，优先队列。首先考虑$5c$和$b$的关系，当$5c&lt;b$是显然令$b=5c$可以更优。由于两种操作的代价不同，所以无法简单地通过两个指针来解决。 考虑按最终答案模$5$的值$=d$来分类，首先我们要修改所有的数使得所有的数模$5=d$，记这一部分花费为$x$。我们还要选择一个最大的$a[r]$，修改其他的$k-1$为$a[r]$。贡献如何计算，即为$\\large \\sum(x + \\frac {(a[r] - a[i])b} {5})$。于是将这个括号拆开，拆出一部分与$a[r]$无关的，用堆维护最小的$k$个即可。 Codeforces Round #347 (Div. 1) 663A,2A。给定一些形如$?+?-?+?+?=n,?-?-?+?=n$的表达式，最后一个数字为n，在前面填$[1,n]$的数，问是否满足条件的等式，可能输出“Possible“并给出一组解。$n \\leq 1000000$ 构造。考虑怎样的等式能够满足条件，记增加的数的个数为$A$，减少的为$B$。若$A-nB \\leq n \\leq nA-B$则一定有解。于是每次一确定一个数，此时两边消掉这个数，得到新的$N$，同时$A$或$B$减一，只要新的$N$仍满足这个条件即可。 663B,1A。有一个$n$个点，$m$条边的无向图。开始每条边的颜色都是给定的，玩家选择一个顶点，把相邻的边的颜色反转一下，问使得所有边颜色相同。最少反转几下，输出那些反转的顶点。只有两种颜色。$n,m \\leq 30000$ 并查集。不失一般性，考虑将所有边的颜色改为蓝色。然后每一个点有选，或不选两种状态。逐个考虑每一条边，若这条边是红色的，则两个点的状态不同，否则这两个点的状态相同。 于是可以维护两个并查集即可。如何要保证最小？对于每一个连通块，一定被分为两个集合，只需要取其中较小的即可。注意将所有边改为红色也要尝试，因为对应并查集的合并方式不同。 CF663E,2A。有一个$n\\times m$的表格，包含0或1。每一次可以选择一行，或一列翻转(0&lt;-&gt;1)。求一些操作后，1的个数的最小值。$n \\leq 20,m \\leq 100000$ 快速沃尔什变换。考虑$O(2^n\\times m \\times n)$的暴力，枚举每一行的状态，然后$O(nm)$统计。事实上，统计可以优化到$O(m)$，假设第$i$列的状态为$a[i]$，行的状态为$s$，于是第$j$列的个数即为$\\min(|a[j] \\oplus s|,n-|a[j]\\oplus s|)$。 $$\\large Ans[s] = \\sum _{i=1} ^m \\min(|a[j] \\oplus s|, n-|a[j] \\oplus s|)$$ 记 $$\\large v[i] = \\min(|i|, n-|i|)$$ 那么 $$\\large Ans[s] = \\sum _{i=1} ^m v[s\\oplus a[i]]$$ 令 $$\\large cnt[x]为a[i]=x的个数$$ 得到 $$\\large Ans[s] = \\sum _{i=0} ^{2^n-1} cnt[i] \\times v[s \\oplus i]$$ 发现就是异或卷积的形式： $$\\large C = \\sum _{j \\oplus k = i} A[j] \\times B[k]$$ 就可以用$FWT$啦。具体FWT的总结以后填吧QAQ。 VK Cup 2016 - Round 2 CF641B,1A。原来有一个$N \\times M$的矩阵，要求满足一些操作：某一行循环左移，某一列循环上移，给定某个位置的元素是什么，求出最初的矩阵。$n,m \\leq 100, Q \\leq 10000$ 模拟。注意到一个性质，这些操作都是可逆的，所以我们只要倒着执行操作即可。 CF641C,1A。给定$n$个数，$1, 2, 3, 4, 5, 6,…, n$。有两种操作，第一个操作是所有数向右边移动x个位置。第二个操作奇数和偶数的位置互换。输出最后的数。n为偶数。$n \\leq 1,000,000, Q \\leq 2,000,000$ 脑洞，模拟。如果仅仅只是暴力修改的话，时间复杂度将无法忍受。注意到一个性质，不管如何操作，奇数偶数都是间隔排列的，而且它们内部的顺序并不会发生改变。所以我们只需要维护$1,2$所在的位置即可。为了方便，可以令下标从$0$。 CF641D,1A。有两个不同的骰子，点数$[1,n]$。得到每个点数的概率可能不同（总和一定是$1$）。掷出这两个骰子，得到点数$a,b$。取$\\max(a,b), \\min(a,b)$。给出$\\max(a,b)=c$的概率分布，和$\\min(a,b)=c$的概率分布。还原两个骰子点数的概率分布，所有概率之和为$1$。$n \\leq 100,000$ 概率，数学。假设第一个骰子的概率分别为$x[i]$，第二个$y[i]$。考虑位置$p$，不难注意到，$P(p\\ is\\ \\min)+P(p\\ is\\ \\max) = x[p]+y[p]$。而根据$1$是最大值的概率，得到$x[1] \\times y[1]$，能知道$x[1]$和$y[1]$。然后逐个处理每个位置$p$。根据$x[p] \\times \\sum {i=1} ^{p-1} y[i] + y[p] \\times \\sum {i=1} ^{p-1} x[i] + x[p] \\times y[p] = P(p\\ is\\ \\max)$ ，就可以推出所有的$x[p],y[p]$了，需要维护$x[],y[]$的前缀和。 CF641E,2A。有三种操作。$1\\ x\\ y$，在第$x$秒插入一个$y$。$2\\ x\\ y$，在第$x$秒移走一个$y$。$3\\ x\\ y$， ，问第$x$秒有多少个$y$。$n \\leq 100000$ map，树状数组。考虑首先离散化时间，以时间建立两个树状数组。维护区间时间内，删除和增加的元素个数。考虑到存在重复，所以可以用map维护。注意，虽然也可以用mulitset，但由于它的count复杂度为$O(n)$，会超时。 Codeforces Round #349 (Div. 1) CF666A,1A。给定一个字符串，这个字符串可以划分成最前面$[5, \\infty]$个字符，然后后面接着每次$2$个或$3$个，后面的相邻字符串不能重复，问所有可能的情况中，后面所有字符的集合是什么。$len \\leq 10^4$ DP，set。由于只要满足相邻的字符串不重复即可，所以可以DP判断所有位置的可行性。把答案存入set，就可以保证不重复。 CF666C,4A。给定一个字符串$s$和$m$次操作。第一种操作，是将字符串$s$替换为一个新的字符串。第二种操作，给定$n$，询问长度为$n$，仅包含小写字母且$s$是其子串的字符串个数。$n,\\sum |s|&lt;=100000$ 分块，DP。首先注意到一个性质，答案仅与字符串的长度有关。考虑如何求出只有一个字符串的情况。考虑$f[i]$表示母串长度为$i$时的方案数。于是， $$ \\large f[i] = f[i-1] + C _{i-1} ^{len-1} \\times 25 ^{i-len}$$ 如何理解第二部分？事实上就是强制第$i$放最后一个$s[len]$然后前面的$i-1$个位置任意选择$len-1$个，强制每一个都是第一次出现，所以剩下的所有位置都有$25$种选择。 看上去复杂度不对？事实上，由于$\\sum |s|&lt;=100000$，所以不同的$len$最多有$\\sqrt{\\sum |s|}$个。复杂度$O(n \\sqrt n)$。 VK Cup 2016 - Round 3 CF643B,1A。给定$N,K$和$a,b,c,d$，问是否存在这样两条路径，使得这两条路径经过所有城市，并且从$a$到$b$，和从$c$到$d$，长度为$N$，整个边数不超过$K$。要输出两条路径，要满足$a$到$b$没有路，$c$到$d$没有路。$4≤n≤1000, n-1≤k≤2n-2$ 构造。首先我们需要根据$a,b,c,d$是否存在重复来分类，对于每一类，我们需要图的边数尽可能少，这样的话，我们可以在中间构造一条链，然后两端是两个三角形。这样一定是最优的。 CF643C,1A。要求维护一棵树，支持以下两种操作：1、以某个节点为父亲，插入一个节点；2、询问对于以某个节点为根的子树，若子树当中每条边有$0.5$的概率被删除，那么整棵子树最大深度的期望值是多少。初始时，树中仅有一个节点。$Q \\leq 100000$ 树形概率DP。考虑定义状态$f[i][j]$表示以$i$为根的子树，其最大深度不超过$j$的概率。于是， $$\\large f[i][h] = \\prod _{j \\in {son[i]}} 0.5 + 0.5 \\times f[j][h-1]$$ 如何理解这个式子？有$0.5$的概率新加入的边删去，$0.5$的概率未删去，此时还要保证$j$的最大深度不超过$h-1$。可以注意到，如果增加了一个节点，我们可以修改它所有的祖先节点。但由于改变量减少极快，所以经过$limit = 60$次左右的更新，已经可以忽略不计。复杂度$O(n \\times limit)$ Codeforces Round #352 (Div. 1) CF671A,1A。有两个人独立地捡垃圾，求他们一起捡完所有垃圾所走的最短路程，从初始点找到第一个垃圾，然后送到垃圾桶，再从垃圾桶出发捡垃圾再送回。人，垃圾，垃圾桶都在二维坐标系中。一个人一次只能拿一个垃圾。$n \\leq 100000$ 贪心。注意到，其他的垃圾到垃圾桶的距离和不变，只要第一次人拿垃圾的代价最小即可。 CF671B,1A。有$n$个数，和$K$次操作。每一次需要把最小的数$+1$，最大的数$-1$。求最后，最大最小的数之差。所有数相同后，不会再改变。$n,K \\leq 100000$ 二分答案。我们可以二分出最小，最大的数。对于$K$较大的情况，只要判断总和是不是$n$的倍数即可。 Codeforces Round #353 (Div. 2) CF675E,1A。有$n$个火车站，第$i$个火车站能够到$[i+1,ai]$。令$p[i][j]$表示从$i$到$j$的最少次数。求$\\sum p[i]j$。$n \\leq 100000$ 贪心，DP。令$f[i]$表示$\\sum p[i]j$，我们尽可能希望，通过走两次之后，能够到达的位置最远。假设这个位置是$m$。那么$f[i]=f[m]+n-i-(a[i]-m)$，如何理解？对于剩下的$n-i$个位置，有$a[i]-m$是可以通过一次转移到达的，否则都是在先走到$m$的基础上再走到别的点。 Codeforces Round #360 (Div. 1) CF687A,1A。给你$m$组边，若能构成二分图输出左右两个点集和个数，若不能输出$-1$。 二分图染色。并查集裸题。","tags":[{"name":"训练","slug":"训练","permalink":"https://xuzhean.github.io/tags/训练/"}]},{"title":"组合数学-Burnside引理与Polya定理","date":"2017-08-05T12:05:00.000Z","path":"2017/08/05/Algorithms-Group-theory/","text":"更多的坑待填… 参考资料 说明 在OI中群论主要用于等价类计数，其中Burnside引理与Polya定理是其核心。 一些定义及定理群。群$G$是一个定义在二元组$(S,⋅)$的代数结构，$⋅$是一个二元运算符。满足封闭性(任两个元素能推到另一个元素)，结合律，消去律。存在单位元$e$，并且每个元素都有逆元。 置换。$(a_1,a_2,a_3,…,a_n)$即$(1,2,3,4,…,n)$的一一映射（全排列），把$i$映射到$a_i$。任意一个置换都可以写成循环的形式：$(3,5,1,4,2)=(1\\ 3)(2\\ 5)(4)$。 置换群，即由置换组成的群，运算是置换的连接。 Burnside引理。用于求置换下的等价类个数。设$G={f_1,f2,…f{|G|}}$是$[1,n]$的置换群。一个方案$S$在置换$f$的作用下不变，称$S$为$f$的不动点，$fi$的不动点个数记为$c(i)$。于是，$$\\Large ans=\\frac{\\sum {i=1}^{|G|} c(i)}{|G|}$$。 Polya定理。 如果置换$f$分解为$m(f)$个循环，每个循环的颜色都相同，若存在$k$种颜色，即有$c(i)=k^{m(f)}$。带入Burnside引理即得。 一些推论及技巧$c(i)$可以通过组合计数，DP或数论的方式求出。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"图论-prufer序列与矩阵树定理","date":"2017-08-04T10:00:00.000Z","path":"2017/08/04/Algorithms-Tree-count/","text":"更多的坑待填… prufer序列参考资料 prufer序是无根树的编码表示，对于一棵$n$个节点带编号的无根树，对应唯一一串长度为$n-2$的prufer编码。 无根树转化为prufer序列找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下$2$个节点。 根据以上过程，显然有推论 一个节点的度数=其在prefer序列出现的次数+1。 prufer序列转化为无根树首先prufer序列中的出现次数+1可以得到每个节点的度。 先执行$n-2​$步，选取最小标号度为1的点$u​$与Purfer序列的第$i​$个数$v​$表示的顶点相连，并将$u​$和$v​$的度减$1​$。最后再把剩下的两个度为$1​$的点连边。 由此发现，一棵无根树和与一个prufer序列一一对应。 一些推论 一个无向完全图的生成树个数为$n^{n-2}$。 设节点$i$的度数限制为$di$，求满足条件树的个数。对应到prufer序列，相当于$i$在序列中出现了$di-1$次，不同的排列数。即为$n!$除以每个$(di-1)!$。 对于一些没有限制度数，稍微修改一下即可。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"FWT(快速沃尔什变换)学习笔记","date":"2017-08-04T10:00:00.000Z","path":"2017/08/04/Algorithms-FWT/","text":"更多的坑待填… 前置技能对于一个长度$n=2^k$的向量$A$，定义$A0$为这个数组的前$2^{k−1}$项，$A1$为这个数组的后$2^{k−1}$项，$A=(A0,A1)$。 $$A \\pm B = {A[0] \\pm B[0], A[1] \\pm B[1], A[2] \\pm B[2],…, A[n-1] \\pm B[n-1] }$$ $$A \\times B = {A[0] \\times B[0], A[1] \\times B[1], A[2] \\times B[2], …, A[n-1] \\times B[n-1] }$$ $$A \\oplus B = { \\sum {i \\oplus j = 0} A[i] \\times B[j], \\sum {i \\oplus j = 1} A[i] \\times B[j]…, \\sum _{i \\oplus j = n-1} A[i] \\times B[j]}$$ 简述快速沃尔什变换(Fast Walsh-Hadamard Transform)，用于解决一类特殊的卷积。 $$\\large C[i] = \\sum _{j \\oplus k = i} A[j] \\times B[k]$$ 其中$\\oplus$可以是任意位运算，$xor, ans, or$。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"AtCoder泛做-ARC#068~076","date":"2017-07-14T16:00:00.000Z","path":"2017/07/15/Training-ARC-068-076/","text":"完结，撒花~ 时间：2017.7.15~2017.8.24 未完成: ARC#069F, ARC#070E/F, ARC#074F ARC#076F(霍尔定理) AtCoder Regular Contest 068 E - Snuke Line 给定$n$个区间$[l,r]$和一个数$m$。对于$d=1,2,3…,m$，求$kd(1 \\leq kd \\leq m,k\\in Z)$被多少个不同区间覆盖（对于不同的$k$，只算一次）。$1 \\leq n,m \\leq 3\\times 10^5,1 \\leq l \\leq r \\leq m$ 记区间的长度为$len=r-l+1$。想到可以$O(mlogm)$暴力枚举所有的$kd$，用线段树算出它被几个区间包含。容易发现当$d&lt;len$时，有可能被多次计算。 考虑当$d \\leq len$时，则一定存在$k$使得$kd$被这个区间覆盖。于是我们记录满足$d \\leq len$的区间个数即可。而对于$d&gt;len$的情况，至多有一个$kd$被区间覆盖，于是就可以用线段树维护。即当$d&gt;len$时加入这个区间，同时单点询问$kd$被多少个区间覆盖。复杂度$O((mlogm+n)logm)$。 Code F - Solitaire 有一个双端队列，依次往首或尾插入数1到n。然后你可以从队列的首或位取出一个数，顺次相接组成一个序列。求有多少个序列的第$K$位为$1$？$1 \\leq k \\leq n \\leq 2\\times 10^3$ 显然，当$n$个数全部插入后，队列一定是递减到1再递增的。不难发现，得到的序列的前$K$位，一定是由两个递减序列交错得到的，且第$K$位为1。 从$n$到$1$逐个考虑每一个数是否选择，且属于哪一个序列。定义$f(i,j)$ 已经得到了序列的前$i$位，其中第$i$位为$j$的方案数。将$j$加入序列1，则$f(i,j)$可由$f(i-1,k), k&gt;j$转移过来。 如果将新的数加入序列2，该如何转移？可以发现，这个数一定是没选择的数中最大的数（序列2也是递减的）。则$f(i,j)$可由$f(i-1,j)$转移过来。 事实上，DP的过程还有一个非法的转移。$f(K-1,1)$会转移到$f(K,1)$，不是以1作为第$K$个数。 对于剩下的$n-K$个数，每次可以取头或尾。于是答案$ans=(f(K-1,1)-f(K-1,1))\\times 2^{n-K-1}$。 时间复杂度$O(nK)$。 Code AtCoder Regular Contest 069 E - Frequency 有$n$堆石头，第$i$堆有$ai$个石头。每一次，你需要记录下石头最多的堆的序号（当石头数相同时，取最左端的），然后你可以从某堆中拿走一块石头。直到石头被全部拿走。需要使得序号组成的序列字典序最小，问1到n在序列中出现的次数。 可以发现，这个序列一定是非递增的。假设现在最多的石头堆为$x$，在1到x-1中石头最多的堆为$y$。考虑贪心的过程，我们需要把x到n中，石头数大于$ay$都取到$ay$，因为这样能使得序号尽可能快地减小。离散化石头数，再从小到大考虑，用树状数组维护小于某个值的石头堆数量，以及石头数总和即可。 事实上，存在排序后$O(n)$的做法。 Code F - Flags 你在一条线上插$n$个$flag$，其中第$i$个$flag$可以插在$xi$或$yi$。记所有$flag$两两间的距离最小值为$d$，求$d$的最大值。 暂未编写。 考虑二分答案$d$。于是是否放在$xi,yi$变成了$2-SAT$判定性问题，对于$xi$和$yi$恰好放一个，距离小于$d$的位置不能同时放，构成了一些约束条件。暴力枚举所有点对，可以在$O(n^2logMAX_{x})$的时间内解决。 发现许多约束条件是无用的。考虑类似线段树的分治结构来建图，对于每个点，至多与$O(logn)$个区间相连；令一方面，线段树中父子相连的边也只有$O(n)$条。单次判定的复杂度可以做到$O(nlogn)$。总的时间复杂度$O(nlognlogMAX_{x})$，可以通过此题。 存在$O(n(logn+logMAX_x))$的算法，暂未理解。 AtCoder Regular Contest 070 D - Need 给定$n$个数$ai$。如果存在子集满足其和大于等于$K$，则称为是好的子集。如果一个数$ai$所在的所有好集中，去除$ai$后仍是好集，则$ai$是无用的。求无用的数的个数。 对于$x&lt;y$，若$y$是无用的，则$x$一定无用的，所以答案满足单调性。考虑判断$x$是否是无用的，用$bitset$维护$n-1$个数相加能组成的集合（$x$除外，可以用类似$DP$的方式求出）。 显然，如果其他的数能组成$K-x$到$K-1$中的任意一个数，则$x$是有用的。时间复杂度$O(\\frac {n^2logn} w)$ ，此处$w$一般为$32$或$64$。 Code AtCoder Regular Contest 071 E - TrBBnsformBBtion 有字符串$S,T$，仅由$A$或$B$构成。有如下操作：①选择一个字符:$A\\rightarrow BB$ 或 $B\\rightarrow AA$。②删除连续3个相同的字符:$AAA$或$BBB$。给定$Q$个询问，对于每个询问，回答$S[a,b]$能否变换为$T[c,d]$。$|S|,|T|,Q \\leq 10^5$ 想了几分钟就YY了一个结论：把A看作1，把B看作2，两个串能变换当且仅当两个区间和模3同余。然后就A掉了。首先，必要性显然，因为对于区间和模3，不论如何操作都不会改变。 看了官方题解才知道如何证明充分性。首先主要到所有的操作都是可逆的：$A\\rightarrow BB\\rightarrow AAAA\\rightarrow A$。且$A,B$可以任意地加3个或减3个。考虑将$S$和$T$中的$B$全变为$A$。如果$S,T$的$A$个个数关于3同余，则一定能变换。就证明了结论。 Code F - Infinite Sequence 给定$n\\ (n \\leq 10^6)$，问存在多少个无穷序列满足：1.每个数都在1到$n$之间。2.对于任意$n \\leq i,j$，都有$a_i=a_j$。3.对于任意的$i$，若存在$i+1 \\leq j&lt;k \\leq i+a_i$，都有$a_j=a_k$。 发现只有前$n$位是有用的，考虑到动态规划更容易向前转移，定义$f(i)$为子序列$[i,n]$满足条件的个数，于是我们考虑$a_i$的值即可转移。 发现1是一个比较特殊的数，当$a_i=1$时，$f(i)=f(i-1)$。 当$a[i]\\not=1,a[i+1]\\not=1$时，序列为$ABBBBBB…$的形式，$f(i)=(n-1)\\times (n-1)$。 当$a[i]\\not=1,a[i+1]=1$时，序列为$A,1,1,,..,1,B…$的形式，$f(i)=f(i-3)+f(i-4)+…+f(1)+n-i+2$。 Code AtCoder Regular Contest 072 D - Alice&amp;Brown A和B在玩一个游戏。一开始，有两堆石子分别有$X$和$Y$个。你可以从一堆中取$2i$个，然后放$i$个到另一堆。无法操作的玩家输。问先手是否存在必胜策略?$0 \\leq X,Y \\leq 10^{18}$。 通过打表发现，当$|X-Y|&gt;=2$先手必胜，否则后手必胜。考虑如何证明。 对于$(X,Y)=(0,0),(0,1),(1,0),(1,1)$，满足$|X-Y|&lt;=1$，是必败态。 对于必胜态，设$|X-Y|=3k+r&gt;=2\\ (r=0,1,-1,\\ k&gt;=1)$ ，取$i=k$，即可转移到必败态。 对于必败态，操作后$X-Y$至少改变3，一定会转移到必胜态。 Code E - Alice in linear land 给定长度为$n$的操作序列$ai$和距离$di$。对于每个$ai$，当$|d-ai|&lt;d$时$|d-ai|$会成为新的$d$，若最终$d=0$，则称是可达的。给定$Q$个询问$qi$，问能否改变$a[qi]$，使得操作序列是不可达的？$n,Q \\leq 5\\times 10^5$ 首先可以预处理前缀$a[1,qi-1]$操作后的$d$，记为$pre[qi-1]$。发现对于询问$qi$，只需要知道后缀$a[qi+1,n]$使得序列不可达的最小的$d=suf[qi+1]$，只要$pre[qi-1]&gt;=suf[qi+1]$就一定能做到。 于是问题转化为如何就$suf[i]$。显然，$suf[n+1]=1$，而且随着$i$的减小，$suf[i]$一定是非递减的。当$ai&gt;=2\\times suf[i+1]$，可以取到$suf[i]=suf[i+1]$（此时无法执行操作）；否则$suf[i]=suf[i+1]+ai$。 Code F - Dam 有一个水坝容积为$L$，一开始没有水。此后$n$天，在第$i$天早晨，会进来体积为$Vi$，温度为$Ti$的水；为了下一天水不会溢出，第$i$天傍晚需要排出一些水。对于体积$V1$，温度$T1$和体积$V2$，温度$T2$的水混合，体积为$V1+V2$，水温为$\\large \\frac {T1\\times V1+T2\\times V2}{V1+V2}$。回答$n$个询问，对于第$i$个询问，输出在第$i$天能够达到的最大水温。$n \\leq 5\\times 10^5$ 假设混合得到的水体积为$V2$，温度为$T3$。由题目可知$T1\\times V1+T2\\times V2 = T3\\times V3$。考虑将$(x,y)=(V,TV)$抽象为一个向量，那么，水的混合就变成了向量之和！ 观察这个向量，发现$T$对应的就是它的斜率！将水排出，相当于是原向量乘上&lt;1的实数！将可能的状态画在坐标系上，可以发现这一定是一个上凸包。如图。 而新加入一个向量后，最右端的会被删除。此时不一定还是凸包，在左端比较相邻的斜率，合并即可。 整个过程用双端队列维护，复杂度$O(n)$。 AtCoder Regular Contest 073Code E - Ball Coloring 有$n$个包，每个包里各有两个球，权值为$xi$和$yi$。你需要将一个球涂为红色，另一个球涂为蓝色。令$Rmin$为红球中的最小权值，$Rmax,Bmin,Bmax$同样定义。求出$(Rmax-Rmin)\\times (Bmax-Bmin)$的最小值。$n \\leq 2\\times 10^5$ 假设所有权值中的最大值为$Max$，最小值$Min$。不失一般性地，有两种情况： $Rmax=Max,Bmin=Min$，此时需要最大化$Rmin$，最小化$Bmax$，于是将两个球中较大的涂为红色，较小的涂为蓝色。 $Rmax=Max,Rmin=Min$（Min和Max不在同一包里），此时需要最小化$Bmax$，最大化$Bmin$，令$xi \\leq yi$，之后按照$x$升序排序。我们说，最优方案一定是，排序后，前$k\\ (1 \\leq k \\leq n)$个的$xi$涂为红色，后$n-k$个涂为蓝色。如何证明，考虑反证法。 假设第$p(p&gt;=k+2)$涂为了红色，那么$Bmin$并不会增大，而$Bmax$并不会减小，所以一定不会是更优解。于是简单证明了结论。 Code F - Many Moves 在一根长度为$n$的数轴上，有两个方块，位置为$A,B$。并且在同一时刻，你能移动一块方块一个单位距离。你需要依次到达位置$xi$，求最少所需时间。$n,Q \\leq 2\\times 10^5$ 以$xi$作为阶段，注意到上次的一个方块位置一定是在$x[i-1]$，于是不难想到$O(n^2)$的DP。$f[i,j]$表示到位置$xi$，另一个位置为$j$的最小时间。若原来位置为$x[i-1]$的到位置$xi$，即有$f[i,j]=f[i-1,j]+|x[i]-x[i-1]|$。否则即有$f[i,x[i-1]]=f[i,j]+|j-x[i-1]|$。 考虑如何从优化转移的时间。对于前面的状态转移方程，事实上就是线段树的区间加。对于后面的状态转移方程，考虑维护$f[i,j]-j$和$f[i,j]+j$的值，在$[1,x[i-1]]$取$f[i,j]-j$的最值；在$[x[i-1],n]$取$f[i,j]+j$的最值即可。阶段间的转移优化到了$O(logn)$。 Code AtCoder Regular Contest 074 D - 3N Numbers 给定$3n$个数$A$，你需要删除其中的$n$个数，使得剩下$2n$个数$A’$中前$n$个数之和-后n个数之和之差最大。求最大值。$n \\leq 10^5$ 发现对于删除后$A’$的第$n$个数一定是在原来$A$的$[n,2n]$，考虑暴力枚举$A’[n]$的取值，剩下的贪心地选取。整个过程用堆维护。 Code E - RGB Sequence 您需要构造一个长度为$n$， 由R,G,B构成的序列，满足以下$m$个限制。对于限制$i$，满足$[li,ri]$间不同的颜色种数恰好为$xi$。求满足条件的序列数。$n,m \\leq 300$ 考虑到如果存在不满足的情况，一定是DP过程中最后的R,G,B发生冲突。于是考虑状态$f[R][G][B]$表示$R,G,B$最后的位置，发现当前位置$p=max{R,G,B}$。考虑暴力转移，转以后判断是否冲突即可。 Code AtCoder Regular Contest 075 D - Widespread 有$n$只怪兽，第$i$只怪兽初始血量$hi$。每次可以选定一只怪兽攻击，造成$A$点血量的伤害。同时其他怪兽受到$B$点血量的伤害。求最少的攻击次数。$n \\leq 100000$ 考虑二分答案次数$T$。当某只怪物的血量$hi \\leq BT$时，不需要主动攻击。否则需要$\\large \\lceil \\frac {hi-BT} {A-B}\\rceil$次主动攻击，判断主动攻击次数之和是否不超过$T$次即可。 Code F - Mirrored 对于一个正整数$n$，记$rev(n)$为$n$的倒置，例如$rev(123)=321,rev(4000)=4$。给定$D$，求存在多少$n$满足$rev(n)=n+D$。$D \\leq 10^9$ 以5位数为例，$\\overline{edcba}-\\overline{abcde}=9999(e-a)+990(d-b)$ 考虑到如果$D$不是9的倍数，一定无解，否则我们考虑现将$D$除以9。然后DFS，发现$(e-a)\\ mod\\ 10$可以确定，同样可以逐位确定剩余的位，最后乘法原理确定总方案数即可。注意奇偶分类。 Code AtCoder Regular Contest 075 E - Connected? 给定$R \\times C$棋盘上的$n$对点，要求这$n$对点彼此连线，保证这些线不相交。求是否存在方案满足。 考虑到，如果不是两个点都在边界上，一定存在方案。所以我们只要考虑边界点即可。考虑使用一个栈，顺时针处理所有的点$x$，如果栈顶的点是$x$，则出栈，否则令$x$入栈。最后只要检查栈是否为空即可。 Code","tags":[{"name":"泛做","slug":"泛做","permalink":"https://xuzhean.github.io/tags/泛做/"}]},{"title":"2017年7月NOIP集训总结","date":"2017-07-02T12:00:00.000Z","path":"2017/07/02/Training-2017.7/","text":"完结，撒花~ 暑假终于到了，蒟蒻$Cyani$也要开始刷题啦~ 暑假的训练时光是宝贵的，是算法和思维快速提高的时期，在这里总结下收获。 7.2-基础数据结构单调栈&amp;单调队列单调栈应用： 求出一个数左/右第一个比这个数大/小的数。 BZOJ1136：[POI2009]求序列中的最长连续子序列，其平均数大于$k$。 考虑每个数都减去$k$，转化为区间和&gt;=0的最长区间。求前缀和后，若$i &gt; j$且$sum_i&gt;=sum_j$，则$j$作为左端点比$i$更优。 维护一个$i$递增$sum_i$递减的栈。枚举右端点，利用单调性二分找到小于它的节点。 事实上，右端点从$n$向左枚举，小于等于它的节点都可以弹出（右端点左移后，长度只会更劣）。 HDU5726：[多校2016]对于给定序列$A$，和$Q$组询问$(l,r)$。输出$gcd(al,al+1,…,ar)$ 和所有满足$gcd(al,al+1,…,ar)=gcd(al0,al0+1,…,ar0)$ 的$(l0,r0)$的个数。 $gcd$有一个很神奇的性质，不断对某个数取$gcd$，得到不同的值最多有$log$个。考虑右端点不断向右移，维护$gcd$区间的单调栈，加入新的数后不断合并相同的数。 考虑第一个问题，将所有询问挂在右端点，对于左端点排序，之后在单调栈里扫一遍就好了。 考虑第二个问题，用一个$map$存所有出现的$gcd$个数。单调栈同时保存所在下标，单调栈扫一遍，下标作差就是贡献。 51Nod1962：给出两个数组A，B，求$Σ︀max(Ai,Ai+1, …,Aj)==max(Bi , Bi+1, …,Bj)(1 \\leq i \\leq j \\leq n)$的值。 暂未AC。向右移动一个端点时，前一次的答案可以利用。维护单调栈时，也维护区间即可。 单调队列应用: 维护DP决策点，删除不可能的决策。 CF524F：给出一个仅由’(‘和‘)’构成的字符串，现在可以加入一个字符，或者将末尾的字符移到最前面。求一个长度最短的合法括号序列，如果有多个输出长度最短的且字典序最小。 暂未完全理解。这题的正解是后缀数组或者HASH+二分，复杂度$O(nlogn)$，然而我并不会。然后zyy大神犇用单调队列，(si hu)复杂度$O(n)$就过去了，做法还是很神的。首先答案一定是原长加上两种括号的差值，（这个是一定能完成的，并且’(‘加在最前面，’)’加在最后面）。那么我们可以将串倍长，计算每个长度为n的区间是否将会缩成一种括号。 考虑计算那些为位置可以作为左端点，如果说一个括号序列是可以匹配的，当且仅当“所有位置的前缀’(‘数量大于’)’的数量“。维护’)’与’(‘差值的前缀和单调递减，每次可以找到’)’减去’(‘最大的右端点，若这个值大于要加上的左括号的数量，则这个位置开始是不符的。$O(n)$内就能算出每个位置是否能作为左端点。 接下来就是些很神奇(sang xing bing kuang)的操作，比较以这些左端点所在的区间的字典序，乱搞一下就行了？复杂度又似乎$O(n^2)$？反正没搞懂。。 字符串这一部分考的主要是KMP的灵活应用和对$Nex$t数组的理解（如经典的把匹配位置作为状态的DP）。 CF631D：给出两个串$A$,$B$，问$B$在$A$中出现了多少次。字符串由$n$个二元组$(li,ci)$拼接而成，每个二元组代表$li$个字符$ci$。 考虑去除$B$前后的二元组，中间的用KMP匹配，两边的再特殊判断。特判只有一个或两个二元组的的情况。 Hash原来我对哈希的理解仅在”一堆数加起来模个质数”的层面。。 把所有数据都$xor$起来，这种方法适用于数据不需要维持相对顺序的时候。 转化成一个$seed$进制下的数模一个质数的值，是可以支持询问一个区间的值，拼接若干区间，以及插入，删除，修改之后的全局询问。 CF7D：定义一个串是$k$回文的，当且仅当这个串是回文的，且其长为$⌊n/2⌋$的前后缀都是$k − 1$回文的，任意串都是$0$回文的。判断这个串的每个前缀的最大回文数. 考虑直接DP。如果$[1,i]$是回文的就有$fi=f{i/2}$，否则为0。考虑维护左端和右端的HASH值，用第二种方式可在两端插入和删除，判断是否相等即可。 CF452F：给定一个$n$的置换$A$，问是否存在一个三元等差子序列。 哈希+线段树。对于中间的数$x$，若不存在$x-k$和$x+k$构成了等差数列，则$x-k$和$x+k$一定在都在$x$之前或之后。于是维护以出现的数，若出现的数关于$x$不对称，一定存在一个等差数列。用线段树正反各维护HASH的值，判断是否相等即可。用第二种HASH方式。 差分这是NOIP喜欢考的小技巧。 序列差分，将区间加变成单点加减，只能做到离线。 树上差分，一般和LCA结合。在u,v处打标记，在LCA处消除标记，求其子树的标记和即可。对于一些树上路径问题，可以用差分代替树链剖分。 BZOJ3043：给定数列A，每次可将区间+1或-1。至少多少次使得所有数相同，在此条件下最终的数列有多少种。 将所有数差分，可将题目中的区间加减变为单点加减。考虑差分的性质：若要操作$[l,r]$，当$r$不为$n$时，在$l$处打$+1/-1$标记，在$r+1$处打$-1/+1$；仅当$r=n$时，在$l$处打$+1/-1$。于是求出差分数组正数的和$x$，负数的和的绝对值$y$。然后$x,y$互相抵消，多余的自己抵消或和第一个抵消。操作次数为$max(x,y)$，结果数为$abs(x-y)+1$。 树上差分的经典题：[NOIP2015]D1T3运输计划，[JLOI2014]松鼠的新家 7.3-树相关1倍增倍增也是noip的常考点，往往可以优化为$log$或去掉一个$log$。 假设现在有问题$f(N)$，如果我们可以通过$f(A)$和$f(B)$快速求出$f(A+B)$，则我们就可以倍增。二进制拆分为$log$个答案，再合并就是最终答案。e.g.快速幂，多项式乘法(FFT?)，RMQ求区间最值，树上节点的祖先。 优化二分。对于一些具有单调性的问题，我们可以二分答案，再用倍增求，复杂度$O(lognlogn)$ 。事实上可以用倍增优化二分，复杂度降到$O(logn)$ 。 假设二分的区间是$[0,n]$，设$m=log(n)$。 设答案$ans$一开始为0，先检验$ans+2^m$是否满足条件，如果满足则让$ans+=2^m$。 之后让$m–$，一直做到$m=0$为止。 正确性显然，相当于二进制逐位确定最终的$ans$。 利用倍增估计二分的界限，来优化一些奇怪的二分？ HDU4343：给定$n$个区间，有$m$次询问，每次问最多可以从n个区间中选出多少$[L,R]$的子区间，使得他们互不相交。 首先去除包含其它区间的区间（显然选择更小的区间更优），所以左端点和右端点都是递增。考虑贪心的过程，每次要选择左端点&gt;=当前右端点，且最靠左的区间。预处理所有区间的后继，然后算出倍增数组。对于每个询问，找到区间内最靠左的区间，倍增找到最靠右的区间，每次询问复杂度$O(logn)%$。 HDU6031：给定一棵$n$个点的有根树，有$Q$次询问，每次询问给出一个集合$A$和集合$B$，你需要从$A$中选出一个数$x$，从$B$中选出一个数$y$，使得$lca(x,y)$的深度最大。 二分答案的深度$s$，求出$A$中点的深度为$s$的祖先和$B$中点的深度为$s$的祖先。用$map$判断两个集合是否有交即可。 DFS序把对子树维护的问题转成对区间维护的问题，记录DFS进入和出去的时间。$y$在$x$的子树中的充要条件是：$in[x]&lt;=in[y]&lt;=out[y]&lt;=out[x]$。 转化为区间维护问题后，用树状数组或线段树维护即可。一般难度不大。 树的路径相关 将路径拆分为x到$LCA$，和$LCA$到y的两条链。 定义一个点的重量是去掉它之后树的最大的联通块的大小。我们将一棵树中重量最小的点称为重心。一棵树最多只有两个重心。 判断无根树同构：取重心作为根，从而变成有根树，然后就可以用树hash来判断是否同构了。 点分治：重心的重量一定小于等于$n/2$，所以可以用来分治。 定义一棵树中最长的路径为树的直径。树的直径并不唯一，但是直径的中点都是一样的。 任选一个点$S$，找到离他最远的点$X$。找到离$X$最远的点$Y$。那么$(X,Y)$就是一条直径。 直径合并：对于两棵树$T,S$，任取他们的直径$(Ta,Tb)$，$(Sa,Sb)$。假设现在有一条边连接了$T$和$S$，构成了新的树$M$，那么$(Ta,Tb,Sa,Sb)$这四个点中一定能选出两个点$u,v$，使得$(u,v)$是$M$的一条直径。 对于一些要你在树上选两个点的题，可以先打表看看，很大概率是选在直径上最优。 并查集 路径压缩：与树的形态无关，尽量将儿子节点挂到根节点上，均摊复杂度$O(α(n))$，单次可能被卡到$O(n)$！ 按秩合并：与树的形态有关，记一下每棵有根树的子树大小，每次合并时让小的成为大的的儿子。树高一定是$O(logn)$。复杂度证明：从一个点x出发，每次往上爬，子树大小至少翻一倍。所以最多爬$O(logn)$次。 CF468B：给定$a,b$和$n$个整数。每个整数属于集合$A$或$B$。如果$x$属于集合$A$，那么$a-x$也属于集合$A$；如果$x$属于集合$B$，那么$b-x$也属于集合$B$。判断是否冲突 考虑其逆否命题，$a-x\\notin A\\Rightarrow x\\notin A$ ，可以确定某些整数能否属于集合$A$，集合$B$同样处理。同时将$x$与$a-x$合并，或上1表示能在集合$A$，或上2表示能在集合$B$。最后判断同一个并查集里的是否有冲突即可。 7.5-膜你赛1题目很赞，数据略水，还是很滋瓷的。T1暴力A掉，T2写出正解，T3正解写挂。。全场Rank5？？ A:分块 给定序列$a1,a2,…,an$和$Q$个询问。对于询问$(q,p)$求出所有满足$i=p(mod\\ q)$的$ai$之和。$n,Q \\leq 100000$ 暴力对于数据随机，均摊复杂度可以达到$O(nlogn)$（调和级数）。 发现暴力速度的瓶颈在于$q$较小的情况。考虑设置一个阀值$k$。 对于$q&gt;=k$的情况，直接$O(n/k)$就可以暴力算出答案。 对于$q&lt;k$的情况，$O(kn)$就可以预处理答案。 复杂度$O(kn+n^2/k)$，显然取$k=\\sqrt n$最优。 B:函数相关？脑洞题 给定一个$n$行$m$列的矩阵（所有的元素都在模$K$意义下操作），可以有以下操作：修改某一行，使得这行所有的数累加1；列也是类似操作。求出最少要操作几次，使得矩阵全为0（保证存在解）。$n,m \\leq 1000$ 假设第$i$行的操作次数为$xi$，第$j$列的操作次数为$yj$。显然$0 \\leq xi,yj&lt;K$。 不难发现当第一行的操作次数（记为$x$）确定后，所有行和列的操作次数都能确定，且都是关于$x$的线性函数。 所以操作次数$ans=f(x)$是关于$x$的分段函数，每一段都是一次函数。 发现一次函数的最值一定是在端点处取到，而端点取到的情况是某个$xi$或$yj$等于$K-1$或$0$。 带入$x$，直接$O(n)$就能算出$f(x)$，于是复杂度为$O(n^2)$。 C:数据结构 有$𝑛$个墙，第$𝑖$个墙的高度为$𝑎𝑖$，给你$𝑄$个操作。$𝑃$，询问当前墙的状态下最多能存储多少水。$𝑈(𝑥,𝑣)$，令第$x$个墙的高度增加$v$。$n,Q \\leq 100000$ 考虑暴力的做法。为了方便计算，我们需要把砖块当作“水”，同时维护砖块的个数。显然我们一定可以找到最高且最靠右的墙（记为$P$），而左边水的高度是单调不减的，右边水的高度是单调不增的。 直接$O(1)$维护墙的高度。对于每一个询问，从$1$扫描到$P$，维护前缀最大值，每个位置水的高度都是前缀最大值；同理从$n$扫描到$P+1$即可。需要减去砖块的个数。 标程的做法：以$P$左侧为例。用$set$维护高度递增的墙。当$x$高度增加需要更新后，弹出在$x$右侧且比它低的墙，在此同时，维护水的个数即可。注意到$P$位置是可以改变的，需要特殊处理。由于进入$set$的元素个数为$O(n)$，并且$set$单次操作时间为$O(logn)$。复杂度$O(nlogn)$。 我的做法：用线段树维护。当$x$的高度增加需要更新后，区间更新$[x,P]$的最大值。即仅当$ax&gt;ai(x \\leq i \\leq P)$后，才会更新$ai$的值。似乎需要$O(n)$？ 事实上，由于单调性的存在，对于每个线段树区间$[l,r]$，维护左端高度$lh$，右端高度$rh$。当更新的高度$h \\leq min(lh,rh)$时，显然不用更新；当$h&gt;=max(lh,rh)$时，直接更新整段区间；否则继续划分区间。于是最后更新的区间只有$O(logn)$段，单次询问复杂度也为$O(logn)$。 与标算一样，也需要考虑$P​$改变后对答案的影响（要修改到新的$[P,P’]​$或$[P’,P]​$），我就是因为没有判断$P​$与$P’​$的位置关系，导致爆0…QAQ… 相比标算，虽然更为麻烦，但是却能够支持区间查询。 7.6-动态规划及贪心作为NOIP必考的DP，难度普遍偏高，需要我们多多总结模型和一些优化的方法。 动态规划的要素，优化方法阶段 可划分，无后效性 ，背包、区间、树形，倍增，正序 - 逆序。 状态 状态数少，状态的“线性相关”，二进制压缩，舍弃无用状态。 权值 能比较，字典序，前缀和（最大值），可行性-&gt;判定性。 转移 效率要有保证 ，决策单调，斜率优化，数据结构 7.7-树状数据结构二叉堆 UOJ130：求$K$叉哈夫曼树的最小权，和权值最小时树的最小高度。 直接用堆维护哈夫曼树的叶子节点和，每次取出最小的$K$个子树，合并即可。由于要求高度最小，每次挑高度最小的合并。 51Nod1380：有$n$个排成环的数，每次可以选择一个数，同时删除这个数两边的数，直到所有数全部取完。问取出的数的和最大为多少。$n \\leq 100000$ 很赞的题目。用堆维护最大值，选取最大值后删除两边的值。发现这样不一定是最优的，需要能够“撤销”操作。考虑将最大值位置的值修改为左右两边的和减去中间的数重新入堆。当再次选到这个位置上时，就会撤销原来的操作，加上了新的值。当多次选到这个位置上时，会撤销之前的撤销操作，不难发现，每次选择的个数刚好加一。于是入$n/3$次堆就可以直接跳出了。 注意到需要标记每个元素是否被删除。直接用一个$bool$数组维护的话，需要每次找左端和右端的数，复杂度可能退化到$O(n^2)$。于是用双向链表维护一下就行了。 有一长为$N$的序列$A$， 给出$L,R$，计算所有长度在$[L, R]$的区间的和中，最小的$m$个数之和。 显然先计算出前缀和。考虑在堆加入三元组$(l,r,i)$，表示右端点为$i$，左端点为$[l,r]$的某个数，时区间的最大和。每次挑出$[l,r]$中$s[j-1]$最小的$j$，之后再在堆中加入$(l,j-1,i)$以及$(j+1,r,i)$。需要求出区间最值，用ST表实现即可。 树状数组 常数较小，支持单点修改，维护前缀信息。 对于$C[i]$，维护的是$[i-lowbit(i)+1,i]$的信息。 容易扩展到高维的情形。 通过差分处理，可以进行区间修改。 因为$lowbit(x)=lowbit(-x)$，把数组投影到$[-n,-1]$，所以加减的顺序改变后，事实上求的是树状数组后缀和。 51Nod1461：给定$n$个数$li$，删除$li$需要$di$的能量。假设剩下$k$个数，如果最大$li$的数量超过$⌊n/2⌋$，那么这$k$个数是稳定的。求使得剩下的数稳定所需要的最小能量。$n \\leq 100000$ 考虑按照$li$递增排序，每次处理一段相同的$li$（假设有$m$个）。于是我们就要从比$li$小的$lj$中挑选$m-1$个$di$最大的数。离散化$di$，就可以用树状数组维护最大的前缀和。可是如何找到第$m-1$大的数。考虑另外开一个树状数组，保存前缀$di$的个数。二分答案能在$O(logn \\times logn)$找出第$m-1$大值。 事实上，由于树状数组优美的结构，能够很好地支持倍增。假设目前已经到了第$p$位，前缀个数为$s$个，对于逐个减小的$k$，若$s+sum[p+1,p+2^k]&lt;=m-1$，则$p$就能增加到$p+2^k$。发现$sum[p+1,p+2^k]=sum[p+2^k-lowbit(p+2^k)+1,p+2^k]=c[p+2^k]$。 线段树区间修改的要求： 节点的信息是可以合并的。 并且信息可以和标记合并。 标记可以和标记合并。 线段树分治结构利用。基于均摊的线段树操作实现。 UOJ228：维护一个序列。支持：区间累加，区间开根，区间求和。$n,m \\leq 100000$ 当区间内开根后，减小的数都相同，就变成区间减操作。通过一些均摊复杂度分析，复杂度为$O(nlognloglogn)$？ CF438D：维护一个序列，支持：区间取模，单点修改，区间求和。$n,m \\leq 100000$ 考虑到如果区间的最大值小于模数，直接可以返回。复杂度分析：每次取模后，每个数至多变为原来的一半，单点加法每次也只恢复了一个点的势能，而势能是最多减少$log$次。 Trie Cow Xor：有一长为N的序列挑一段$[l, r]$使得$a[l]\\ xor\\ a[l+1]\\ xor … xor\\ a[r]$最大。 求出其前缀异或，插入$Trie$，贪心地询问$s[i]$异或最大值。 7.9-膜你赛2题目很赞，很滋瓷。T1可以无视，T2写出正解，T3是50分暴力。。全场Rank2？？ B:数据结构 给你一个长度为$𝑛$且下标从$1$开始的数列$a$。并给$𝑚$个操作。操作有两种：$1\\ 𝑝\\ 𝑥$，$𝑎𝑝=𝑥$。$2\\ 𝑎\\ 𝑏$，求$Σ︀𝐹(𝑖, 𝑗)(a \\leq i \\leq j \\leq b)。$其中$F(i,j)=ai\\ xor\\ ai+1\\ xor … xor\\ aj$。 $n,m \\leq 10^5,0 \\leq ai,x \\leq 1000$ 考虑到对于每一位二进制位都是异或独立的，所以对于十个二进制位用十个线段树维护。发现区间对于答案有贡献，当且仅当区间内恰好有奇数个一。 考虑维护四个值：$cnt$:区间内点的个数；$sum$:区间内恰有奇数个点的子区间个数；$L$:有奇数个1的前缀个数；$R$:有奇数个1的后缀个数。 首先$cnt​$很容易维护。对于$L​$，只需要把左端的$L​$与右端的合并，如果左端$cnt​$为偶数，那么就要加上右端的$L​$否则加上区间长度减$L​$（即有偶数个1的前缀个数）。$R​$也是同样。于是我们很容易用$L​$和$R​$维护$sum​$。首先要加上左端和右端的$sum​$，再考虑跨过中心的情况，分为左奇右偶和左偶右奇相乘即可。 C:组合数学 $A$、$B$、$C$有一叠卡，$A$有$𝑁$张，$B$有$𝑀$张，$C$有$𝐾$张。卡片上写着字母$A$，$B$或$C$，游戏从$A$开始。每个人把牌打出来，下个出牌的人的是打出的卡上的字母。如果当前玩家没有牌，那么那个玩家就赢了。求$A$能获胜的种类。 事实上，我们可以把出牌的次序看作一个序列（一个持牌情况肯定对应唯一一个序列）。发现当$A$出现第$N$次后，$A$就赢了。并且此前，$B$最多出现$M$次，$C$最多出现$K$次。我们考虑枚举第$N$个$A$出现的位置，假设是$x$。首先确定前$N-1$个$A$出现的位置，为$C_{x-1}^{N-1}$。考虑到剩下的位置可一随机排放$A$,$B$或$C$，还要乘上$3^{N+M+K-x}$。于是枚举$B$的个数，可以的到算得$C$的个数。复杂度$O(N^2)$就能得到50分。 考虑满分的做法。画出杨辉三角，可以发现由于$M$和$K$的个数限制，得到的是一块平行四边形区域。考虑如何维护每一行的值，如果没有限制，前一行乘2就可以得到下一行的和。发现有可能会超过平行四边形的边界，暴力减除即可。于是每一行的转移只需要$O(1)$，总的复杂度为$O(N)$。 7.10-图论相关由于Cyani太弱了，所以图论的题基本不会，只能另开一篇了。。。 7.12~13-NOIP模拟赛一Day1&amp;Day2两场比赛完炸，只有100+100+10+100+80+0=390分。代码能力还是不够。 形态形成场 给定前$k$个大写字母的替换式$Si$，会出现大写字母和数字。求字符$A$所代表的串中有多少子串满足：子串为单个字符’0’或没有前导’0’，且把子串看作十进制数后模$n$等于0。 显然，我们可以按照拓扑序依次求出每个字符所代表的答案。 考虑如何合并两个区间的答案。假设我们需要将$a$和$b$合并为$c$，于是我们需要求出跨过中间的数的贡献。发现即为$a$的后缀$x$，与$b$的前缀$y$所合并的数$(x\\times 10^{leny}+y)\\ mod\\ n=0$。于是我们需要维护前缀$pre$[$i$]，与后缀$suf$[$i,j$]（ 保存$10^{leny}\\ mod\\ n$与$y\\ mod\\ n$）。为了维护前缀和后缀，还需要维护区间模$n$的值$val$与$10^{len}$模$n$的值。区间的合并类似线段树。 旅行商 旅行商要参加一些展销会（都在河的旁边，可以不参加），给定展销会的时间（只有一天），地点，收益，顺流和逆流行驶要一定的成本，可瞬间到达。求最大收益。 若展销会不在同一天，就是简单的$O(n^2)$DP。考虑一天参加多个展销会的情况。发现参加的展销会一定是一段连续区间，于是从之前的状态转移到现在的每个展销会，再同层状态向左或向右转移。非同层状态转移$O(n^2)$，同层状态转移$O(n^2)$，总的复杂度$O(n^2)$。 LEBOXES 有$n$个盒子，每个盒子有$Pi$的概率为$ \\$Vi$，否则为一颗钻石。有$m$个物品，每个物品需要$ \\$Ai$和$Bi$个钻石。打开箱子，买下尽可能多的物品。求购买物品的期望数。$n,m \\leq 30$ 预处理$f(i,j)$表示用至多$i$个钻石，买$j$个物品最少要花多少钱。这样就做到时间复杂度与$Ai,Vi$无关。同时观察数据范围可知，应该是折半搜索，再合并前后两段的答案。 爆搜可以得到前后两端获得若干钻石的钱数和概率，可以存在vector里。假设前一段钻石数$j$，后一段钻石数$k$，能买$i$个物品。发现对于不同的$(j,k)$，对于答案的贡献是独立的，于是我们需要分别求得概率$g(j,k,i)$。考虑到随着$i$的变小，$g(j,k,i)$变大，而$g(j,k,i)-g(j,k,i+1)$才是最多买$i$个的概率。 考虑如何求得$g(j,k,i)$。我们需要钱数$A(j,x)+B(k,y)&gt;=f(j+k,i)$，于是我们可以将之前的到的vector数组排序+求前缀和。于是我们只需移动指针$x$的同时，指针$y$也单调移动就行了。 考虑复杂度。枚举$i,j$为$O(nm)$，而$O(\\Sigma |B_k|)=O(2^{n/2})$。所以总的复杂度为$O(nm\\times 2^{n/2})$。 7.16~17-NOIP模拟赛一Day1&amp;Day2怎么说呢，题目比之前水，所以才有100+30+100+100+100+70=500。全场Rank5？ 压路机 在一个$n\\times m$的网格中，你需要从起点到终点。给定每条边所需的时间，其中出发后，结束前，改变方向前后都需要双倍的时间。求最少时间。$n,m \\leq 100$ 很显然的最短路。同时加上2维状态，表示之前的方向，以及之前的道路是否已经计算两次。相当于把一个点裂成5个点。直接跑Dijkstra或SPFA即可。 有一个坑点 直观上认为，走回头路一定是更劣的，于是一堆人被坑成30分；没有考虑的反而A了。事实上，假设有4个点$a,b,c,d$，有边$(a,b)$长1，边$(b,c)$长1，边$(b,d)$长100。如果不考虑，一定会选择$a\\rightarrow b\\rightarrow c$ ，代价为202；而如果$a\\rightarrow b\\rightarrow c\\rightarrow b\\rightarrow d$， 代价仅为104。 长城游戏 在$n\\times n$的棋盘上，有$n$个棋子。问最少移动几次，使得所有棋子在同一行或列。$n \\leq 6\\times 10^5$ 显然，如果我们要移到同一行，我们需要移到不同的列。类似均分纸牌一样，$O(n)$扫一边即可。 由于我太傻了，直接枚举都移到某一行或列，先排序，然后维护前缀和，前缀个数之类的东西。$O(n)$扫一边，比较出最优解。 事实上，一定是取中位数最优（初一都知道的常识）。。有位dalao取了平均数233。。。 历史 有个奇怪的王国，有$n$座城市。每年，在位的国王都会修建一条路$x&lt;=&gt;y$。有时候，国王闲得无聊就会计划一次$st\\rightarrow ed$的旅行，如果当前能完成这次旅行而$t$年前不能，国王就会高兴，否则会生气。并让下次旅行之前，建设的道路$x&lt;=&gt;y$错误地记为$(x+n-c)\\ mod\\ n&lt;=&gt;(y+n-c)\\ mod\\ n$。其中会发生国王的交替，初始国王的c为0，每个国王的c或许各不相同。求每次旅行计划，国王是否满意。$n,m \\leq 3\\times 10^5$ 显然并查集，由于要查询历史信息（可持久化并查集？233），考虑离线的做法。事实上我们只要把之后的询问挂在之前的时间上，直接计算即可。 考虑在线的做法。事实上就是要求两个点所在路径中，最后加边的时间。考虑到并查集的形态不能被破环，所以可以按秩合并。树高只有$O(logn)$，暴力向上爬求LCA即可。复杂度$O(nlogn)$。以上纯属口胡。。。 尾声半个月的集训结束了，可以说是收获颇丰。学到了很多，复习了很多知识，但也认识到自己的很多不足。这不是小学生的流水帐吗。。 在模拟赛中，由于做题心切，一心想打正解，导致正解打挂甚至根本没调出来。 先写暴力，再打正解，是比较稳妥的方式。 时间分配也要合理，留出充足的时间检查。 平时训练的时候，总是要交很多次才能A。没有很好地考虑到所有情况，小错误也比较多。 没有静下心来写，导致效率偏低。 差不多就是这些吧。以后也不会再更新了。反正继续加油~~","tags":[{"name":"集训","slug":"集训","permalink":"https://xuzhean.github.io/tags/集训/"}]},{"title":"AtCoder比赛记录&题解","date":"2017-07-01T14:00:00.000Z","path":"2017/07/01/AtCoder/","text":"题解都没补 未完成: ARC#078F, AGC#018B/C/D/E/F, ARC#079F ARC#080E/F ARC#081E/F 比赛记录2017年 比赛名称 AC/提交/总数 Rank AtCoder Regular Contest 077 2/3/4 144 AtCoder Regular Contest 078 2/2/4 477 AtCoder Grand Contest 018 1/2/6 549 AtCoder Regular Contest 079 3/3/4 261 AtCoder Regular Contest 080 2/3/4 674 AtCoder Regular Contest 081 2/3/4 290 AtCoder Grand Contest 019 2/3/6 423 Tenka1 Programmer Contest 2/2/4 243 CODE FESTIVAL 2017 qual B 3/4/6 256 题解AtCoder Regular Contest 077 D - 11 给定$n$和长度为$n+1$的子序列，每个数都在$[1,n]$，且恰有一个数出现两次。对于$k=1,2,…,n+1$，求出长度为$k$的互异子序列个数。$n \\leq 10^5$ 首先找出相同的两个数$x$的位置$l,r$，可以发现剩下的数都是等价的。对于每个$k$，分类讨论计数。按照选取$x$个数，就是$C{n-1}^k+2C{n-1}^{k-1}+C{n-1}^{k-2}$。注意到，如果在$(l,r)$内没有选数，选择$l$和选择$r$会被当作同一情况，于是答案还要减去$C{u+v}^{k-1}$。 E - guruguru 有一盏灯具有$1,2,…,m$种亮度。遥控板可以一次操作可以将亮度加一（为$m$时，变为$1$）或跳转到固定的亮度$x$。一开始亮度为$a1$，接下来$n-1$次，你需要将亮度从$a{i-1}$调节到$a_i$。选取一个$x$，使得调节的总次数最小。$n,m \\leq 10^5$ 记$f(x_0)$为：当$x=x_0$时，需要调节的总次数。考虑亮度$s\\Rightarrow t$ 对$f(x)$的贡献（假设$s&lt;t$， 其他情况同样处理）。 对于$x \\leq s$，$f(x)+=t-s$ 对于$s&lt;x \\leq t$， $f(x)+=t-x+1$ 对于$t&lt;x$，$f(x)+=t-s$ 发现是区间操作，并且只有在最后查询。于是考虑差分，特别的，需要分为常数部分和系数部分。 F - SS 定义“双串”，由两个相同的字符串拼接而成。定义$f(S)$，在双串S后追加最少字符得到的双串。给定$S0S0$和$l,r$。求$f^{10^{100}}(S0S0)$在$[l,r]$内，26个字母分别出现的个数。$|S|&lt;=2*10^5,l,r \\leq 10^{18}$ 有待更深入理解。用KMP预处理Next[]，可以的到S0的最短相同前后缀T，设$f(S0S0)=STST$。通过画图发现，若$|T|$是$|S|$的因数，那么S就是由一些T拼成的，$f(STST)=STTSTT$。否则，$f(STST)=STSTST$。设$g(S)g(S)=f(SS)$ ，能得到$g^{i+2}(S)=g^{i+1}(S)+g^i(S)$（显然，对于$i$无限大时也满足第一种情况）。考虑求出前缀的贡献，按照类似fib数列的递推方式计算即可。 AtCoder Regular Contest 078 D - Fennec VS. Snuke 有一棵有$n$个节点的树，A和B在树上玩涂色游戏。一开始，$1$号节点被涂上黑色，$n$号节点被涂上白色，其他节点没有被涂色。A和B轮流进行操作，不能继续操作的玩家输。对于A，能选择一个与被涂黑节点相邻的节点（未涂色）涂上黑色。B是对称的操作。 对于每个玩家，首要考虑的圈占尽可能多的地盘。于是一定先在$1\\rightarrow n$的路径上涂色，直到相遇。剩下未涂色的节点谁多，谁就获胜。一般地，我们可以转化为以$1$为根的有根树，找到路径$1\\rightarrow n$的中点$p$，比较$size(p)$与$n-size(p)$的大小即可。 AtCoder Grand Contest 018我太弱了，根本不会做啊啊啊啊。。。。 AtCoder Regular Contest 079","tags":[{"name":"比赛","slug":"比赛","permalink":"https://xuzhean.github.io/tags/比赛/"}]},{"title":"CodeForces比赛记录&题解","date":"2017-07-01T02:00:00.000Z","path":"2017/07/01/CodeForces/","text":"唔。。题解都没补。似乎除了Educational Codeforces Round都要补一补QAQ。 长期开坑 未完成: UPD 2017.11.6 粗体是补过题的，Div2的就不补了QAQ。 比赛记录1比赛名称 | AC/提交/总数 | Rank :—————————————————————————————————————————: | :——: | :–: Educational Codeforces Round 24 | 4/5/7 | 144 (虚拟) Codeforces Round #422 (Div. 2) | 4/4/6 | 111 Codeforces Round #423 (Div. 2, rated, based on VK Cup Finals) | 2/3/6 | 520 Codeforces Round #427 (Div. 2) | 4/4/6 | 93 Educational Codeforces Round 26 | 4/5/7 | 77 IndiaHacks 2nd Elimination 2017 | 2/3/6 | 27 Codeforces Round #428 (Div. 2) | 2/4/5 | 477 (虚拟) Codeforces Round #424 (Div. 2, rated, based on VK Cup Finals) | 5/5/6 | 38 (虚拟)Codeforces Round #426 (Div. 2) | 2/3/5 | 807 Codeforces Round #429 (Div. 2) | 3/3/5 | 646 (虚拟)Codeforces Round #421 (Div. 2) | 2/3/5 | 142 (虚拟)Codeforces Round #308 (Div. 2) | 3/4/5 | 475 (虚拟)Codeforces Round #342 (Div. 2) | 3/3/5 | 106 (虚拟)Educational Codeforces Round 1 | 4/5/6 | 63 (虚拟)Educational Codeforces Round 3 | 5/5/6 | 69 (虚拟)Educational Codeforces Round 4 | 5/5/6 | 35 AIM Tech Round 4 (Div. 2) | 3/4/5 | 70 (虚拟)Educational Codeforces Round 5 | 5/5/6 | 46 (虚拟)Educational Codeforces Round 6 | 5/5/6 | 36 Codeforces Round #430 (Div. 2) | 3/3/5 | 72 Codeforces Round #431 (Div. 1) | 1/2/5 | 577 Bubble Cup X - Finals [Online Mirror] | 4/5/10 | 84 Codeforces Round #433 (Div. 2, based on Olympiad of Metropolises) | 4/4/5 | 109 (虚拟)Manthan, Codefest 16 | 5/5/8 | 99 Russian Code Cup 2017 - Finals [Unofficial Mirror, Div. 1 Only Recommended, Teams Allowed] | 1/2/6 | 110 (虚拟)Codeforces Round #356 (Div. 1) | 2/3/6 | 156 (虚拟)Bubble Cup 9 - Finals [Online Mirror] | 3/3/9 | 129 (虚拟)Educational Codeforces Round 28 | 6/6/6 | 22 Codeforces Round #434 (Div. 1, based on Technocup 2018 Elimination Round 1) | 2/3/5 | 279 2017-2018 ACM-ICPC, NEERC, Southern Subregional Contest, qualification stage (Online Mirror, ACM-ICPC Rules, Teams Preferred) | 11/13/13 | 49 Educational Codeforces Round 29 | 5/5/7 | 60 Manthan, Codefest 17 | 4/4/7 | 175 (虚拟)MemSQL Start[c]UP 3.0 - Round 2 and Codeforces Round #437 (Div. 1) | 3/3/7 | 57 Codeforces Round #438 by Sberbank and Barcelona Bootcamp (Div. 1 + Div. 2 combined) | 2/4/7 | 741 Codeforces Round #439 (Div. 2) | 4/4/5 | 4 Codeforces Round #440 (Div. 1, based on Technocup 2018 Elimination Round 2) | 1/1/5 | 269 Codeforces Round #441 (Div. 1, by Moscow Team Olympiad) | 2/2/5 | 331 2017-2018 ACM-ICPC, NEERC, Southern Subregional Contest (Online Mirror, ACM-ICPC Rules, Teams Preferred) | 7/8/13 | 114 | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | 题解Codeforces Round #422 (Div. 2) CF822E。给定长度为$n$的字符串$s$，长度为$m$的字符串$t$（$m \\leq n$）。问是否能在$s$中分割出不超过$x$段不相交的连续子串，使得不打乱顺序后，能够组成字符串$t$？$n \\leq 10^5,x \\leq 30$ DP，贪心，HASH+二分求LCP。注意到一个事实，假设已经匹配到$s[i]$，那么我们一定要让已匹配的长度尽可能长，又由于$x$的取值并不大，由此得到状态的定义：定义$f[i][j]$表示$s[1..i]$划分为$j$段后，能在$t$中匹配的最长前缀。 假设$f[i][j]=k$，$l$为$s[i+1..n],t[k+1..m]$的$LCP$。考虑向后转移。 一种是不匹配，$f[i+1][j]=max(f[i+1][j],f[i][j])$。 一种是匹配，$f[i+tmp][j+1]=max(f[i+tmp][j+1],f[i][j]+tmp)$，$tmp$不大于$l$。 可是，这里的第二种转移是$O(n)$的，考虑如何优化。注意到，对于$tmp \\leq l$，$i+LCP(i+1,f[i][j]+1)=i+tmp+LCP(i+tmp+1,f[i+tmp][j]+1)$。所以从$f[i]$向后转移一定比从$f[tmp]$向后转移更优（或是相等，需要划分的段更少）。因此，我们只需要转移到$f[i+l][j+1]$即可。 $LCP$可以通过后缀数组（窝不会）或者经典的$HASH$+二分求出。 Code CF 822F。给定一棵树，每个节点有一个秒表，可以选择若干条不相交路径。对于一条路径，$a1,a2,a3…,ak$，选择边$(ai,ai+1)$上距离$ai$为$x$的位置出发。先一直走到$ak$，然后再返回到$a1$，如此往复。每秒钟走一条边。当点到达某个节点时，会把节点的秒表置$0$。请构造一种方案，使得节点$1$秒表的最大值最小，如果相同，使得$2$的最大值最小，以此类推。$n \\leq 100$ 贪心，构造。题意比较鬼畜，可能比较奇怪？注意到，一定是把所有单独的边作为路径最优。这样所有的运动就是以$2$为周期的。对于节点$i$，假设它的度为$d[i]$，我们将时间$2$划分为$d[i]$段，让$d[i]$条边上的点以$\\large \\frac 2 {d[i]}$为周期访问$i$。所以说因为这样的最优值唯一，所以和字典序无关。 算法用DFS实现，注意父节点向子节点的传递。 Code Codeforces Round #423 (Div. 2, rated, based on VK Cup Finals) CF828D。请构造一棵包含$n$个节点，$k$叶子节点的无根树。使得叶子节点的距离的最大值最小。$n \\leq 2 \\times 10 ^ 5$ 贪心，构造。以$1$为根，分出$k$个分支，答案一定是最优的。为什么呢？如果不这么做，达到相同的距离需要的边数会更少，增加边数后，答案一定更劣。三个月前的Cyani好傻逼啊。 Code CF828F。给定一个连通图，对于每条边求出它的最大权值，使其在图的所有最小生成树上（不改变其他边的权值）。$n,m \\leq 10^5$ 最小生成树，倍增。 非常套路的题，首先求出MST（也一定是最小瓶颈树），然倍增搞一搞就好了。分为两种情况： 这条边不在MST中。直接倍增求路径的$\\max$。（如果想要更小的常数，可以并查集按秩合并，不过不能修改？？） 这条边$(u,v)$在MST中。取连接$u,v$两端的非MST边，$(u,v)$一定要比最小值还要小，似乎要枚举每一条边？Cyani好傻逼啊。其实也可以倍增，只是从大的推到小的罢了。 嘴巴上AC很容易啊。既然是嘴巴选手，那么我就先不写。。 UPD: Code Codeforces Round #427 (Div. 2) CF835E，交互题。已知存在$n$个数，只有两个数是$y$，其他的数都是$x(x\\not=y)$。您可以询问任意一个子集的$xor$和。求出$y$所在的两个位置。询问数不得超过$19$。 构造好题，异或性质利用，二分查找。非常巧妙的一道题啊，考虑一个问题：如果只存在一个数为$x$，应该怎么做？很显然只要二分查找，不断缩小范围。关键在于如何区分两个$y$， 一开始的想法是随一半的位置，直到两个$y$存在不同的集合之中？应该不超过7,8就好了，很显然会被卡。由于数据组数过多，不能使用概率算法。 假设两个位置分别为$a,b$。考虑一个难以发现的性质，我们只需要不超过$10$次询问，询问强制某一位为0的子集，确定$a,b$在这一位是否相同。就能得到$a \\oplus b$的值。然后我们对$a$进行二分搜索即可。可是，似乎这样仍然需要$20$次？ 注意到$a,b$的顺序是无关对，对于某一位$a \\oplus b=1$（显然一定存在），只要强制$a$的那一位为$0$就好了。好妙啊。 一个有趣的事实，官方题解说不存在算法能够小于$19$次来解决这个问题（随机乱搞当然不算啊）。为什么呢？？题解没说。蒟蒻Cyani来口胡一下：对于每一个询问，实际上只能得到$2$种回复，偶数个或是奇数个$1$。总共的情况数为$C(1000,2)&lt;2^{19}$，所以说至少$19$次询问才能对应唯一一种情况。 Code CF835F。给定一个有$n$个节点和$n$条边的图，任意两点相互联通，无自环，无重边，求删掉一条边形成的树的直径的最小值。$n \\leq 2 \\times 10 ^ 5$ 环套树，树的直径。显然是一个环套树，假设环上有$k$个点。首先假设每个点对应的最大深度为$di$，断开$(i,i+1)$。那么有三种情况，$[1,i]$直径最大的点，$[i+1,k]$直径最大的点，$[1,i]$到$1$的最优距离$+1$到$k$的边$+[i+1,k]$到$k$的最长距离，取三者的最大值，来更新最小值。显然这些都可以$O(n)$预处理。 注意外向树的直径！ 貌似成为一名嘴巴选手了QAQ，代码周末补吧。。 UPD: Code 2KB代码写了1h，我好弱啊啊啊 自我感觉求基环的部分很简洁，以后就这么写啦。。 Codeforces Round #428 (Div. 2) CF839D。给定一个集合，包含一些整数$ai$。一个子集$s={a[i1],a[i2],a[i3],…,a[ik]}$的力量定义为$k\\times \\gcd{s}$。求所有子集的力量总和。$n \\leq 100000$ 数论，容斥原理。考虑每个$gcd$的贡献。定义$f[i]$为大小为$i$的集合的所有子集，的大小之和，显然有$f[i]=2f[i-1]+2^{i-1}$。但是这样会算重，由此想到容斥原理。 假设集合中$k$的倍数有$cnt$个，$f[cnt]$可以得到，$\\gcd$是$k$的倍数的贡献。考虑从$k$从大到小枚举，减去被数的个数，由此可以的得到$\\gcd = k$的个数。 Code CF839E。给出$n(n≤40)$个点的邻接矩阵，要求给每个点赋值，使得点的权值和为$K$，每条边权值为两端点点权的乘积，最大化边的权值和。 最大团问题。不会做啊，CF的Div2竟然有论文题！！！题解，有时间再补。 Codeforces Round #424 (Div. 2, rated, based on VK Cup Finals) CF831F。有$n$棵竹子，竹子每天长$1m$，每个竹子都有一个临界高度$ai$，每$d$天去看竹子，如果有竹子的高度超过了对应的临界高度，就它砍断(不会再长高)，然后把高于$ai$的部分收集起来现在求一个最大的$d$，满足最后收集到的竹子长度小于等于给定的$k$。 $n \\leq 100,k \\leq 10^{11},ai \\leq 10^9$ 数论，分块好题。假设隔$d$天看一次竹子，那么得到的长度为： $$\\large \\sum_{i=1}^n \\left( d\\times \\lceil\\frac {ai} d \\rceil - ai \\right)$$ 又需要满足条件，得到不等数，再两端再同除以$d$，整理得到，（$sum$表示$k$与$ai$之和） $$\\large \\sum_{i=1}^n \\lceil \\frac { ai } {d} \\rceil \\leq \\lfloor \\frac {sum} d \\rfloor$$ 考虑按照$\\large \\lfloor \\frac {sum} {d} \\rfloor$来分块，如果存在$d1,d2(d1&lt;d2)$满足： $\\large \\lfloor \\frac {sum} {d1} \\rfloor = \\lfloor \\frac {sum} {d1} \\rfloor$ 如果$d1$满足，那么$d2$一定满足。所以，我们只要对于块内的最大值进行check。复杂度$O(n\\sqrt{sum})$。 Code Codeforces Round #426 (Div. 2) CF834C。有$n$场游戏，初始分均为1，每回合，胜者分数乘上$k^2$，输的分数乘上$k$，（每一回合的$k$都是任意的）。给定两个数$a,b$，问这两个数是否可能是他们最终的分数。$n \\leq 3.5\\times 10^5,a,b \\leq 10^9$ 数论，二分。注意到$a\\times b$一定可以表示为$k[1]^3 \\times k[2]^3 \\times k[3]^3 \\times … \\times k[m]^3$，此处的$k[1],k[2],…$有可能相等。考虑二分找到$mid=k[1]\\times k[2]\\times … \\times k[m]$，如果能找到并且$mid|a,mid|b$，那么一定是存在一种方式的，反之则不存在。 话说Cyani在VP的时候好傻逼啊，竟然不会做。暴力乱搞搞到TLE69，优化无果就弃了。rk:800+ Code CF834D。有一个长度为$n$的序列，划分为$K$个连续子序列，每个子序列的价值为不同的元素种类。求所有子序列的代价总和的最大值。$n \\leq 35000,K \\leq 50$ DP，线段树。显然是一个DP，首先考虑最暴力的方式：定义$f[i][j][k]$表示前$i$个元素划分为$j$个子序列，最后一个子序列从$k$开始。两种转移： 从$f[i-1][j][k]$转移，如果$[k,i-1]$中没有出现过$a[i]$，那么加一。判断是否出现，我们只需要记录每个元素上一次出现的位置即可。 从$f[i-1][j-1][t]+1$转移到$f[i][j][i]$。 发现状态难以优化，考虑优化转移。事实上，我们可以将所有$f[i][j][]$用线段树维护，对于转移1，就是区间修改，转移2就是询问区间最值。维护$K$棵线段树即可。 Code CF834E。给定区间$[L,R]$，求区间中的数去掉这个数中的$0$之后，把这个数各个数位上的数从小到大排列后，总共有多少个不同的排列情况。$L,R \\leq 10^{18}$ 爆搜。又是爆搜？？暂时弃了。。题解 Codeforces Round #429 (Div. 2) CF841D。给定一个包含$n$个节点，$m$条边的无向图。可能包含重边，但不包含自环。每个节点的值$di$可能为$0,1,-1$。找出一个边的集合满足：对于每个点$i$，在集合中$i$的度数模$2$为$di$，或者$di=-1$。$n,m \\leq 3\\times 10^5$ 构造。算是比较好的一道构造题。考虑这样一个事实：如果存在解，那么一定存在一个解满足构成的图是森林。为什么？如果存在一个环，那么把所有环的边去掉，节点度的奇偶性仍然不变。于是可以像树一样进行$DFS$，考虑每一条边是否需要保留即可。 考虑这样一个性质，对于树上的一条路径，只有路径两端的奇偶性才会变化。如果$DFS$到了节点$u$，可以通过$u$将$u$的子树中的路径配对（如果$d[u]=1$，那么$u$也要配对）。最后只会留下$0,1$条未配对路径，返回给父节点。 Code CF841E。给定包含$n$个数的数组$a[]$，对于一个长度为$n$的置换$P$，如果对于$1 \\leq i &lt; n$，不存在$a[p[i]\\times a[p[i+1]]$是完全平方数，那么置换$P$是满足条件的。求有多少个置换是满足条件的。$n \\leq 300$ 组合，DP，好题。考虑将所有数划分为若干个组，每个组的数两两相乘都是完全平方数（也就是这些数包含的质因子的指数奇偶性相同）。这样就转化为，存在若干种物品，同种物品不能相邻的方案数。设第$i$组有$cnt[i]$个数，考虑DP。 定义$f[i][j]$表示，对于前$i$组数，存在$j$对相邻为同组的数的方案，对于同组的数是无序的。于是我们在转移（加入一组新的数）的时候，首先将这组数划分为$k$段，再挑选$p$段插入到相邻的同组数中，最后再将剩下的段插入。其中$m=cnt[1]+cnt[2]+…+cnt[i-1]$。 $$\\large f[i][j+cnt[i]-k-p] = f[i-1][j] \\times C(cnt[i]-1,k-1) \\times C(j,p) \\times C(m-1-j+2,k-p)$$ Code Codeforces Round #431 (Div. 1) CF848B。有一个$W*H$的矩阵在坐标轴上。从$x$轴出发有一些舞者，在位置$pi$时间$ti$，沿着$y$轴正方向走。$y$轴同样如此。当两个舞者相遇时，他们会改变各自的方向为对方的方向。问所有舞者的最终位置。 $W,H,n \\leq 10^5$ 脑洞题。注意到满足$pi+tj=pj+ti$的两个舞者会相遇，可以按照$pi-ti$的值将所有舞者划分为若干类，每一类都会碰撞一次。根据$x,y$轴上的舞者数目可以$O(1)$判断每个舞者交换后对应的舞者。 C，cdq分治。 D，网络流。 E，FFT。 好一场CN Round！ Bubble Cup X - Finals (Online Mirror) CF852A。给一个$10^{200000}$以内的数字，支持一种操作：在数字之间加若干个加号，把原数字变为加法运算后的结果，要求在三次操作内把数字变成个位数，输出方案。 随机化。注意到如果每次在所有数字间加上加号，容易出现$999..$的情况。所以可以随机化，每一次多合并相邻的两位，直到答案符合要求。还是比较容易被满足的。 CF853C。给定一个正$2n$边形，每条边被分为$n$等分，其中第$0,2,..,2n-2$条边上各选择一个蓝点$B0,B2,..,B2n-2$（保证是$n$的置换）。 您需要确定$B1,B3,..,B2n-1$（同样是$n$的置换），使得这些$B$点构成的面积最大。 贪心，一次函数。注意到白色三角形的面积总和是关于$B1,B3,..$的一次函数。计算出系数后，根据排序不等式即可贪心配对。 D，二分+网络流。 H，毒瘤。 I，树上莫队。 Manthan, Codefest 16 CF633E。给定$n$和长度为$n$的两个数组$v[i],c[i]$，定义区间的价值 $$\\large p(l,r) = \\min(100 \\times \\max {k=l} ^{r} v[k],\\ \\min {k=l} ^{r} c[k])$$ 会随机选择一些$li$，您会选择对应$ri(li \\leq ri)$，使得$p(li,ri)$最大。求所有最大值的最小值的期望值。 $n \\leq 10^6$ 期望，对数转化。注意到对于给定的$l$，我们可以预处理$ans[l]$为最大的$p(l,r)$。具体就是$ans[i] = \\min ( \\max (100 \\times v[i], ans[i+1]), c[i])$。 发现选择的$K$个$ans[i]$中，只有最小的一个才会产生贡献。考虑所有$ans[i]$按照递增来排序，新的$ans[i]$的贡献为$\\large \\frac {C(n-i,K-1) \\times ans[i]} {C(n,K)}$。发现$n$实在是太大了，所以可以将组合数转化为对数的运算。 Code","tags":[{"name":"比赛","slug":"比赛","permalink":"https://xuzhean.github.io/tags/比赛/"}]},{"title":"Hello World!","date":"2017-06-30T16:00:00.000Z","path":"2017/07/01/Hello-World!/","text":"博主是ZJSX某蒟蒻。 小学连续三年水了市里的一等，感觉什么都没学。 初一PJ差10分一等，还是我太弱了 初二PJ侥幸385。20+人并列，一定是题目太水了 ZJOI2017，一试30分，二试70分。伪装成神犇？ NOIP2017，540意外挂成450。身为蒟蒻的我已经很满意辣。 明年ZJOI加油！ 现在初三，正在为ZJOI2018而努力，一起加油吧~ 大事记以下是蒟蒻Cyani闲的无聊瞎写写的。 2017.7.25 BZOJ 100AC 纪念。 2017.8.17 我的心路历程。 2017.8.18 百度之星复赛。成功熟练地切掉水掉签到题，骗到了T恤。 2017.8.25 靠手速+疯狂HACK，成功水到rk4。然而，被FST了QAQ。还是没能紫QAQ。。 解锁成就：成为一名Cha人狂魔。。 2017.8.30 终于在暑假前紫名了！ 2017.9.2 遇到了一场假比赛和假题目，rating掉了80。瞬间打回原型QAQ。 2017.9.3 第一次打(单人)ACM赛制，一人单挑一支队！虽然做得慢，但还是成功靠罚时少的优势，水到了A了四题中的rk2！能A四题还是很满意的。。 2017.9.16无聊vp了一场教育赛。。应该是史上最简单的QAQ。然后，6题1A+AK！ 解锁成就：CF中第一次AK，第一次所有题1A。。 2017.9.24 打了一场Div1+Div2的Round，最后3分钟刚出E，想想真是一颗赛艇啊QAQ。 2017.10.6 #439(Div2),CN Round凭借CN套路，小号成功rk4，上首页辣！ 2017.11.13 NOIP考挂辣。本来540的分数，因为DayT1,T3两个傻逼错误，直接变成450了。明年ZJOI加油吧!期待进入省队的那一刻！","tags":[]}]