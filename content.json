[{"title":"《代数学引论》 第一卷","date":"2017-12-31T16:01:00.000Z","path":"2018/01/01/Note-Introduction-to-Algebra-Volume-I/","text":"《代数学引论: 基础代数》笔记致谢：部分习题答案 某道习题答案 _Chapter 1_ 代数基础Section 1 线性方程组初步基本概念可以写成矩阵形式，$ Ax = B$。齐次线性方程组定义为，$\\forall\\; i = 1 \\cdots n, b_i = 0$ （存在零解） 若 $n=m$，称之为 方阵，它的 主对角线 即为 $\\{a_{11},a_{22},a_{33},\\cdots,a_{nn}\\}$ 定义一种特殊的方阵， 对角矩阵： 满足 $\\forall\\; i \\not=j,a_{ij}=0$，记为 $\\mathrm{diag}\\{a_{11},a_{22},a_{33},\\cdots,a_{nn}\\}$。而作为特殊的对接矩阵，纯量矩阵 定义为 $\\mathrm{diag}\\{a_{11},a_{22},a_{33},\\cdots,a_{nn}\\}$，$\\forall\\; i = 1 \\cdots n, a_{ii} = a$，记为 $\\mathrm{diag}_n(a)$。单位矩阵 $\\mathrm{diag}_n(1)$，记为 $E_n$ 上三角矩阵 $n=m,\\forall\\; i &gt; j,a_{ij} = 0$，下三角矩阵 $n=m,\\forall\\; i&lt;j,a_{ij} = 0$。方便起见，将方阵 $A$ 化为上三角矩阵后的形式记为 $\\bar{A}$ 线性方程组的 相容性 指的是是否有解；而 确定性 指解是否唯一 初等变换 $\\Rightarrow$ 化为阶梯形I型初等变换 交换两行 II型初等变换 其中一行加上另一行的常数倍 初等变换可逆，变换后在许多意义下等价 阶梯形线性方程组设 $r$ 是阶梯形线性方程组的行数 如果 $\\exist\\; t&gt;r,b_t \\not= 0$， 方程组不相容 自由变量 $\\Rightarrow$ 主未知数 如果 $n=r$ ，方程组即为三角形式，存在唯一解 推论：$n &gt; m$ 时，相容的方程组是不定的 Section 2 低阶行列式二阶行列式$\\begin{pmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a _{22} \\end{pmatrix}$ 的行列式 $\\begin{vmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a _{22} \\end{vmatrix} = a_{11}a_{22} - a_{21}a_{12}$ 可以发现，$\\begin{vmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{22} \\end{vmatrix} x_1 = \\begin{vmatrix} b_1 &amp; a_{21} \\\\ b_2 &amp; a_{22} \\end{vmatrix}$ ，于是可以得到 $x_1,x_2$ 的行列式表达 _一般地，对于 $x_i$ 只需要将第 $i$ 列替换为 $b_1,\\cdots,b_n$ 即可_ 三阶行列式对于三个未知数，两个齐次方程的线性方程组，令 $y_1 = - \\frac{x_1} {x_3}, y_2 = -\\frac{x_2} {x_3}$，可以得到关于 $y_1,y_2$ 的二元方程组，进而得到二阶行列式表达。得到特解， $$x_1 = \\begin{vmatrix} a_{12} &amp; a_{13} \\\\ a_{22} &amp; a_{23} \\end{vmatrix} \\quad x_2 = \\begin{vmatrix} a_{12} &amp; a_{11} \\\\ a_{23} &amp; a_{21} \\end{vmatrix} \\quad x_3 = \\begin{vmatrix} a_{11} &amp; a_{12} \\\\ a_{21} &amp; a_{23} \\end{vmatrix}$$ _如果 $\\exist\\; i\\in\\{1,2,3\\},x_i \\not = 0$，所有解都可以由特解乘以常数得到_ 考虑一个三元方程组，配上系数 $c_1,c_2,c_3$，可以消掉 $x_2,x_3$。最后得到关于 $x_1$ 的二阶行列式表达，$x_1$ 前的系数即为三阶行列式 $$\\begin{vmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ a_{31} &amp; a_{32} &amp; a_{33} \\end{vmatrix} = a_{11}a_{22}a_{33} + a_{12}a_{23}a_{31} + a_{13}a_{21}a_{32} - a_{11}a_{23}a_{32} - a_{12}a_{21}a_{33} - a_{13}a_{22}a_{31}$$ Extra命题：三阶行列式的六项不可能都是正的 _proof_ 设 $A$ 为所有 $+$ 项的乘积，$B$ 为所有 $-$ 项的乘积，必然有 $A+B=0$ $A,B$ 异号或均为 $0$，必然存在负的一项 _对于二阶行列式，沿着主对角线翻转，值取为相反数；而对于三阶行列式，翻转后不变_ Section 3 集合与映射集合如果 $T \\subset S$，差集 $S \\backslash T$ 也称为 $T$ 在 $S$ 中的 补集 对于两个集合 $X,Y$，笛卡尔积 $X \\times Y = \\{(x,y) | x \\in X, y \\in Y\\}$ （由此可以定义多元函数） 例如 笛卡尔平方 $\\mathbb{R^2 = R \\times R}$ 就表示实平面 对于有限集 $A$，其 基数 $|A$| 定义为 $A$ 的元素个数 对于无限集 $A$，存在一一映射 $f:X \\rightarrow Y$ 与 $\\mathbb{N}$ 基数相同的集合，称作 可数集，记作 $\\large \\aleph_{0}$ 映射对于集合 $X,Y$，存在变换 $f:X \\rightarrow Y$，即为 映射 （对应有 定义域，值域） 可以定义 象 $\\mathrm{Im} f = \\{f(x) | x \\in X\\} = f(X) \\subset Y$ 类似定义 原象 $\\begin{eqnarray} f^{-1}(Y_0) = \\{x \\in X | f(x) \\in Y_0\\} = \\bigcup _{y \\in Y_0} f ^ {-1} (y) \\;(Y_0 \\subset Y) \\end{eqnarray}$ _定义域和值域是一个映射（函数）的本质部分（是映射相同的必要条件）_ 定义 单位映射 $e_X: X \\rightarrow X$，指向自己 如果 $X \\subset X’ , Y \\subset Y’, f:X\\rightarrow Y, g:X’ \\rightarrow Y’,\\quad \\forall x \\in X, f(x) = g(x) $，$g$ 是 $f$ 的 扩张，类似可以定义 收缩 定义映射的乘积（合成） $fg(x) = f(g(x))$ 定理一：映射的合成满足结合律（直接运用定义证明） 定义 逆映射，设 $f:X \\rightarrow Y, g: Y \\rightarrow X$，如果 $fg = e_Y$ 那么 $f$ 是 $g$ 的 左逆 ，$g$ 是 $f$ 的 右逆 如果存在 $fg =e_Y, gf = e_X$，$g,f$ 互为 逆 引理：如果 $gf = e_X$ 则 $f$ 是单的，$g$ 是满的（用单射 / 满射定义证明） 定理二：$f:X \\rightarrow Y$ 有逆，当且仅当 $f$ 是双射（左推右，直接利用引理；右推左，根据定义） 推论：对于双射 $f:X \\rightarrow Y$，$(f^{-1})^{-1} =f$。如果 $f:X \\rightarrow Y, h: Y \\rightarrow Z$ 都是双射，必定有 $hf$ 也是双射，同时 $(hf)^{-1} = f^{-1} h^{-1}$ 定理三：$X$ 是有限集，变换 $f:X \\rightarrow X$ 是单射，则 $f$ 是双射（满射同理）（利用有限性，证明它是满射即可） Extra_设 $f:X \\rightarrow Y,\\; S \\subset X, T \\subset X$，有 $f(S \\cup T) = f(S) \\cup f(T), \\quad f(S \\cap T) \\subset f(S) \\cap f(T)$_ Section 4 关系二元关系对于集合 $X,Y$，定义 $\\omega \\subset X \\times Y$ 为 $X,Y$ 间的一个 二元关系 $(x,y) \\in \\omega$ 用 $x \\omega y$ 表示，称 $x,y$ 间有关系 $\\omega$ 例如 $&lt;$ 是 $\\mathbb{R}$ 的一个二元关系，由 $\\mathbb{R}$ 上位于 $x=y$ 上方的点组成 等价关系集合上的二元关系 $\\sim$ 叫做 等价关系，任取 $x,x‘,x’’ \\in X$ 满足 反身性，$x \\sim x$ 对称性，$x \\sim x’ \\Rightarrow x’ \\sim x$ 传递性，$x \\sim x’,x’ \\sim x’’ \\Rightarrow x \\sim x’’$ 可以定义 $x$ 的 等价类 $\\overline{x} = \\{ x’ \\in X | x’ \\sim x \\} \\subset X$ 定理：由 $\\sim$ 确定的等价类的集合是 $X$ 的一个划分，是这些子集的不交并，记为 $\\pi _{\\sim} (X)$ 商映射简单来说，商映射 是将 $x \\in X$ 映射到对应的等价类 即定义满射 $p: x \\mapsto p(x) = \\overline{x}$，叫做 $X$ 到 商集 $X / \\sim$ 的 自然映射 _在某个给定的映射 $f$ 下_ 定义映射 $\\overline{f}:X/\\omega_f \\rightarrow Y,\\;\\overline{f} (\\overline{x}) = f(x)$（不依赖于 代表元 $\\overline x$ 的选取） 于是有 $f = \\overline{f} \\cdot p$ 序集一个 全序集 $X$，存在二元关系 $\\le$ 满足反身性，反对称性和传递性。称 $X$ 上有一个 偏序 联系图论中的DAG，可以定义 最大元，极大元，最小元，极小元 Section 5 数学归纳法注意归纳基础 二重归纳原理 … Section 6 置换置换的记法考虑一个 $n$ 元有限集 $\\Omega = \\{1,2,3,\\cdots,n\\}$，置换 即为一一映射 $\\pi : i \\mapsto \\pi(i)$，全体置换记作 $S_n$（显然有 $|S_n| = n!$。与一般的映射类似的，置换存在单位元，恒等映射 $e = e_{\\Omega}$，同样可以定义乘法，满足同样的运算律 对于置换 $\\pi$，一种方便的记法是 $\\large (i, \\pi(i), \\pi^2(i), \\pi^3(i), \\cdots, \\pi^{n-1}(i))$ 置换的循环结构定义置换 $\\pi$ 的 阶 $q$，满足 $\\langle \\pi \\rangle = \\{e, \\pi, \\cdots, \\pi^{q-1}\\}$ 包含所有互不相同的方幂，同时 $\\pi ^ q = e$ 我们可以定义两个点 $i,j \\in \\Omega$ 是 $\\pi$ 等价 的，当且仅当 $\\exist s \\in \\mathbb{Z},\\; j = \\pi ^ s(i)$ 于是我们将 $\\Omega$ 划分为若干类，$\\Omega = \\Omega_1 \\cup \\cdots \\cup \\Omega_p$，称之为 $\\pi$ 轨道 考虑其中一个 $\\pi$ 轨道 $\\Omega_k$（令 $l_k = \\Omega_k$），令 $\\pi_k = (i, \\pi(i), \\cdots, \\pi ^ {l_k-1})$，我们得到一个置换，称之为 长为 $l_k$ 的置换（显然置换 $\\pi_k$ 使集合 $\\Omega \\backslash \\Omega_k$ 中的点不动，于是两个循环是 无关的） 所以 $\\pi$ 可以对应到乘积的分解 $\\pi = \\pi_1 \\pi_2 \\cdots \\pi_p$ （显然可以省略恒等置换） 运用数学归纳法即可证明：定理一： $S_n$ 中的每一个置换 $\\pi \\not= e$ 都可以唯一地分解为长度 $\\ge 2$ 且不相交的循环的乘积 接下来考虑长度为 $2$ 的循环，称作 对换 一个简单的 推论：任何置换 $\\pi \\in S_n$ 都可以表示为对换的乘积，而且并不唯一 （直接构造即可，比如 $(i_1,i_2,\\cdots,i_l) = (i_1,i_l)(i_1,i_{l-1}) \\cdots (i_1,i_2)$ ） 考虑 $\\pi \\in S_n$，分解为对换的乘积 $\\pi = \\tau_1 \\tau_2 \\cdots \\tau_k$，定义 $\\epsilon_\\pi = (-1)^k$ 为 $\\pi$ 的符号（奇偶性） 一个重要 定理二：$\\epsilon_\\pi$ 的奇偶性是唯一确定的，与分解式无关，满足 $\\epsilon_{\\alpha \\beta} = \\epsilon_\\alpha \\epsilon_\\beta$。 只需要考虑数学归纳法，找到 $m$ 个因子变为 $m-2$ 个因子的构造性依据（参见 $\\mathrm{page}\\; 41$） 显然如果 $\\pi \\in S_n$ 会分解为 $m$ 个循环（包括长度为 $1$ 的），有 $\\epsilon_\\pi = (-1)^{n-m}$ 构造 $L_r : \\pi \\rightarrow \\tau \\pi$，是一个一一映射，即可得到 结论：$S_n$ 中奇置换个数等于偶置换个数 定义一个 $n$ 元函数 $f$ 是 斜对称的，当且仅当交换相邻变量的位置时，函数变号。数学归纳法可以得到 推论：交换任意两个变量，函数变号，运用这个推论也可以证明定理二 Extra定义 $\\begin{eqnarray} \\mathrm{sgn}(\\pi) = \\prod _ {1 \\le i &lt; j \\le n} \\frac {\\pi(j) - \\pi(i)} {j-i} \\end{eqnarray}=(-1)^k$，$k$ 即为置换的逆序对个数，显然有 $\\epsilon_\\pi =\\mathrm{sgn}(\\pi)$ 只需要构造对换，使得每一次对换减少一个逆序对。具体地，假设 $1,2,\\cdots,i-1$ 已经排列完毕，在 $i-1$ 到 $i$ 中间的数都比 $i$ 要大，每一次将 $i$ 和前面一个元素交换，即可减少一个逆序对，直到 $i,i-1$ 相邻 Section 7 整数的算术算术基本定理：任意正整数 $n \\not= 1$ 必定能唯一地分解为素数的乘积 （尽管非常显然，定理只涉及到整除的性质，但是定理的证明需要用到 $\\mathbb{Z}$ 中的加法与乘法运算） _Chapter 2_ 矩阵Section 1 行和列的向量空间定义 行向量 是属于向量空间 $\\mathbb{R}^n$ 的一个元素，列向量 与 行向量 的区别仅仅只是约定。$\\mathbb{R}$ 的运算法则适用于 $\\mathbb{R}^n$ 线性组合. 线性包考虑 $X_1,X_2,\\cdots,X_k \\in \\mathbb{R}^n$，$X = a_1X_1 + a_2X_2 + \\cdots + a_kX_k$ 是向量 $X_i$ 带有系数 $a_i$ 的 线性组合 令 $V = \\langle X_1, X_2, \\cdots, X_k \\rangle$，是这些向量的所有线性组合构成的集合，称之为向量组的 线性包，称 包 是这些向量 张成的 满足性质 $S \\subset V \\Rightarrow \\langle S \\rangle \\subset V$，$0 \\subset V$ 重要结论：线性包 $U,V$ 的交集一定是线性包，而并集不一定是线性包（证明交集的线性组合在交集内即可；可构造反例 $U = \\{(a,0)|a \\in \\mathbb{R}\\}, V = \\{(0,a)|a \\in \\mathbb{R}\\}$） 线性相关对于空间 $\\mathbb{R}^n$ 中的向量组 $X_1, X_2, \\cdots, X_k$，如果存在 $k$ 个不全为 $0$ 的数，使得 $$a_1X_1 + a_2X_2 + \\cdots + a_kX_k = 0$$就称这个向量组是 线性相关的 下面是一些 显然而非常重要的定理：（直接利用线性相关的定义即可） 向量组的一部分是线性相关的，整体也是线性相关的；线性无关向量的任意一部分都是线性无关的 线性相关的向量组至少存在一个向量是其他向量的线性组合；如果存在一个向量是其他向量的线性组合，那么这个向量组的线性相关的 向量组 $X_1, \\cdots, X_k$ 是线性无关的，$X_1,\\cdots,X_k,X$ 是线性相关的，$X$ 是其他向量的线性组合；如果 $X$ 不能表示为其他向量的线性组合，那么这向量组是线性无关的 基. 维数定义向量组 $X_1,\\cdots,X_r \\in V$ 是 $V$ 的 基，当且仅当他们线性无关，并且 $\\langle X_1, \\cdots, X_k \\rangle =V$。$r$ 即为 $V$ 的 维数 对于 $X \\in V$ 显然存在唯一的 $\\{a_i\\}$，使得 $X = a_1X_1 + \\cdots + a_kX_k$，系数 $\\{a_i\\}$ 称之为 $X$ 相对于基 $X_1,\\cdots,X_k$ 的 坐标 定义 标准基 $\\{E_{(1)}, E_{(2)}, \\cdots, E_{(n)}\\}$，它是 $\\mathbb{R}^n$ 的基。其中 $E_{(i)} = (0,0,\\cdots,1,\\cdots,0)$（第 $i$ 项为 $1$） 一个重要的 引理：设 $V = \\langle X_1, \\cdots, X_r \\rangle$ ，$Y_1, \\cdots, Y_k$ 是线性包 $V$ 内线性无关的向量组，则有 $s \\le r$（利用反证法，设 $x_1Y_1 + \\cdots + x_kY_k = 0$，得到一个 $r$ 行 $s$ 列的齐次线性方程组，存在非零解，与条件矛盾） 定理：对于一个线性包 $V$ 的所有基，都含有相同个数的向量，一定满足 $r \\le n$，记作 $\\mathrm{dim}\\; V$（每次不断扩充将 $V$ 中无法线性组合的 $X_k$ 加入线性包，根据引理，最后得到的个数 $r \\le n$；设存在两组基 $\\{X_i|i=1,\\cdots,r\\},\\{Y_i|i=1,\\cdots,s\\}$，根据引理 $s \\le r, r \\le s$ 得到 $s=r$） 定义向量组 $\\{X_1, X_2, \\cdots\\}$ 的 秩，$\\mathrm{rank}\\{X_1,X_2, \\cdots \\} =\\mathrm{dim} \\langle X_1, X_2, \\cdots \\rangle$ 特别的，对于 $V = \\{0\\}$，我们定义 $\\mathrm{dim}\\; V = 0$ Extra设 $U,V$ 是两个 $\\mathbb{R}^n$ 中的线性包，定义 线性包的和： $$U + V = \\langle U \\cup V \\rangle = \\{u + v | u \\in U, v \\in V\\}$$如果 $U \\cap V = 0$，称 $U \\oplus V = U + V$，为 直和 命题：$V = V_1 \\oplus V_2 \\oplus V_3 \\oplus \\cdots \\oplus V_k$ $\\large \\Longleftrightarrow$ $X = X_1 + \\cdots +X_k\\in V \\; (X_i \\in V_i)$ 的表示方法唯一 _proof_ 假设存在两种表示方法，必定存在 $X_i + X_j = X’_i + X’_j\\;(X_i \\not=X’_i,X_j \\not=X’_j)$，那么有 $X_i-X’_i = X_j-X’_j \\in V_i \\cup V_j$，而 $V_i \\cup V_j = 0$，矛盾 类似于之前的构造性方法，假设存在两个线性包有交集，得到表示方法不唯一 设 $V$ 是 $\\mathbb{R}^n$ 中的一个线性包，如果 $V = U \\oplus W$，那么 $W$ 叫作 $U$ 在 $V$ 中的 补 命题： $U$ 在 $V$ 中的补是唯一确定的 假命题。 容易举出反例：$U = \\mathbb{R}^2,V = \\{(\\lambda,0)|\\lambda \\in R\\}$，则 $W$ 可以取 $\\{(0,\\lambda)|\\lambda \\in R\\}$ 或者 $\\{(\\lambda,\\lambda)|\\lambda \\in R\\}$ 证明：$\\mathbb{R}^n$ 中的向量组 $X_1, \\cdots, X_n$ 张成 $\\mathbb{R}^n$，当且仅当它们是线性无关的 _proof_ 假设它们是线性相关的，那么它们的维数 $r &lt; n$，小于 $\\mathbb{R}^n$ 的维数，无法张成，矛盾 考虑任意一个向量 $X \\in \\mathbb{R}^n$，是否是线性组合，即一个方程组是否存在解。由于它们线性无关，一定能变成三角矩阵（构造一个齐次方程组，不存在非零解，所以变换的时候不会使得某一行都为 $0$），故存在解 证明：$U,V$ 是 $\\mathbb{R}^n$ 中的线性包，若 $U \\cap V = 0$，则 $\\mathrm{dim}(U+V) = \\mathrm{dim}\\;U + \\mathrm{dim}\\;V$ _proof_ 考虑选取 $U+V$的基为 $U,V$ 的基的并。只需证明：$U,V$ 的基的并线性无关，基的并能张成 $U+V$。两者显然 Section 2 矩阵的秩矩阵的秩将矩阵 $A$ 的第 $i$ 列记作 $A^{(i)}$，线性包 $V_c =\\langle A^{(1)}, A^{(2)}, \\cdots, A^{(n)} \\rangle$ 叫作矩阵的 列空间，列秩 $r_c = \\mathrm{dim}\\;V_c$ 类似地，我们将第 $i$ 行记作 $A_{(i)}$，线性包 $V_r = \\langle A_{(1)}, A_{(2)}, \\cdots, A_{(m)} \\rangle$ 叫作矩阵的 行空间，行秩 $r_r = \\mathrm{dim}\\;V_r$ 一个重要的 引理：对于一个矩阵 $A$ 经过有限次行初等变换后，得到了矩阵 $A’$，那么有 $r_r(A’) = r_r(A), r_c(A’) = r_c(A)$（只需考虑一次初等变换后不变，对于行秩，利用定义显然；对于列秩，只需要证明其 极大线性无关组（是它的其中一个基）的大小不变：它对应的齐次方程组的解不变，即极大线性无关组无法加入新的向量，也无法减少向量） 通过这个引理可以得到重要 定理：对于任意 $m \\times n$ 阶矩阵 $A$，等式 $r_c(A) = \\mathrm{rank}\\;A =r_r(A)$ 成立（其中 $\\mathrm{rank}\\;A$ 叫作矩阵 $A$ 的秩） 首先通过行初等变换得到阶梯矩阵 $A’​$，记 $r​$ 为非零行数。提取每一个非零行开头第一个不是 $0​$ 的元素所在的列，称之为矩阵的 列向量基，显然他们线性无关，得到 $r_c(A’) \\ge r​$；又 $r_c(A’) = \\mathrm{dim}\\; V’_C \\le \\mathrm{dim}\\; \\mathbb{R}^r = r​$，得到 $r_c(A’) = r​$。而 $r_r(A’)=r​$ 是显然的 可解性原则结合之前定理的证明过程，我们可以得到 结论：对于一个齐次方程组，化为阶梯形后，它的主未知数个数等于矩阵的秩 _这句话表明，矩阵的秩是其内在特征，不依赖于任何外加状况_ 克罗内克-卡皮里定理：线性方程组是有解的，当且仅当它的系数矩阵的秩等于其增广矩阵的秩（注意，该定理无法判断是否存在唯一解 考虑必要性，$Ax=B$ 存在解，当且仅当列向量 $B$ 是矩阵 $A$ 的列向量的线性组合，即有 $\\mathrm{rank}(A^{(1)},\\cdots,A^{(n)}) = \\mathrm{rank}(A^{(1)},\\cdots, A^{(n)},B)$。得到 $\\mathrm{rank}\\;A = r_c(A) = r_c((A|B)) = \\mathrm{rank}\\;((A|B))$ 考虑充分性，如果 $A,(A|B)$ 的秩相同，矩阵 $A$ 的列向量基是 $A,(A|B)$ 的极大线性无关组，于是列向量 $B$ 是 $A$ 的列向量基的线性表示，故存在解 Extra定理 $r_c(A) = r_r(A)$ 的另一种，不需要化为阶梯型的证明方法 _proof_ 基本思路：设 $\\mathrm{dim}\\; V_r(A) = r, \\mathrm{dim}\\; V_c(A) = s$，如果我们能证明 $s \\le r$，再考虑矩阵 $A$ 的转置 $^t A$，就可以得到 $r = s$ 具体地，选取 $A$ 的 $r$ 个基行（不妨设为前 $r$ 行），构成一个新的矩阵 $\\tilde{A}$，再选取它的 $t$ 个基列（类似的设为前 $t$ 列），有 $t \\le r$（因为 $V_c(\\tilde{A}) \\subset \\mathbb{R}^r$） 接下来就是要证明 $s \\le t$，即 $A$ 的列秩不大于 $\\tilde{A}$ 的列秩，即证明对于 $A$ 的任意一列，都可以由前 $t$ 列线性表出。假设 $A_{(i)} = \\mu_1A_{(1)} + \\cdots + \\mu_rA_{(r)}$，而对于前 $r$ 行，存在系数满足，$\\tilde{A}^{(k)} = \\lambda_1 \\tilde{A}^{(1)} + \\cdots + \\lambda_t \\tilde{A}^{(t)}$。于是 $$a_{ik} = \\sum _ {l = 1} ^ {r} \\mu_l a_{lk} = \\sum _{l = 1} ^{r} \\mu_l \\sum _ {p=1} ^ {t} \\lambda_p a_{lp} = \\sum _ {p=1} ^ {t} \\lambda_p \\sum _{l = 1} ^{r} \\mu_l a_{lp} = \\sum _ {p=1} ^ {t} \\lambda_p a_{ip}$$就证明了结论 Section 3 线性映射. 矩阵的运算矩阵与映射考虑两个高分别为 $n,m$ 的列向量空间，设 $A = (a_{ij})$ 是一个 $m \\times n$ 的矩阵，定义一个映射 $\\varphi _ {A} : \\mathbb{R}^n \\rightarrow \\mathbb{R}^m$，对于一个高度为 $n$ 的列向量 $X = [x_1, x_2, \\cdots, x_n] \\in \\mathbb{R}^n$，即有 $$Y = \\varphi_A(X) = x_1 A^{(1)} + x_2 A^{(2)} + \\cdots + x_n A^{(n)}$$也可以写作 $\\begin{eqnarray} y_i = \\sum _ {j=1} ^{n} a_{ij} x_{j},\\quad i=1,2,\\cdots,m \\end{eqnarray}$ 容易验证，映射 $\\varphi_A$ 满足性质： $\\varphi_A(X’ + X’’) = \\varphi_A(X’) + \\varphi_A(X’’), \\quad \\forall \\; X’,X’’ \\in \\mathbb{R}^n$（可加性） $\\varphi_A(\\lambda X) = \\lambda \\varphi_A(X), \\quad \\; \\forall X \\in \\mathbb{R}^n, \\lambda \\in \\mathbb{R}$（齐次性） 可以证明，满足上述性质的任意映射 $\\varphi$ 等价于 $\\varphi_A$（利用性质，得到 $\\begin{eqnarray} \\varphi(X) = \\sum _{j=1} ^{n} x_j \\varphi(E^{(j)}) \\end{eqnarray}$，映射 $\\varphi$ 的取值由它在列向量基 $E^{(j)}$ 的取值完全决定） 有了之前的铺垫，我们可以引入定义：满足上述性质的映射 $\\varphi = \\varphi_A : \\mathbb{R}^n \\rightarrow \\mathbb{R}^m$ 叫作从 $\\mathbb{R}^n$ 到 $\\mathbb{R}^m$ 的 线性映射 （不同向量空间之间的映射）。特别地，如果 $m=n$ 时叫作 线性变换 （向量空间到自己的映射），矩阵 $A$ 叫作 线性映射 $\\varphi_A$ 的矩阵。特别地，当 $m=1$ 时，映射 $\\varphi: \\mathbb{R}^n \\rightarrow \\mathbb{R}$ 称作 $n$ 变元的线性函数 根据之前的结论，我们可以得到重要 定理：从 $\\mathbb{R}^n$ 到 $\\mathbb{R}^m$ 的线性映射与 $m \\times n$ 阶的矩阵之间存在着一一对应 利用映射 $\\varphi_A$ 的性质，以及矩阵的运算法则，得到重要 推论：$\\alpha \\varphi_A + \\beta \\varphi_B = \\varphi _{\\alpha A + \\beta B}$ 以下是一个常用的事实：线性函数的线性组合也是一个线性函数 矩阵的乘积类比一般的映射复合，我们可以考虑两个线性映射的合成。考虑 $\\varphi_A：\\mathbb{R}^n \\rightarrow \\mathbb{R}^s,\\;\\varphi_B:\\mathbb{R}^s \\rightarrow \\mathbb{R}^m,\\quad\\varphi_C = \\varphi_A \\circ \\varphi_B$，利用 $\\varphi_A,\\varphi_B$ 是线性映射这一性质，容易得到 $\\varphi_C$ 也是一个线性映射。考察线性映射的显式表达，可以得到 $$c{ij} = \\sum _ {k=1} ^{s} a_{ik} b_{kj}=A{(i)}B^{(j)}$$于是我们得到 矩阵乘法 的定义，上式即为 $C = A \\times B$ 定理：有矩阵 $A$ 和矩阵 $B$ 确定的两个线性变换的乘积 $\\varphi_A \\circ \\varphi_B$ 是由矩阵 $C = AB$ 确定的线性变换，即有 $\\varphi_A \\circ \\varphi_B = \\varphi_{AB}$ _乘法 $AB$ 有意义，当且仅当 $A$ 的列数等于 $B$ 的行数。而方阵始终有意义_ 根据映射的结合律，得到 推论：矩阵乘法满足结合律 $A(BC)=(AB)C$ 根据定义，可以直接得到矩阵乘法的 分配率：$(A+B)C = AC+BC,\\; D(A+B) = DA+DB$ 矩阵的转置考虑两个分别为 $n \\times m,m\\times n$ 的矩阵 $A,B$，$\\forall\\; i=1,\\cdots,n, j=1,\\cdots,m,\\; A_{ij} = B_{ji}$，两个矩阵就 互为转置，显然满足性质 $^t(^tA) = A,\\;^t(A+B) = {}^tA + {}^tB,{}^t(\\lambda A) =\\lambda{}^tA,{}^t(A_1A_2\\cdots A_r)={}^tA_r \\cdots {}^tA_2 {}^tA_1$ 矩阵乘积的秩 定理：不等式 $\\mathrm{rank}\\;AB \\le \\min \\{\\mathrm{rank}\\;A,\\mathrm{rank}\\;B\\}$ 成立（考虑到 $C_{(i)} = A_{(i)}B$，我们选取 $A$ 前 $r_1$ 个向量作为基向量，$B$ 的秩不会发生改变；到 $C$ 的所有行向量能由前 $r_1$ 个向量线性表出，即 $\\mathrm{rank}\\;C \\le \\mathrm{rank}\\;A$，类似可以得到 $B$） 方阵全体 $n$ 阶实方阵的集合记作 $M_n(\\mathbb{R})$，构成一个 （结合）环 对于任意方阵 $A$ ，显然有 $\\mathrm{diag}_n(\\lambda)A = \\lambda A = A \\mathrm{diag}_n(\\lambda)$。同时有 定理：在 $M_n$ 中，与任意矩阵可交换的矩阵是纯量矩阵（考虑一个可交换的矩阵，在其两边分别乘上 $E_{ij}$，观察矩阵的形式即可） 对于方阵 $A$，存在 $A’,A’’$ 满足 $AA’= E = A’’A \\Longrightarrow A’’=A’’E=A’’(AA’)=(A’’A)A’=EA’=A’$这样如果存在 $AA’=E=A’A$，那么 $A’$ 一定唯一，称之为 $A$ 的 逆矩阵，记作 $A^{-1}$，称矩阵 $A$ 是可逆的 定义：矩阵 $A \\in M_n(\\mathbb{R})$ 叫做 非退化的，当且仅当行（列）向量组线性无关，即 $\\mathrm{rank}\\;A = n$。否则 $A$ 是 退化的 非常重要的定理：矩阵 $A \\in M_n(\\mathbb{R})$ 是 可逆的，当且仅当它是非退化的 一方面，如果存在 $AB=E$，$n = \\mathrm{rank}\\;E = \\mathrm{rank}\\;AB \\le \\min\\{\\mathrm{rank}\\;A,\\mathrm{rank}\\;B\\} \\le n$ 另一方面，如果 $\\mathrm{rank}\\; A =n$，那么 $\\langle A^{(1)}, \\cdots, A^{(n)} \\rangle = \\mathbb{R}^n$，于是 $\\exist A’ \\in M_n(\\mathbb{R}),\\;\\forall \\; j=1,\\cdots,n, \\quad E^{(j)} = AA’^{(j)}$，即 $E = AA’$；显然 ${}^tA$ 也是非退化的，也即存在 $B$ 满足 $E = {}^tAB$ ，可得$E = {}^tE = {}^t({}^t AB) = {}^tB{}^t({}^tA) = {}^tBA$，故存在 $A’’={}^tB$ 满足 $E = A’’A$ 推论1：设 $B,C$ 分别是 $m,n$ 阶非退化方阵，而 $A$ 是任意的 $m \\times n$ 矩阵，则 $\\mathrm{rank}\\; BAC = \\mathrm{rank}\\; A$（根据之前的定理，有 $\\mathrm{rank}\\; BAC \\le \\mathrm{rank}\\; BA = \\mathrm{rank}\\; BA(CC^{-1}) = \\mathrm{rank}\\; (BAC)C^{-1} \\le \\mathrm{rank}BAC$，即 $\\mathrm{rank}\\;BA = \\mathrm{rank}\\;A$） 推论2：如果 $A,B \\in M_n(\\mathbb{R}), \\;AB=E \\; \\mathtt{or} \\; BA=E$，那么 $B=A^{-1}$（$AB=E \\Rightarrow \\mathrm{rank}\\;A = n$，即 $A$ 是非退化的） 推论3：如果 $A,B,\\cdots,C \\in M_n(\\mathbb{R})$ 是非退化的方阵，其乘积也是非退化的，同时 $(AB\\cdots C)^{-1} = C^{-1} \\cdots B^{-1} A^{-1}$ 矩阵的等价类引入三类 初等矩阵，分别对应三类初等变换： 令 $E_{st}$ 表示只有第 $s$ 行第 $t$ 列为 $1$，其他位置都为 $0$ 的矩阵 对于 I 型初等变换，$F_{st} = E - E_{ss} - E_{tt} + E_{st} + E_{ts}$ 对于 II 型初等变换，$F_{st}(\\lambda) = E + \\lambda E_{st}$ 和特殊的 III 型初等变换，第 $s$ 乘以了一个常数，$F_s(\\lambda) = E + (\\lambda - 1) E_{ss}$ 由初等变换的可逆性，能得到 初等矩阵的可逆性： $$(F{st})^{-1} = F{st},\\quad F{st}(\\lambda)^{-1} = F{st}(\\lambda),\\quad F{s}(\\lambda)^{-1}= F{s}(\\lambda^{-1})$$（II 与 III 型对应的初等矩阵，其逆矩阵有不同的表现形式，故不宜统一形式） 考虑一个 $m \\times n$ 的矩阵，可以通过 行与列的 I,II 初等变换 得到左上角为 $r \\times r$ 非退化对角子矩阵的矩阵，这里有 $r = \\mathrm{rank}\\; A$。再通过 III 型初等变换，得到矩阵 $P_k\\cdots P_1AQ_1\\cdots Q_l = \\begin{pmatrix} E_r &amp; 0 \\\\ 0 &amp; 0\\end{pmatrix}$ （其中 $P_i(Q_i)$ 是 $m(n)$ 阶初等矩阵） 于是就能引入 矩阵的等价性，大小相同的 $A,B$ 等价当且仅当能找到非退化的 $m,n$ 阶矩阵 $B = PAQ$。容易验证其满足条件，我们引入形如 $\\begin{pmatrix} E_r &amp; 0 \\\\ 0 &amp; 0\\end{pmatrix}$ 的矩阵作为等价类的代表元 得到重要 定理：$n \\times m$ 的矩阵集合被划分为 $\\min\\{n,m\\} + 1$ 个等价类，所有秩相同的矩阵属于同一个等价类，以及 推论：所有非退化矩阵能写成初等矩阵的乘积 逆矩阵的计算利用初等矩阵的理论，我们可以很方便地进行逆矩阵的计算。对于一个非退化方阵 $A$，写成扩展矩阵 $(A|E)$，经过行初等变换（即乘上初等矩阵），变换为 $(E|A’)$，$A’$ 即为 $A$ 的逆。称之为 P约化，一般地，变成其代表元的过程称之为 PQ约化 解空间考虑一个 $n$ 元含有 $m$ 个方程的线性齐次方程组，$AX = 0$ 的全部解。显然，解的线性组合也是解，故齐次线性方程组的 解空间 是个线性包（也称之为 $A$ 的 核）：$V_A = \\langle X \\in \\mathbb{R}^n | AX = 0 \\rangle \\subset \\mathbb{R}^n$ 定理：等式 $r=\\mathrm{rank}\\;A,\\; s= \\mathrm{dim}\\; V_A,\\; r + s = n$ 成立，考虑其证明： 假设 $V_A$ 的基 $X^{(1)},\\cdots,X^{(s)}$，选择其他的基 $X^{(s+1)},\\cdots,X^{(n)}$ 以扩充成 $\\mathbb{R}^n$。取 $X \\in \\mathbb{R}^n$ 是这些基的线性组合 根据前提，$AX$ 可以表示为 $AX^{(s+1)}, \\cdots, AX^{(n)}$ 的线性组合，而 $V_c(A) = \\langle AX | X \\in \\mathbb{R}^n \\rangle \\subset \\mathbb{R}^m$ 所以有 $r = \\mathrm{dim}\\; V_c(A) \\le n - s$，而 $r = n - s$ 仅当 $AX^{(s+1)}, \\cdots, AX^{(n)}$ 线性无关 线性无关的证明：$\\begin{eqnarray} 0 = \\sum _ {k \\ge s + 1} \\beta _ k A X ^ {(k)} = A(\\sum _ {k \\ge s + 1} \\beta _ k X ^ {(k)}) \\Longrightarrow \\sum _ {k \\ge s + 1} \\beta _ k X ^ {(k)} \\in V _ A \\end{eqnarray}$，而根据 $X^{(k)}$ 的选择，得到所有的 $\\beta_k = 0$ 将任意一组解 $X$ 的基，定义为 基础解系。而 规范基础解系 定义为：$$X ^ {(1)} = \\left[ x_1^{(1)},x_2^{(1)},\\cdots,x_r^{(1)},1,0,\\cdots,0\\right] \\\\X ^ {(2)} = \\left[ x_1^{(2)},x_2^{(2)},\\cdots,x_r^{(2)},1,0,\\cdots,0\\right] \\\\\\cdots \\cdots\\\\X ^ {(n-r)} = \\left[ x_1^{(n-r)},x_2^{(n-r)},\\cdots,x_r^{(n-r)},0,0,\\cdots,1\\right] \\\\$$ Extra马尔科夫矩阵 应用于概率论，可以看作是概率的转移。定义矩阵 $$P = (p_{ij}),\\quad p_{ij} \\ge 0, \\quad \\sum _ {j=1} ^ {n} p _{ij} = 1, \\quad i = 1, 2, \\cdots n$$ 常常作用于概率列向量 $$X = \\left[ x_1, \\cdots, x_n \\right], \\quad x_i \\ge 0, \\quad \\sum _ {i=1} ^ n x _ i = 1$$$ 矩阵 $P \\in M_n(\\mathbb{R})$ 是马尔科夫的，当前仅当对于任意概率向量 $X$，$PX$ 是概率向量 如果 $P,Q \\in M_n(\\mathbb{R})$ 是马尔科夫的，那么 $PQ$ 也是马尔科夫矩阵 命题：对于任意两个 $m \\times n​$ 的矩阵 $A,B​$ ， $\\mathrm{rank}(A+B) \\le \\mathrm{rank}\\;A + \\mathrm{rank}\\; B​$ _proof_ 注意到 $A,B$ 的基向量可以线性表出 $A+B$ 即可 命题 Sylvester不等式：对于任意的 $m \\times s, s \\times n$ 的矩阵 $A,B$，证明：$\\mathrm{rank}\\; A + \\mathrm{rank}\\; B - s \\le \\mathrm{rank} \\;AB$ _proof_ 注意到 $\\mathrm{Im}\\; B \\subset \\mathbb{R}^s$，即有 $\\mathrm{ker}\\; AB \\subset \\mathrm{ker}\\; A \\subset \\mathrm{ker}\\; A + \\mathrm{ker}\\;B$ $m - \\mathrm{rank}\\; AB \\le m - \\mathrm{rank}\\; A + s - \\mathrm{rank}\\;B$ 关于矩阵秩的不等式 证明：若矩阵 $A = (a_{ij})$ 是非退化的对称矩阵，那么 $A^{-1}$ 也是对称矩阵 _proof_$$AA^{-1} = E \\Rightarrow {}^tA^{-1}{}^tA = E \\Rightarrow {}^tA^{-1}A = E \\Longrightarrow A^{-1} = {}^tA^{-1}$$ 分块矩阵 将一个矩阵用若干条横线和竖线分成许多个小矩阵，将每个小矩阵称为这个矩阵的子块，以子块为元素的形式上的矩阵 加法、数乘、转置，稍微yy一下 考虑乘法。显然要求分块矩阵 $A$ 的列分割方式等于分块矩阵 $B$ 的行分割方式，直接按照之前的乘法方式，每个元素也是矩阵乘法，容易发现其等价性 常常用于减少矩阵的阶数，例如：（这里 $A,B,E,0 \\in M_n(\\mathbb{R}$)$$\\begin{pmatrix} E &amp; A \\\\ 0 &amp; E \\end{pmatrix} \\begin{pmatrix} A &amp; 0 \\\\ -E &amp;B \\end{pmatrix} = \\begin{pmatrix} 0 &amp; AB \\\\ -E &amp; B \\end{pmatrix}$$对于一些特殊的分块矩阵，有一些性质 Baidu or Wiki _矩阵乘法的另一种理解_ 考虑两个 $m \\times s,\\; s \\times n$ 的矩阵 $A,B$ 的乘法 $C = A \\times B$ 根据定义，我们得到的矩阵乘法：$C_{ij} = A_{(i)} \\cdot B^{(j)}$（其中 $\\cdot$ 为向量的数量积） 如果我们提取 $B$ 的行向量而不是列向量，可以得到另一种理解$$\\begin{pmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1s} \\\\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2s} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{ns} \\end{pmatrix} \\begin{pmatrix} B_{(1)} \\\\ B_{(2)} \\\\ \\vdots \\\\ B_{(s)} \\end{pmatrix} = \\begin{pmatrix} a_{11}B_{(1)} + a_{12}B_{(2)} + \\cdots + a_{1s}B_{(s)} \\\\ a_{21}B_{(1)} + a_{22}B_{(2)} + \\cdots + a_{2s}B_{(s)} \\\\ \\cdots\\cdots\\quad\\quad\\quad\\quad\\cdots\\cdots \\\\ a_{n1}B_{(1)} + a_{n2}B_{(2)} + \\cdots + a_{ns}B_{(s)} \\\\ \\end{pmatrix}$$$A$ 仍然是一个用于线性映射的矩阵，只不过此处的 $B$ 向量（矩阵）的每一个元素都是一个向量 _回归到了矩阵的本质_ _Chapter 3_ 行列式Section 1 行列式：构造和基本性质几何背景从行列式的几何意义入手，我们可以得到一些直观的理解。考虑一个 $n$ 阶方阵 $A = (a_{ij})$，对应一个 平行六面体，是形如$$x_1A^{(1)} + \\cdots + x_nA^{(n)},\\quad 0 \\le x_i \\le 1$$的点的集合。低维的情形有 线段，平行四边形 $n$ 维平行六面体的体积归纳定义为 $n-1$ 底面的体积与点 $A^{(n)}$ 到底面所在超平面的垂线段长度的乘积。注意此处的体积为 有向体积 行列式即为 $\\det A = v(A)$，$A$ 是单位立方体 $E$ 在线性映射 $\\varphi_A$ 下的像。故 $\\det A$ 可以看作 有向体积的变换系数。直接能得到大量的行列式性质 ####组合 - 解析方法 为了得到更多的技巧，我们需要采用 _分析_ 的方法，而不是几何直观。直接给出行列式的 完全展开式，以研究其性质$$|A| = \\det A = \\sum _ {\\sigma \\in S_n} \\epsilon_\\sigma a_{1 \\sigma(1)} a_{2 \\sigma(2)} \\cdots a_{n \\sigma(n)}$$ 行列式的基本性质引入两个基本概念。一个函数 $\\mathcal{D}: \\left[ A_{(1)},\\cdots,A_{(n)} \\right] \\mapsto \\mathcal{D} \\left(A_{(1)},\\cdots,A_{(n)}\\right)$ 叫做 多重线性的，如果它的每一个分量 $A_{(i)}$ 都是线性的，即$$\\mathcal{D} (A_{(1)}, \\cdots,\\alpha A’_{(i)} + \\beta A’’_{(i)}, \\cdots, A_{(n)}) = \\alpha \\mathcal{D}(A_{(1)},\\cdots,A’_{(i)},\\cdots,A_{(n)}) + \\beta \\mathcal{D} (A_{(1)}, \\cdots, A’’_{(i)}, \\cdots, A_{(n)})$$_注 1：_ 由多重线性性可得 i) 含有零向量时，$\\mathcal{D}=0$ ii) 对于固定的 $A_{(1)},\\cdots,A_{(i-1)},A_{(i+1)},\\cdots,A_{(n)}$以及任意的 $i$，$A_{(i)} = X = \\{x_1,\\cdots,x_n\\}$，一定有$$\\mathcal{D}(A_{(1)},\\cdots,A_{(n)}) = \\alpha_1x_1 + \\alpha_2x_2 + \\cdots + \\alpha_nx_n$$其中 $\\alpha_1,\\cdots,\\alpha_n$ 是与 $A_{(i)}$ 无关的纯量。逆命题显然同样成立 同样还有之前提过的 斜对称性，当且仅当$$\\forall\\; i \\in \\{1,2,\\cdots,n-2,n-1\\},\\quad \\mathcal{D}(A_{(1)},\\cdots,A_{(i)},A_{(i+1)},\\cdots,A_{(n)}) = - \\mathcal{D}(A_{(1)},\\cdots,A_{(i+1)},A_{(i)},\\cdots,A_{(n)})$$_注 2：_ 可以得到，斜对称性等价于一下形式$$\\forall\\; i \\in \\{1,2,\\cdots,n-2,n-1\\},\\quad \\mathcal{D}(A_{(1)},\\cdots,A_{(i-1)},X,X,A_{(i+2)},\\cdots,A_{(n)})$$ 对于行列式，行和列的地位是等价的，有 定理 1：对于任意方阵，有 $\\det {}^tA = \\det A$（事实上，这是显而易见的，考虑同一项乘积，两个置换必定有 $\\pi\\sigma = e$，有 $\\epsilon_\\pi = \\epsilon_\\sigma$） _注 3：_ 此论断表明，行列式的行（列）满足的性质，那么列（行）也满足 定理 2：以下三个性质成立。 _D1._ $\\det A$ 是矩阵 $A$ 行的斜对称函数 _D2._ $\\det A$ 是矩阵 $A$ 行的多重线性函数 _D3._ $\\det E = 1$（显然） 对于 _D1._，考虑同一项乘积，需要增加一次对换，系数全部取反；对于 _D2._，我们只需要提出与 $a_{kj}$ 无关的系数，就能得到 $A_{(k)}$ 的线性表达形式，满足 _注 1_ 中的形式 以上三个性质称之为 行列式的性质，但是我们可以对于具有性质 _D1,D2_ 的任意函数 $\\mathcal{D}:M_n(\\mathbb{R}) \\rightarrow \\mathbb{R}$ 证明诸多性质 _D4._ 显然有 $\\det \\lambda A = \\lambda^n \\det A$ _D5._ 根据 _注 1_，行列式满足 _D1._：有一行为零的行列式等于 $0$ _D6._ 根据 _D1_，以及之前关于斜对称函数的推论，得到：有两行相同的方阵 $A$ 的行列式为 $0$（交换后变号同时相等） _D7._ 对行列式的行施行 II 型初等变换后，其值不变，证明如下： $$\\begin{split}\\mathcal{D}(A’) &amp;= \\mathcal{D}(A_{(1)},\\cdots,A_{(s)}+\\lambda A_{(t)},\\cdots,A_{(n)}) \\\\&amp;= \\mathcal{D}(\\cdots,A_{(s)},\\cdots) + \\lambda \\mathcal{D}(\\cdots,A_{(t)},\\cdots, A_{(t)},\\cdots) \\\\&amp;= \\mathcal{D}(\\cdots,A_{(s)},\\cdots) \\\\&amp;= \\mathcal{D}(A)\\end{split}$$ _注 4:_ 注意到这些性质只利用到 _D1,D2_，所以满足这两个性质函数能够满足以上几个性质 命题 1：设 $A$ 是一个方阵，那么有$$\\mathcal{D}(\\bar A) = \\mathcal{D}(E) \\, \\bar a_{11} \\bar a_{22} \\cdots \\bar a_{nn}$$直接利用 _D1_ 以及 _D7_，不断化为对角矩阵即可。对于 $\\mathcal{D} = \\det$，由于 $\\det E = 1$，所以我们就得到了计算行列式的简便做法，注意一次 I 型初等变换会变号 引入定义。将矩阵 $A = (a_{ij})$ 去掉第 $i$ 行和第 $j$ 列得到的矩阵的行列式记作 $M_{ij}$，称为矩阵 $A$ 的对应于元素 $a_{ij}$ 的 子式。而数值 $A_{ij} = (-1)^{i+j} M_{ij}$ 叫做 代数余子式 命题 2：若 $A$ 的形式如下，那么有 $\\det A = a_{11}M_{11} = a_{11}A_{11}$$$A = \\begin{pmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{12} \\\\ 0 &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; a_{n2} &amp; \\cdots &amp; a_{nn}\\end{pmatrix}$$利用行列无关的性质，翻转后即可证明 定理3：对于任意满足之前所述性质的函数 $\\mathcal{D}$，均有 $\\mathcal{D}(A) = \\mathcal{D}(E) \\cdot \\det A$（利用 命题1 可直接得出） 可见 行列式的性质，_D1,D2,D3_ 唯一地刻画了这个函数。而 $\\mathcal{D}$ 只需要 _D1,D2_ 这两个性质 Section 2 行列式的进一步性质行列式按一行或一列的元素展开一种计算行列式的常用方法：基于逐次降低行列式的阶数，我们有 定理 1：设 $A = (a_{ij}) \\in M_n(\\mathbb{R})$，下述公式成立$$\\det A = \\sum _ {i=1} ^ {n} (-1) ^ {i+j} a _{ij} M _{ij} = \\sum _{i=1} ^{n} a _{ij} A _{ij}$$也就是说矩阵 $A$ 的行列式等于某行（或某列）的一切元素与它们的代数余子式的乘积之和$$\\begin{split}&amp; \\det A \\\\=&amp; \\sum _{i=1} ^{n}\\begin{vmatrix}a_{11} &amp; \\cdots &amp; 0 &amp; \\cdots &amp; a_{1n} \\\\\\cdots &amp; \\cdots &amp; 0 &amp; \\cdots &amp; \\cdots \\\\a_{i1} &amp; \\cdots &amp; a_{ij} &amp; \\cdots &amp; a_{in} \\\\\\cdots &amp; \\cdots &amp; 0 &amp; \\cdots &amp; \\cdots \\\\a_{n1} &amp; \\cdots &amp; 0 &amp; \\cdots &amp; a_{nn}\\end{vmatrix} \\\\=&amp; \\sum _{i=1} ^{n} (-1)^{i+j}\\begin{vmatrix}a_{ij} &amp; a_{i1} &amp; \\cdots &amp; a_{i,j-1} &amp; a_{i,j+1} &amp; \\cdots &amp; a_{i,n} \\\\0 &amp; a_{11} &amp; \\cdots &amp; a_{1,j-1} &amp; a_{1,j+1} &amp; \\cdots &amp; a_{1,n} \\\\0 &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\0 &amp; a_{i1} &amp; \\cdots &amp; a_{i-1,j-1} &amp; a_{i-1,j+1} &amp; \\cdots &amp; a_{i-1,n} \\\\0 &amp; a_{i1} &amp; \\cdots &amp; a_{i+1,j-1} &amp; a_{i+1,j+1} &amp; \\cdots &amp; a_{i+1,n} \\\\0 &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\0 &amp; a_{n1} &amp; \\cdots &amp; a_{n,j-1} &amp; a_{n,j+1} &amp; \\cdots &amp; a_{nn}\\end{vmatrix} \\\\= &amp; \\sum _{i=1} ^{n} (-1)^{i+j} a_{ij} M_{ij}\\end{split}$$ 引入 范德蒙德行列式， 有$$\\Delta_n =\\begin{vmatrix}1 &amp; 1 &amp; \\cdots &amp; 1 \\\\x_1 &amp; x_2 &amp; \\cdots &amp;x_n \\\\x_1^2 &amp; x_2^2 &amp; \\cdots &amp; x_n^2 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\x_1^{n-1} &amp; x_2^{n-1} &amp; \\cdots &amp; x_n^{n-1}\\end{vmatrix}= \\Delta(x_1,x_2,\\cdots,x_n)= \\prod _ {1 \\le i &lt; j \\le n}(x_j-x_i)$$_proof_ 考虑数学归纳法，先进行初等变换，消去第 1列的大部分元素$$\\Delta_n =\\begin{vmatrix}1 &amp; 1 &amp; \\cdots &amp; 1 \\\\0 &amp; x_2 - x_1 &amp; \\cdots &amp; x_n-x_1 \\\\0 &amp; x_2^2 - x_2x_1 &amp; \\cdots &amp; x_n^2-x_nx_1 \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\0 &amp; x_2^{n-1}-x_2^{n-2}x_1 &amp; \\cdots &amp; x_n^{n-1} - x_n^{n-2}x_1\\end{vmatrix}$$这样就可以利用代数余子式展开，再利用多重线性性$$\\Delta_n = \\prod _{i=2} ^{n} (x_n-x_1) \\cdot \\Delta(x_2,x_3,\\cdots,x_n) = \\prod _{1 \\le i &lt; j \\le n} (x_j-x_i)$$ 引入 斜对称的 的方阵 满足 $a_{ij} + a_{ji} = 0$，显然有 $a _{ii} = 0$，其行列式$$\\det A = \\det {}^tA = \\det (-A) = (-1)^n \\det A$$对于任意奇数阶的斜对称矩阵，均有行列式为 $0$ 特殊矩阵的行列式定理 2：对于 $n+m$ 阶行列式 $D$ 在前 $n$ 列和后 $m$ 行的交叉处为 $0$，则有公式：$$\\det \\begin{pmatrix} A &amp; C \\\\ 0 &amp; B \\end{pmatrix} = \\det A \\cdot \\det B$$_proof_ 考虑固定 $A,C$，令 $D = \\mathcal{D}(B)$。显然 $\\mathcal{D}$ 具有性质 _D1. D2._，于是有 $\\mathcal{D}(B) = \\mathcal{D}(E) \\det B$ 考察 $\\begin{pmatrix} A &amp; C \\\\ 0 &amp; E \\end{pmatrix}$，注意到后 $m$ 行都只有一个 $1$，于是我们可以依次展开第 $n+m,n+m-1,\\cdots,n+1$ 行，容易得到 $\\mathcal{D}(E) = \\det A$。 就证明了结论 另外，行列式 $\\det \\begin{pmatrix} C &amp; A \\\\ B &amp; 0 \\end{pmatrix} = (-1)^{nm} \\det A \\cdot \\det B$ 的证明也可以用类似方法 行列式在矩阵乘法中非常重要的一个论断： 定理 3：设 $A,B$ 是 $n$ 阶方阵，那么有$$\\det AB = \\det A \\cdot \\det B$$_proof_ 类似于之前的证明方法，我们构造函数 $\\mathcal{D}_B(A) = \\det AB$，需要证明其满足性质 _D1,D2_ 对于 _D1_，注意到 $(AB)_{(s)},(AB)_{(t)}$ 交换了位置，行列式取负 对于 _D2_，显然 $\\det AB$ 是第 $i$ 行 $(AB)_{(i)}$ 的元素的线性函数 于是有 $\\mathcal{D}_B(A) = \\mathcal{D}_B(E) \\cdot \\det A = \\det EB \\det A = \\det A \\det B$ Extra_定理 3_ 的另类证法，构造辅助矩阵 $C = \\begin{pmatrix}E &amp; B \\\\ -A &amp; 0 \\end{pmatrix},\\; C’ = \\begin{pmatrix}E &amp; B \\\\ 0 &amp; AB \\end{pmatrix}$ 由于 $C’$ 是由 $C$ 进行 II 型初等变换得到的，故有 $\\det AB = \\det C’ = \\det C = \\det A \\det B$ 定义$$C_n(\\lambda_1,\\cdots,\\lambda_n) =\\begin{pmatrix}\\lambda_1 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; 0 \\\\-1 &amp; \\lambda_2 &amp; 1 &amp; \\cdots &amp; 0 &amp; 0 &amp; 0 \\\\\\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\0 &amp; 0 &amp; 0 &amp; \\cdots &amp; \\lambda_{n-2} &amp; 1 &amp; 0 \\\\0 &amp; 0 &amp; 0 &amp; \\cdots &amp; -1 &amp; \\lambda_{n-1} &amp; 1 \\\\0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; -1 &amp; \\lambda_{n}\\end{pmatrix}$$有 $\\det C_n = \\lambda_n C_{n-1} + \\det C _{n-2}$ 成立 只需要按照最后一列展开，$A_{n-1,n}$ 按照最后一行展开即可 证明$$\\det\\begin{pmatrix}A &amp; B \\\\B &amp; A\\end{pmatrix}= \\det (A+B)\\cdot \\det(A-B)$$形式上，利用初等变换$$\\det \\begin{pmatrix} A &amp; B \\\\ B &amp; A \\end{pmatrix} = \\det \\begin{pmatrix} A-B &amp; B \\\\ B-A &amp; A \\end{pmatrix}= \\det \\begin{pmatrix} A-B &amp; B \\\\ 0 &amp; A+B\\end{pmatrix}$$ Section 3 行列式的进一步性质非退化矩阵的判别准则考虑一个非退化方阵 $A$，满足 $AA^{-1} = A^{-1}A = E$，于是得到$$\\det A \\cdot \\det A^{-1} = 1$$引入 伴随矩阵，即矩阵的每个位置的代数余子式，再取转置$$A^{\\vee} =\\begin{pmatrix}A_{11} &amp; \\cdots &amp; A_{n1} \\\\\\vdots &amp; \\ddots &amp; \\vdots \\\\A_{1n} &amp; \\cdots &amp; A_{nn}\\end{pmatrix}$$我们有 定理 1：矩阵 $A \\in M_n(\\mathbb{R})$ 是非退化的，当且仅当 $\\det A \\not= 0$。若 $\\det A \\not= 0$，则有$$A^{-1} = (\\det A)^{-1} A^\\vee$$_proof_ 引入一个 引理：对于 $A \\in M_n(\\mathbb{R})$ 我们有关系式 $$ a_{i1}A_{j1} + a_{i2}A_{j2} + \\cdots + a_{in}A_{jn} = \\delta_{ij} \\det A,\\quad \\delta_{ij} = [i=j] $$ 对于 $i=j$ 的情况，就是行列式的展开式 对于 $i \\not= j$ 的情况，取 $A’$，是由 $A$ 中第 $i$ 行代替第 $j$ 行得到的矩阵。显然有 $\\det A’ = 0$，第 $j$ 行展开为代数余子式即可 取 $C = A A^\\vee$，有 $(c_{ij}) = (\\delta \\det A) = (\\det A) E$，即 $AA^\\vee = (\\det A)E$，于是如果有 $\\det A \\not=0$$$A (\\det A)^{-1} A^\\vee = E \\Longrightarrow A^{-1} = (\\det A)^{-1} A^\\vee$$ 克拉默（克莱姆）公式定理 2：如果一个 $n \\times n$ 的线性方程组的系数不为 $0$，那么有$$x_k = \\frac { \\begin{vmatrix} a_{11} &amp; \\cdots &amp; b_{1} &amp; \\cdots &amp; a_{1n} \\\\ \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ a_{n1} &amp; \\cdots &amp; b_{n} &amp; \\cdots &amp; a_{nn} \\end{vmatrix}}{ \\begin{vmatrix} a_{11} &amp; \\cdots &amp; a_{1k} &amp; \\cdots &amp; a_{1n} \\\\ \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots &amp; \\cdots \\\\ a_{n1} &amp; \\cdots &amp; a_{nk} &amp; \\cdots &amp; a_{nn} \\end{vmatrix}},\\quad k = 1,2,\\cdots,n$$_proof_ 利用伴随矩阵，可以得到$$X = A^{-1}B = \\frac 1 {\\det A} A^\\vee B$$从而$$x_k = \\frac 1 {\\det A} \\sum _{i=1} ^n A_{ik} b_{i}$$注意到分子就是行列式的第 $k$ 列展开式 需要注意一点，克拉默公式对系数系统的微小扰动是及其敏感的，并不适用于求近似解 加边子式法定义 $k$ 阶子式：一个 $m \\times n$ 的矩阵 $A$ 的任意 $k$ 行和 $k$ 列交叉处的元素组成的一个方阵的行列式。子式 $\\widetilde M$ 称之为 $M$ 的 加边，当且仅当 $M$ 是由 $\\widetilde{M}$ 去掉一端的行，以及一端的列得到的 有 定理（加边子式法）：对于一个矩阵 $A$，如果存在一个 $r$ 阶子式 $M \\not= 0$，且对于 $r$ 的任意加边，它们都为 $0$，则 $\\mathrm{rank}\\; A = r$（只需要展开 $\\widetilde M$，利用 $i$ 的任意性，证明任意一列都是前 $r$ 列的线性组合即可，得到 $\\mathrm{rank}\\; A \\le r$，但是 $M$ 中的列是线性无关，矩阵 $A$ 中更长的列肯定线性无关） 得到 推论：任意矩阵的秩等于它的非零子式的最大阶数 加边子式法常常用于求矩阵 $A$ 的行或列的极大线性无关组，然而用初等变换会使得信息丧失 Extra_由于某些原因被skip了，日后填_ Section 4 行列式的公理化构造（待理解）本节指出了 _通往行列式理论的若干途径_，通过最简单的三条公理得到许多优美的性质 第一公理化构造 将行列式看作满足下述三条性质的任意函数 $\\mathcal{D}: M_n(\\mathbb{R}) \\rightarrow \\mathbb{R}$ 关于矩阵的行是斜对称的 关于矩阵的行是线性相关的 $\\mathcal{D}(E) = 1$ 根据之前的证明，这个函数是由这三条性质唯一确定的。唯一需要关心的给出 $\\mathcal{D}({}^tA) = \\mathcal{D}(A)$ 的独立证明 第二公理化构造 类似于第一公理化构造，可以直接推到上述三条性质 完全归纳构造法 定义一阶矩阵 $(a_{11})$ 的行列式为 $a_{11}$，利用代数余子式的展开式作归纳 归纳法证明 _D1.D2.D3_ 成立 通过乘法性质的刻画 定义函数 $\\mathcal{D}$ 满足乘法、两种初等矩阵的值 证明三种初等矩阵的值与其行列式的值对应相等，利用乘法性质得到 $\\mathcal{D}(A) = \\det A$ ExtraToo Difficult… _Chapter 4_ 群. 环. 域Section 1 具有代数运算的集合二元运算定义映射 $\\tau : X \\times X \\rightarrow X$ 叫做 $X$ 上的 二元代数运算，记为 $\\tau(a,b)$，常常简记为 $a \\tau b$，特殊的记号 $_, \\circ, \\cdot, +$。称 $\\cdot$ 为 积（可省略），称 $+$ 为 和。在一个集合上可以定义许多不同的运算，选定一种后，记号 $(X,_)$ 称 $_$ 定义了 $X$ 上的一个 _*代数结构（代数系统）__ 注意到二元运算看起来是十分特殊的。一般地，我们还有 $n$ 元运算，属于 泛代数 的范畴 半群与幺半群定义集合 $X$ 上的二元运算 $_$ 是 结合的，有 $\\forall \\; a,b,c \\in X,\\quad (a_b)_c = a_(b*c)$ 如果是 交换的，则有 $a _ b = b _ a$，显然这两个性质是互相独立的 元素 $e \\in X$ 叫做关于二元运算 $_$ 的 单位元（中性元），当且仅当 $\\forall\\, x \\in X,\\; e _ x = x * e = x$ 称满足结合律的代数结构为 半群，称带有单位元的半群为 幺半群 一些常见的例子. 考虑 $\\Omega$ 是任意集合，$M(\\Omega)$ 是它变换的集合。三元组 $(M(\\Omega), \\circ, e_\\Omega)$ 是一个幺半群 考虑 $\\Omega$ 的幂集 $\\mathcal{P}(\\Omega)$，我们有两个可交换的幺半群 $(\\mathcal{P}(\\Omega),\\cup,\\varnothing),\\; (\\mathcal{P}(\\Omega),\\cap,\\Omega)$ 对于方阵，我们有交换幺半群 $(M_n(\\mathbb{R}),+,0)$，以及非交换幺半群 $(M_n(\\mathbb{R}),\\cdot,E)$ 定义 $n\\mathbb{Z} = \\{nm|m \\in \\mathbb{Z}\\}$，那么有交换幺半群 $(n\\mathbb{Z},+,0)$，当 $n &gt; 0$ 时 $(n\\mathbb{Z},\\cdot)$ 是一个半群 带有运算 $_$ 的半群 $S$ 的一个子集 $S’$ 是一个 子半群，若取 $x,y \\in S’, x _ y \\in S’$，也称 子集 $S’ \\subset S$ 关于运算 $*$ 封闭 类似可以定义 子幺半群，但是要求单位元一定在这个子幺半群内。也称之为 变换幺半群 广义结合律. 方幂一个显然的 定理 1：如果 $X$ 上的二元运算是结合的，那么 $S$ 中 $n$ 个元素相乘的结果与括号位置无关 定义元素的 $n$ 次方幂，$x ^n = x \\, x \\, \\cdots \\, x$，显然有 $x^mx^n = x^{n+m}, \\quad (x^m)^n=x^{nm}, \\quad m,n \\in \\mathbb{N}$，在 幺半群 中，定义 $x^0 = e$。在加法幺半群中，上述性质可以记为 $mx+nx = (m+n)x,\\quad n(mx) = nmx$ 一般来说，称 $(M,\\cdot,e)$ 为 乘法 幺半群，而称 $(M,+,0)$ 为 加法 幺半群（一般用于交换的幺半群） 可逆元素幺半群 $(M,\\cdot,e)$ 的一个元素 $a$ 称为 可逆的，若存在 $b \\in M,\\; ab = e = ba$，容易证明 $b$ 是唯一的。称 $a,b$ 互为 逆元，记为 $a^{-1}$ 一个显然的 结论：幺半群 $(M,\\cdot,e)$ 中全体可逆元素的集合对运算封闭，并且构成 $M$ 中的一个子幺半群 Extra证明：存在代数结构 $(X,_)$（只有封闭性），满足 $\\forall\\, x,y \\in X,\\; (x_y)_y=x,\\; y_(y_x)=x$。 求证 $_$ 是交换的 _“因为这是本书中最没用的习题之一. 但毕竟还是个练习！” 答案_ _proof_$$\\begin{split}(x _ y) _ y &amp;= x \\\\(x _ y) _ ((x _ y) _ y) &amp;= (x _ y) _ x \\\\y &amp;= (x _ y) _ x \\quad(\\mathrm{use}\\; y _ (y _ x) = x) \\\\x &amp;= (y _ x) _ y \\\\(x _ y) _ y &amp;= (y _ x) _ y \\\\((x _ y) _ y) _ y &amp;= ((y _ x) _ y) _ y \\\\x _ y &amp;= y _ x \\quad\\quad\\quad\\;(\\mathrm{use}\\; (x _ y) _ y = x) \\\\ \\ \\\\\\Large\\mathrm{Ver}&amp;\\Large\\mathrm{y\\ nice.}\\end{split}$$ 证明集合$$M_n^0(\\mathbb{R}) = \\left\\{ A = (a_{ij}) \\in M_n(\\mathbb{R}) \\; \\left| \\;\\sum _{i=1} ^{n} a_{ij} = 0, \\quad i=1,2,\\cdots,n\\right. \\right\\}$$在矩阵乘法运算下构成一个半群。它是一个幺半群吗？ _proof_ 显然满足结合律，于是只需要证明它对于矩阵乘法封闭。不妨令 $C = AB$ 考虑 $\\forall\\, i=1,2,\\cdots,n, \\;\\sum C_{(i)} = \\sum _{j=1}^n a_{ij} (\\sum B_{(j)}) = 0 $，即对乘法封闭 注意到它是列线性相关的，即有 $\\mathrm{rank}\\, A &lt; n, \\; \\forall A \\in M_n^0(\\mathbb{R})$，不存在单位元 $E$ 证明：在乘法幺半群 $M$ 中选出任意一个元素 $t$，并引入运算 $_$：$x_y = xty$，证明 $(M,*)$ 称为一个幺半群当且仅当所选的元素 $t$ 可逆，且它的单位元是 $t^{-1}$ _proof_ 显然 $(M,*)$ 也是一个半群，设其单位元为 $e$，而 $M$ 的单位元为 $e’$，根据定义，显然有$$xte = x = etx \\;\\Longrightarrow\\; te = e’ = et \\;\\Longrightarrow\\; e = t^{-1}$$ Section 2 群定义和例子考虑行列式不为 $0$ 的实系数 $n$ 阶方阵的集合 $GL_n(\\mathbb{R})$，连同乘法运算，显然它是一个幺半群。注意到对于任意 $A \\in GL_n(\\mathbb{R})$ 均存在逆元满足 $AA^{-1} = E = A^{-1}A$，我们称之为 $\\mathbb{R}$ 上的 $n$ 阶一般线性群 由此引入 定义：所有元素都可逆的幺半群叫做 群。特别的，对于代数结构 $S_n$ 称之为 $n$ 元置换的对称群。带有交换二元运算的群称之为 交换群，也常常叫做 阿贝尔群 类似的，我们可以定义 子群 的概念，当且仅当 $H \\subset G$ 且满足群的性质。类似地，定义 真子群，要求 $H \\not={e},H \\not= G$ 一些常见群的例子. 定义 $GL_n(\\mathbb{R})$ 中行列式为 $1$ 的矩阵构成的子集 $SL_n(\\mathbb{R})$，是一个子群，称为 $n$ 阶特殊线性群 考虑不同数域下的 $GL_n$ 有许许多多 有限 / 无限 的群 我们也可以令 $S(\\Omega)$ 是 $\\Omega$ 的全体双射，它的各类子群叫做 变换群。注意到将 $\\Omega$ 取作 $\\mathbb{R}^n$，包含可逆线性变换构成的集合，就和 $n$ 阶非退化矩阵一一对应 循环群设 $G$ 是一个乘法群，$a \\in G$，如果对于任意 $g \\in G$ 都可以写成 $g = a ^n$ 的形式，则称 $G = \\langle a \\rangle$ 是带有生成元 $a$ 的 循环群。而加法群则定义为 $\\langle a \\rangle = \\{na | a \\in \\mathbb{Z}\\}$，方便起见，我们定义符号 $(a^{-1})^{k} = a^{-1}$。 容易证明 定理 1：任取 $m,n \\in \\mathbb{Z}$，有$$a^ma^n = a^{m+n},\\quad (a^m)^n = a^{mn}$$ 一个简单的例子，整数加群 $(\\mathbb{Z}, + , 0)$ 是个循环群，它由元素 $1$ 或 $-1$ 生成 考虑任意一个群 $G$，和 $a \\in G$，有两种可能 $\\forall\\, n \\not= m,\\; a^m \\not= a^n$，称 $a$ 是 无限阶元 $\\exist\\, n &lt; m,\\; a^m = a^n \\Rightarrow a ^{m-n} = e$，令 $q$ 是使 $a^q=e$ 的最小整数，称 $a$ 是 $q$ 阶元 考虑一个显然的 定理 2：如果 $a$ 是个 $q$ 阶元，那么 $\\mathrm{Card}\\langle a \\rangle = q$，并且，$$\\langle a \\rangle = \\{e,a,a^2,\\cdots,a^{q-1}\\} \\\\a^k = e \\Leftrightarrow k=lq,\\quad l\\in \\mathbb{Z}$$（考虑 $k$ 的带余除法即可） 同构直接引入 定义：两个分别具有运算 $_$ 和 $\\circ$ 的群 $(G,_)$ 与群 $(G’,\\circ)$ 称之为 同构 的，存在一种映射 $f:G \\rightarrow G’$，使得 $\\forall\\, a,b \\in G, \\; f(a * b) = f(a) \\circ f(b)$ $f$ 是双射 用符号 $G \\simeq G’$ 表示两个群同构 推论 1：单位元对应到单位元（$e _ a = a _ e = a \\Rightarrow f(e) \\circ f(a) = f(a) \\circ f(e) = f(a) \\Rightarrow f(e) = e’$，其中性质二保证了 $f(g)$ 取遍 $G’$ 的所有元素） 推论 2：$f(a^{-1}) = f(a)^{-1}$ （利用等式 $f(a^{-1}) \\circ f(a) = e’ = f(a)^{-1} \\circ f(a)$ 即得证） 推论 3：逆映射 $f^{-1}:G’ \\rightarrow G$ 也是一个同构（显然，只需任取 $a,b \\in G$ 证明定义中的等式即可） 一个简单的例子：函数 $f:=\\ln$ 是 $(\\mathbb{R}_+,\\cdot)$ 到 $(\\mathbb{R},+)$ 的一个同构映射，逆映射即为 $f^{-1}: x \\mapsto e^x$ 一个不言而喻的 定理 3：任意两个同阶的循环群是同构的（特别的，任意两个无限循环群是同构的） 群论中的重要 定理 4（凯莱定理）：任意 $n$ 阶有 $G$ 限群都同构于对称群 $S_n$ 的某个子群 _proof_ 设 $n = |G|$。假设 $G = \\{e=g_1, g_2, \\cdots, g_n\\}$ 对于任意一个元素 $a \\in G$，定义映射 $L_a : g \\mapsto ag$。注意到 $L_a$ 是一个双射，存在逆映射，存在恒定映射，并且满足结合律。得到 $H = \\{L_e, l_{g_2}, \\cdots, l_{g_n}\\} \\subset G$ 在对应关系 $L : a \\mapsto L_a$ 下与 $G$ 同构 如果同构定义中 $G’ = G$ 得到群 $G$ 到自身的同构映射 $\\varphi:G \\rightarrow G$，称之为群的 自同构。恒等映射 $e_G : g \\mapsto g$ （记为 $1$）是自同构，自同构的逆映射也是自同构，容易验证自同构也满足结合律。事实上，群 $G$ 的全体自同构集合 $\\mathrm{Aut}(G)$ 构成 $S(G)$ 的一个子群（$G \\rightarrow G$ 的全体双射） 同态直接引入 同态 的定义，群 $(G,_)$ 到 $(G’,\\circ)$ 的一个映射 $f : G \\rightarrow G’$ 叫做 同态映射，若（相当于只满足同构的第一个性质）$$\\forall\\, a,b \\in G,\\quad f(a_b) = f(a) \\circ f(b)$$定义集合$$\\ker f = \\{g \\in G | f(g) = e’ \\in G’\\}$$是同态 $f$ 的 核。自己到自己的同态映射称为 自同态 显然映射的象 $\\mathrm{Im}\\, f \\subset G’$ 是一个子群。$\\ker f$ 的平凡性表示 $f$ 是否是单射，如果有 $\\ker f = \\{e\\}$，那么 $f: G \\rightarrow \\mathrm{Im} f$ 是一个同构映射 由于$$f(a) = e’,f(b) = e’ \\Longrightarrow f(a*b) = f(a) \\circ f(b) = e’ \\circ e’ = e’ \\\\f(a^{-1}) = f(a) ^{-1} = (e’)^{-1} = e’$$所以核 $\\ker f$ 是 $G$ 的一个子群 术语. 例子在集合间的映射，我们有术语 满射，单射，双射。在群（或者其他代数系统）的 同态（态射） 时，有对应术语 满同态，单同态，同构 一些群同态的例子. 整数加群 $\\mathbb{Z}$ 到 $q$ 阶循环群 $\\langle g \\rangle$ 有一个满同态映射 $f : n \\mapsto g^n$，同时有 $\\ker f = \\{lq | l \\in \\mathbb{Z}\\}$ 从实数加群 $\\mathbb{R}$ 到平面绕不动点 $O$ 的旋转群 $T$ 是个满同态映射 一般线性群 $GL_m(\\mathbb{R})$ 到非零实数乘法群 $\\mathbb{R}^*$ 有态射 $f : A \\mapsto \\det A$，并且有 $\\ker f = SL_m(\\mathbb{R})$ $n$ 阶对称群 $S_n$ 到二阶循环群 $C_s = \\langle -1 \\rangle = \\{1, -1\\}$ 有映射 $\\epsilon : \\pi \\mapsto \\epsilon_\\pi$，核为 $\\ker \\epsilon = A_n$，称之为 交错群 无限群可以同构于自己的真子群。群 $(\\mathbb{Z},+)$ 到群 $(n\\mathbb{Z}, +)$ 恰好两种同构映射 $f : k \\mapsto nk$ 或 $g:k \\mapsto -nk$ 考察一个群 $G$ 的自同构群 $\\mathrm{Aut}(G)$，如果满足性质：存在 $2$ 阶自同构 $\\varphi\\,(\\varphi^2 =1)$，没有非平凡不动点$$a \\not= e \\Rightarrow \\varphi(a) \\not= a$$如果有 $\\varphi(a) a^{-1} = \\varphi(b) b^{-1}$，可得$$\\varphi(b)^{-1}\\varphi(a) = b^{-1} a,\\;\\varphi(b^{-1}a) = b^{-1}a,\\; b^{-1} a = e,\\;a = b$$也即对于任意 $g \\in G$，都可以写成 $\\varphi(a)a^{-1}$ 的形式，此时有$$\\varphi(g) = \\varphi^2(a) \\varphi(a)^{-1} = a\\varphi(a)^{-1} = (\\varphi(a)a^{-1})^{-1} = g^{-1}$$即 $\\varphi : g \\mapsto g^{-1}$，由于$$ab = \\varphi(a^{-1}) \\varphi(b^{-1}) = (a^{-1}b^{-1})^{-1}=((ba)^{-1})^{-1} = ba$$得到 $G$ 是阿贝尔群，并且 $G$ 是由 $e$ 和互不相同的元素对 $g_i,g_i^{-1} = \\varphi(g_i)$ 组成 我们可以改变群的运算，但在同构意义下不改变群的自身，考虑上一节的习题3。此时的群为 $(G,\\cdot)$，引入运算 $g * h = g t h$ （其中 $t$ 是 $G$ 中的一个给定元素） 考虑映射 $f : g \\mapsto g t^{-1}$ 建立了 $(G,\\cdot),(G,*)$ 之间的同构 一个一般性原则：对群 $G$ 的态射的研究反映出群 $G$ 自身的重要信息 Extra设 $S$ 是群 $G$ 的子集，若包含子群 $S$ 的所有群的交集与 $G$ 重合，则称 $G$ 是由 $S$ 生成的，记作 $G = \\langle S \\rangle$ 证明：当 $G = \\langle S \\rangle$ 时，任意元素 $g \\in G$ 形如 $g = t_1t_2\\cdots t_n,\\quad n=1,2,\\cdots$ 其中 $t_i \\in S$ 或者 $t_i^{-1} \\in S$（反证，得到 $G$ 中形如 $t_1t_2 \\cdots t_n$ 包含 $S$ 同时是一个群即可） 挖坑待填 Section 3 环与域环的一般定义与基本性质直接给出 定义： 设 $R$ 是一个非空集合，在 $R$ 上定义了两种（二元代数）运算 $+$ 和 $\\cdot$，并且满足条件 $(R,+)$ 是阿贝尔群，$(R,\\cdot)$ 是半群，加法与乘法运算以分配律相联系 $(a+b)c = ac+bc,\\; c(a+b) = ca+cb$，则称 $(R,+,\\cdot)$ 是一个 环 其中 $(R,+)$ 叫作 环的加法群，而 $$(R,\\cdot)$$ 叫作它的 乘法半群。如果 $(R,\\cdot)$ 是一个幺半群，则称 $(R,+,\\cdot)$ 是 有单位元的环，加法的单位元称为 零元。类似的，我们可以定义 环 $R$ 的子集 $L$ 叫作一个 子环，如果$$\\forall\\, x,y \\in L,\\quad x-y \\in L,xy \\in L$$类似地，可以定义由子集 $T \\subset R$ 生成的子环 $\\langle T \\rangle \\subset R$ 。如果 $\\forall\\, x, y, \\in L,\\; xy = yx$，则环 $R$ 是 交换的 一些环的例子. $M_n(\\mathbb{R})$ 是一个有单位元 $1 = E$ 的环，称之为 $\\mathbb{R}$ 上的全矩阵环 设 $X$ 是任意集合 $R$ 是任意环，$R^X = \\{X \\rightarrow R\\}$ 是所有映射 $f : X \\rightarrow R$ 组成的集合。定义两种二元运算 $$(f+g)(x) = f(x) \\oplus g(x) \\\\(fg)(x) = f(x) \\odot g(x)$$ 容易验证其满足环的所有条件。其中 $0_X : x \\mapsto 0, 1_X : x \\mapsto 1$ 是 $R^X$ 的零元和单位元。称之为 函数环 从环的定义中的三个条件导出环的其他更特殊的性质，可以从 $\\mathbb{Z}$ 的性质得到启示，例如有$$a + 0 = a \\Rightarrow a(a+0) = a^2 \\Rightarrow a^2 + a \\cdot 0 = a^2 \\Rightarrow a \\cdot 0 = 0\\;(0 \\cdot a = 0)$$如果存在 $0 = 1$，则任取 $a \\in R$，会得到 $a = a \\cdot 1 = a \\cdot 0 = 0$，即 $R$ 中仅有零元。得到在非平凡的环中，有 $1 \\not = 0$ 利用分配律，容易得到 $(-a)b = a(-b) = -(ab)$。可证牛顿二项式仅当 $R$ 是交换环时成立 同余式. 剩余类环定义两个整数 模 $m$ 同余，于是 $\\Z$ 划分为若干类（同一类的模 $m$ 同余），每个剩余类形如$$\\{r\\}_m = r + m \\Z = \\{r + mk | k \\in \\Z \\}$$实际应用中，我们常常用 $\\Z_m$ 中的代表元代替剩余类。同样，我们在 $\\Z$ 中导出运算，得到了 $\\{\\Z_m,\\oplus,\\odot\\}$ 是一个带有单位元 $1 + m\\Z$ 的 模 $m$ 的剩余类环 环的同态直接给出 定义，设 $(R,+,\\cdot)$ 和 $(R’,\\oplus,\\odot)$ 是两个环，映射 $f : R \\rightarrow R’$ 称为 同态，若 $f$ 保持环的两种运算，即$$f(a+b) = f(a) \\oplus f(b) \\\\f(ab) = f(a) \\odot f(b)$$有 $f(0) = 0’,f(na) = nf(a)\\,(n \\in \\Z)$。其中，集合$$\\ker f = \\{a \\in R | f(a) = 0’\\}$$称为同态 $f$ 的 核，显然 $\\ker f $ 是 $R$ 的一个子环 类似地，有 单同态，若 $\\ker f = 0$（反证即可）；满同态，若 $\\mathrm{Im} f = R’$；同构，$f$ 既单且满，记为 $R \\cong R’$ 环的类型. 域注意到，我们所熟知的数环 $\\Z, \\Q, \\R$ 中，具有性质：从 $ab = 0$ 中可以推得 $a=0$ 或者 $b=0$。但是一些其他的环却不具有这个性质","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"「切题记录」BZOJ","date":"2017-12-31T16:00:03.000Z","path":"2018/01/01/Solutions-BZOJ/","text":"一个利益至上的OJ. 坚决抵制 SDOI BZOJ3122-[SDOI2013]随机数生成器 给定参数 $a,b,X[1]$ ，序列 $X$ 由 $X[i+1] = (a \\times X[i] + b) \\mod p$ 得到。问第一次在序列 $X$ 中出现 $t$ 的位置， $p$ 是一个给定的质数。或者永远不会出现。 分类讨论，大小步算法。 先要特判一波。 $X[1] = t$ ， $a = 0$ 时直接输出。 $a = 1$ 时，就是一个裸的 $exgcd$ 。接下来就怒推一发公式。。。 显然可以暴力展开，得到： $$X[n] = aX[n-1] + b = a(aX[n-2] + b) + b = … = a ^ {n-1} X[1] + (a ^ 0 + a ^ 1 + … + a ^ {n-2}) b$$ 随便化简一下： $$a ^ {n-1} = \\frac {X[n] - \\frac {a ^ {n-1} -1} { a - 1} \\times b} {X[1]} $$ 跑个BSGS就好了。小心爆int。 BZOJ1927-[SDOI2010]星际竞速 给定一个DAG，要求用若干条不相交路径覆盖所有的点，给定所有边的代价，以及所有点作为路径的第一个点的代价。问最小的代价之和。 最小路径覆盖，费用流，拆点。 首先考虑 $S$ 向 $i$ 连上 $(1,ai)$ 的边，$i$ 向 $T$ 连 $(1,0)$ 。此时它可以选择 一个 后继节点，于是考虑增加一个点 $i+n$ ，需要 $S \\rightarrow n+i, (1,0)$ ，考虑删除这个点 $i$ ，对于 $i \\rightarrow j$ 连 $(1,w_{i,j})$ 。表示将 $j$ 作为第一个点的代价 可以是 $w_{i,j}$ 。以上是思考过程。 正确性？考虑到每个点的流量只有两种可能来源，逆推即可得到一种对应方案。同时每一种方案也对应一种可行的流。所以最小费用即为最小答案。 BZOJ1974-[SDOI2010]auction代码拍卖会 一个 $10$ 进制表示的正整数，如果从左到右，每一位的数字都不小于前一位的数字，则被称为上升数。 给出正整数 $n$ 和 $K$ ，求有多少个长度恰好为$n$ 的上升数是 $K$ 的倍数，答案对 $999911659$ 取模。 $n \\leq 10^{18}, K \\leq 500$ 动态规划。 如果纵向切割，显然很难搞。考虑横向切割，不难发现这个数可以拆分为不超过 $9$ 个，$1,11,111,1111,..$ 的和。然后，这些数模 $K$ 很显然是存在循环的。定义 $f[i][j][k]$ 表示前 $i$ 组中，选择了 $j$ 个数，模意义下为 $K$ 的方案数。 需要注意的是 $\\frac {10^{n-1} - 1} 9$ 要特殊处理，同时注意 $K$ 等于 $1$ 的情况 ZJOI BZOJ1414-[ZJOI2009]对称的正方形 给定一个 $n \\times m$ 的矩阵。问存在多少子矩阵，使得它上下对称且左右对称。$n,m \\leq 10^3$ HASH乱搞。 显然，对于每一个位置，我们可以二分求出一个极大子矩阵。判断就可以用二维HASH，注意方向，小心不要写成旋转对称QAQ。新技能get!二维哈希。 我们可以弄两个不同的大素数 $p,q$，$(i,j)$ 就要乘上 $p ^ i \\times q ^ j$ 。用unsigned int，然后自然溢出就好了。。 不放心的话，可以用unsigned long long。相当于双模数HASH？ BZOJ2111-[ZJOI2010]Perm 排列计数 计算 $1,2,..,n$ 的排列在大根堆中有多少种方案。 组合，动态规划。 首先求出每个位置的 $size$ ，定义 $f[i]$ 为以第 $i$ 个位置为根的方案数。如果它有两个儿子，那么 $f[i] = \\binom {size[i]-1} {size[lc]} \\times f[lc] \\times f[rc]$ 。 注意，这里的组合数的 $n,m$ 有可能超过 $MOD$ 。所以需要使用 Lucas定理。 SHOI BZOJ1018-[SHOI2008]堵塞的交通traffic 给定一个 $2*n$ 的网格图，要求支持加边，删边，求两点的连通。 线段树。 因为是线段上的操作，所以很显然可以用线段树来维护。 不难发现，所有的路径都像这样：向往另一端走，然后转回来，超过之后再转回来。所以就要维护前缀，后缀和两端的最短路，更新类似于floyd。 SCOI BZOJ1078-[SCOI2008]斜堆 给定一棵斜堆，要求还原插入序列。保证是一个置换。 斜堆的性质。 题解 似乎还要再想想。 BZOJ2333-[SCOI2011]棘手的操作 有 $n$ 个节点，每个点有一个权值，要求支持以下操作： U x y 加一条边，连接第 $x$个节点和第 $y$ 个节点 A1 x v 将第 $x$ 个节点的权值增加 $v$ A2 x v 将第 $x$ 个节点所在的连通块的所有节点的权值都增加 $v$ A3 v 将所有节点的权值都增加 $v$ F1 x 输出第 $x$ 个节点当前的权值 F2 x 输出第 $x$ 个节点所在的连通块中，权值最大的节点的权值 F3 输出所有节点中，权值最大的节点的权值 左偏树，懒标记。 看到操作 U 和最值，不难想到要使用可并堆维护。由于 F3 操作的存在，我们需要维护一个 set 用于保存所有堆顶的值。而 A2 可以用线段树的懒标记实现。A3就搞一个简单的全局增量。A1操作需要删除原有的节点，再加入新的。查询的时候注意要路径上的所有点pushdown，因为左偏树的高度是期望 $O(\\log)$ 的，所有往上找父亲的复杂度是对的。 代码其实挺难写的，要注意 set 修改的时候要仔细，同时A1和A2操作都需要修改。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485void pushdown(int x) &#123; if (!h[x].lazy) return; if (h[x].l) &#123; h[h[x].l].val += h[x].lazy; h[h[x].l].lazy += h[x].lazy; &#125; if (h[x].r) &#123; h[h[x].r].val += h[x].lazy; h[h[x].r].lazy += h[x].lazy; &#125; h[x].lazy = 0;&#125;void ALLpushdown(int x) &#123; if (h[x].fa) ALLpushdown(h[x].fa); pushdown(x);&#125;inline int getroot(int x) &#123; while (h[x].fa) x = h[x].fa; return x;&#125;int merge(int x, int y) &#123; if (!x || !y) return x + y; pushdown(x); pushdown(y); if (h[x].val &lt; h[y].val) swap(x, y); h[x].r = merge(h[x].r, y); h[h[x].r].fa = x; if (d[h[x].l] &lt; d[h[x].r]) swap(h[x].l, h[x].r); d[x] = d[h[x].r] + 1; return x;&#125;int clear(int x) &#123; int t = merge(h[x].l, h[x].r), f = h[x].fa; h[x].fa = h[x].l = h[x].r = 0; if (x == h[f].l) h[f].l = t; else h[f].r = t; h[t].fa = f; return getroot(t);&#125;int main() &#123; n = read(); rep (i, 1, n) &#123; h[i].val = read(); s.insert(h[i].val); &#125; Q = read(); d[0] = -1; while (Q--) &#123; op = readchar(); if (op == 'U') &#123; u = getroot(read()); v = getroot(read()); if (u != v) &#123; if (merge(u, v) == u) s.erase(s.find(h[v].val)); else s.erase(s.find(h[u].val)); &#125; &#125; else if (op == 'A')&#123; op2 = readchar(); if (op2 == '1') &#123; x = read(); y = read(); ALLpushdown(x); s.erase(s.find(h[getroot(x)].val)); h[x].val += y; s.insert(h[merge(x, clear(x))].val); &#125; else if (op2 == '2') &#123; x = getroot(read()); y = read(); s.erase(s.find(h[x].val)); s.insert(h[x].val += y); h[x].lazy += y; &#125; else delta += read(); &#125; else &#123; op2 = readchar(); if (op2 == '1') &#123; x = read(); ALLpushdown(x); writeln(h[x].val + delta); &#125; else if (op2 == '2') &#123; x = getroot(read()); writeln(h[x].val + delta); &#125; else writeln(*(--s.end()) + delta); &#125; &#125; return 0;&#125; BZOJ1294-[SCOI2009]围豆豆Bean 在一个 $n \\times m$ 的矩阵中，有 $D$ 个豆豆，都有一定的分值，还有一些障碍物。如果一个位置没有障碍，而且没有豆豆，就可以进入。要求从某个位置出发，最后回到这个位置，得到的价值为围住的豆豆数量，减去走的步数。求得到的价值最大为多少。$n, m \\leq 10, D \\leq 9$ SPFA，状压。 考虑枚举每一个点作为起点，$f[i][j][k]$ 表示到达 $(i,j)$ 可以包围的集合为 $k$ 的最短路径。因为状态存在环，跑一个SPFA就可以了。最后权值和减最短路径就是价值。 如何判断一个点最终是否会被围起来？射线法！ 从一点向随机方向引一条射线，如果射线和多边形的边相交奇数次，说明点在多边形内。否则在多边形外。考虑向右连射线，这里的相交需要左闭右开，也就是和一条竖直线段的非下端点相交才能算。 BZOJ1854-[SCOI2010]游戏 给定 $n$ 个数对，每个数对中最多选择一个数字。要求选择 $1,2,3,…$ 能达到的最大值。 巧妙的图论模型，并查集。 发现是一个二元关系，考虑建图。对于一个 $size = p$ 连通块，如果不存在环，只能选择 $p-1$ 个点，存在就能选择 $p$ 个。显然，可以用并查集维护连通块是否存在环，以及连通块的最大值即可。 BZOJ1856-[SCOI2010]字符串 求存在多少长度为 $n+m$ 的序列，存在 $n$ 个 $1$ ，$m$ 个 $0$ ，同时任意前缀的 $1$ 多于 $0$ 。 卡特兰数的扩展形式。终于知道卡特兰数怎么推了！！（如果早一点做这题，那场CF就不会血崩了QAQ）。 考虑这样一个 $n \\times m$ 的网格，设 $1,0$ 分别为向右上/右下走。可转化为从 $(0,0)$ 到 $(n+m,n-m) $且不能碰到 $y=1$ 的方案数。考虑容斥，总方案数为 $C(n+m,n)$ 。将路线与 $y=-1$ 第一个交点的左边沿着 $y=-1 $ 对称，发现不合法的方案为 $C(n+m,m-1)$ 。 盗用 题解 的图。 BZOJ1857-[SCOI2010]传送带 在一个 $2$ 维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段 $AB$ 和线段 $CD$。xx 在 $AB$ 上的移动速度为 $P$ ，在 $CD$ 上的移动速度为 $Q$ ，在平面上的移动速度 $R$ 。现在 xx 想从 $A$ 点走到 $D$ 点，他想知道最少需要走多长时间。 三分套三分。 时间 显然 是关于离开位置单峰的，三分一个 $AB$ 再三分 $CD$ 即可。证明嘛.. 先挖坑。 JSOI BZOJ1558-[JSOI2009]等差数列 给定 $n$ 个数，$m$ 个操作，每次给一段区间加一个等差数列，或者询问一段区间至少要用多少个等差数列来表示。$n,m \\leq 10^5$ 差分，线段树。 套路？考虑维护差分数组，修改操作变成了两个单点加和一个区间加，用线段树维护。 合并答案的时候比较复杂，用 $s[0/1][0/1]$ 表示左右端点取不取的答案。一段长度为 $n$ 等差数列就意味着，第一个是任意的差分值，剩下的 $n-1$ 差分值相等。 BZOJ1822-[JSOI2010]Frozen Nova 冷冻波 套路的二分+最大流，需要判断线段是否与圆相交。 计算几何。 只是想记录一下判断线段 AB 是否与圆 C 相交的简便方法。一种情况：线段的一端在圆内/上，首先直接特判掉。 第二种情况：线段两端在圆的两边。 考虑与此线段平行的两条切线中间，被圆分开的两块区域。线段的端点只可能分别在两个区域。首先用叉积求出 $2\\triangle ABC$ ，然后除以长度得到与圆心的距离，大于 $r$ 就判掉（防止卡精度，两边平方即可）。有可能线段的两端都在同一个区域，必定存在一个钝角。用点积判断。于是，代码： 1234if (dist2(a, c) &lt;= 1LL * r * r) return 1;if (dist2(b, c) &lt;= 1LL * r * r) return 1;return dot(b, c, a) &gt;= 0 &amp;&amp; dot(a, c, b) &gt;= 0&amp;&amp; cross(c, a, b) * cross(c, a, b) &lt;= 1LL * r * r * dist2(a, b); NOI BZOJ1564-[NOI2009]二叉查找树 给定一个Treap，总代价为深度$\\times$距离之和。可以每次以 $K$ 的代价修改权值（权值不能相同，并且是实数），问最小代价。 区间DP。 首先有一个很坑的点，权值不能相同。 事实上，由于权值是实数，所以随便改嘛… 然后数据范围也是假的。随便区间DP就好了.. POI AUT 给定一个长度为 $n$ 的置换。求存在多少个 $n$ 阶竞赛图满足，如果边 $(u,v)$ 存在，那么 $(p(u),p(v))$ 存在。$n \\leq 10000$ 简单计数。 考虑将置换分解为循环。容易发现： 对于同一置换：一个长度为 $L$ 循环的方案数为 $2^{L/2}$ 。 对于不同的置换：两个长度分别为 $a,b$ 的循环，连接的方式有 $2^{\\gcd(a,b)}$。 TRO 有 $n+p+q$ 个箱子，如果填充第 $i$ 个，那么第 $\\{i+p,i+p+q\\}\\ or\\ \\{i+q,i+p+q\\}$ 个要被填充。请构造一种方式能够填满前 $n$ 个箱子。$n \\leq 100000$ 贪心。 不妨令 $p &lt; q$ ，从左到右扫描，如果没有放 $i$。如果可以，放 $i+p$ 否则放 $i+q$ 。 可是，为什么这样是满足条件的呢？显然，第 $i+p+q$ 个箱子一定可以放。 不合法的情况当且仅当 $i+p,i+q$ 都放不了。如果 $i+q$ 放不了，那么一定是 $i-p$ 经过了一次操作。而如果 $i-p$ 进行操作，并且 $i$ 也没放，一定会选择放 $\\{i-p, i, i+q\\}$ 这与 $i$ 没放矛盾。所以所有操作都能进行。 BZOJ1098-[POI2007]办公楼biu 给定一个图，求它反图的连通块数目。 链表优化BFS。 显然边数过多，不能把所有边建出来。考虑链表优化。 每一次取出链表的第一个元素，加入队列然后扩展。把与其相连的点标记，再遍历链表，如果遇到没有被标记的，就加入队列。由于每个元素最多被删除一次，每条边最多阻止扩展2次，所以总的复杂度就是 $O(n+m)$ 。 BZOJ1100-[POI2007]对称轴osi 给定一个无自交的多边形，求对称轴数量。 计算几何，KMP。 显然，对称轴只可能是两个点的连线，或者是两条线段的连线。 如何保证轴两边对称？首先要确保距离相等，其次是角度（防止卡精度，又由于边长相等，可以用点积代替）。 然后这样就可以转化为串s，可以倍长得到ss后，用反串t来匹配、完整的匹配次数即是答案。 BZOJ1109-[POI2007]堆积木Klo 给定一个长度为 $n$ 的序列 $ai$，可以删除若干个数。求重新标号之后，$a_i=i$ 的个数最大值。 三维偏序。 考虑能够满足 $a_i=i$ 数的要求。 首先我们要保证 $i, a[i]$ 是递增的，还有保证 $i-a[i]$ 也是不减的（选择的相邻两个的差不应该超过位置差）。发现这是一个三维偏序。 这是一个假的三维偏序。因为 $a[i]$ 递增， $i-a[i]$ 不减时，$i$ 一定递增。二维偏序用 $LIS$ 即可。 BZOJ1122-[POI2008]账本BBB 给定一个由 $+1$ 和 $-1$ 构成的长度为 $n$ 的序列，提供两种操作： 将某一位取反，花销为 $x$ 将最后一位移动到前一位，花销为 $y$ 要求最终 $p+sum_n=q$，且 $p+sum_i≥0(1≤i≤n)$，求最小花销。 前缀和，贪心。 考虑预处理前缀，后缀最大前缀和 $pre/suf$，枚举起始位置。 一个很巧妙的思想就是可以根据 $pre,suf$ 求出移动后的前缀和最小值。然后我们贪心地把前面的若干个 $-$ 改成 $+$ 即可。代码就很短了： 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1000009;int sum[maxn], pre[maxn], suf[maxn];int n, p, q, x, y, mn, cnt; char s[maxn];long long res = 1e18, tmp;int main() &#123; scanf(\"%d%d%d%d%d\", &amp;n, &amp;p, &amp;q, &amp;x, &amp;y); scanf(\"%s\", s+1); sum[0] = p; for (int i=1; i&lt;=n; i++) sum[i] = sum[i-1] + (s[i] == '+' ? 1 : -1); suf[n+1] = suf[n] = sum[n]; pre[1] = sum[1]; for (int i=2; i&lt;=n; i++) pre[i] = min(pre[i-1], sum[i]); for (int i=n-1; i&gt;=1; i--) suf[i] = min(suf[i+1], sum[i]); for (int i=2; i&lt;=n+1; i++) &#123; tmp = 1LL * (n + 1 - i) * y; mn = min(suf[i] - sum[i-1], pre[i-1] + sum[n] - sum[i-1]); if (mn &lt; 0) &#123; cnt = (1 - mn) / 2; tmp += 1LL * cnt * x; &#125; else cnt = 0; tmp += 1LL * abs(sum[n] + cnt * 2 - q) / 2 * x; res = min(res, tmp); &#125; printf(\"%lld\\n\", res); return 0;&#125; COCI BZOJ1182-[COCI2009]PLAHTE 在平面坐标系中，有 $n$ 个矩形。时刻0，在原点处有一个xx，之后的每一时刻，每个xx会向周围八个方向扩展。给定 $Q$ 个询问，要求回答时刻 $t$ ，所有矩形覆盖的xx总数是多少。注意，没有矩形覆盖原点。$n, Q \\leq 10 ^ 6$ 二阶导数（大雾） 二阶差分，加速度。 很显然需要搞一个前缀和。 矩形总共有两种放置情况，一种是在一个象限，还有一种是横跨两个象限。为了 方便 处理，可以将后者拆分为两个矩形，同时，我们可以将矩形强制放在第一象限。还是为了方便我们可以用容斥原理，拆分为四个左下角固定，边长无穷大的矩形。 然后这个东西就很好弄了，扩散有一个初始速度，之后还有一个加速度。叠加起来就好了。本质上是一个二阶差分。 BZOJ1939-[COCI2010] Zuma 有一行 $n$ 个弹子，每一个都有一个颜色。每次可以让超过 $K$ 个的连续的同颜色的一段弹子消失，剩下的会重新紧凑在一起。你有无限的所有颜色的弹子，要求在这行弹子中插入最少的弹子，使得弹子全部消失。 真·祖玛，动态规划，奇妙的状态。 定义 $f[l][r][x]$ 表示对于 $(l,r)$ 这个子序列，我们需要插入 $x$ 个 $a[l]$ 才能使原序列消失，所需要的总的最小代价。 然后有三种转移： 直接在前面插入，$f[l][r][x] = f[l][r][x+1] + 1$ 直接删除，$f[l][r][K-1] = f[l+1][r][0]$ 和后面的匹配 ，$f[l][r][x] = f[l+1][p-1][0] + f[p][r][x+1] (l+1 \\leq p \\leq r, a[l] = a[p])$ Baltic BZOJ1356-[Baltic2009]Rectangle 给出 $n$ 个点，要你从这些点中找出四个点来组成一个矩形，面积最大。注意可以不与坐标轴平行。 几何基础。 考虑一个矩形，他的两条对角线长度相同，且中点相同。就可以 $O(n^2)$ 计算出来，然后按照对角线长度和中点位置排序，考虑可以配对的所有对角线。因为能共圆的点不多，所以直接暴力枚举可过。复杂度是 $O(n^4)$ 的。 事实上不用那么萎。考虑矩形的面积是对角线长度的平方，乘以夹角的 $\\sin$ 考虑按照极角序来排，然后用两个指针，始终维持夹角在小于等于 $\\frac {\\pi} {2}$ 的最大值。酱复杂度就是 $O(n^2 \\log n)$ 啦，可能实际并没有快多少？ BZOJ1761-[Baltic2009]beetle 在一条直线上有 $n$ 个点,每个点 $m$ 升水. 一个虫子在坐标轴 $0$ 上，它每个单位时间移动一格，每个点的水每单位时间消失 $1$ 升。问虫子最多可以喝到多少水，喝水的时间忽略不计。 提前费用计算。 显然是提前费用计算的套路，由于不知道最终要哪些点的水，枚举喝的点的数量即可。然后就是套路区间DP啦。 APIO BZOJ2303-[APIO2011]方格染色 有一个 $n \\times m$ 的方格，可以黑白染色，已经有某些格子已经染色。要求全部染色后，所有 $2 \\times 2$ 的区域中，恰好有奇数个黑块。问染色的方案数。 奇妙的并查集。 令 $S(i,j) = a[i][j] \\oplus a[i-1][j] \\oplus a[i][j-1] \\oplus a[i-1][j-1]$ 考虑将 $S(1..i-1, 1..j-1)$ 全部都 xor 起来。于是 $a[1][1] \\oplus a[i][1] \\oplus a[1][j] \\oplus a[i][j] = [i,j都是偶数]$ 。于是就有 $2n-1$ 个自由变元（也是因为有 $n^2$ 个变元， $(n-1)^2$ 个方程）。 然后我们可以枚举 $a[1][1]$ 的值。这些方程就可以的到 $a[i][1]$ 与 $a[1][j]$ 的取值是否相同。用一个带权并查集搞一搞，判矛盾以及统计连通块数目。 Code: 12345678910111213141516171819202122232425262728293031323334353637int getpa(int x) &#123; if (pa[x] == x) return x; int p = getpa(pa[x]); g[x] ^= g[pa[x]]; return pa[x] = p;&#125;bool link(int x, int y, int z) &#123; int u = getpa(x), v = getpa(y); if (u == v) return !(g[x] ^ g[y] ^ z); g[v] = (g[x] ^ g[y] ^ z); pa[v] = u; return 1;&#125;int calc() &#123; rep (i, 1, n+m) &#123; pa[i] = i; g[i] = 0; &#125; pa[n+1] = 1; rep (i, 1, Q) if (!link(x[i], y[i]+n, z[i])) return 0; int res = 0; rep (i, 1, n+m) if (pa[i] == i) res++; return Power(2, res-1);&#125;int main() &#123; n = read(); m = read(); Q = read(); flag[1] = flag[0] = 1; rep (i, 1, Q) &#123; x[i] = read(); y[i] = read(); z[i] = read(); if (x[i] + y[i] == 2) &#123; flag[z[i]] = 0; i--; Q--; continue; &#125; z[i] ^= (x[i]^1)&amp;(y[i]^1)&amp;1; &#125; if (flag[1]) ans = (ans + calc()) % MOD; if (flag[0]) &#123; rep (i, 1, Q) if (x[i] &gt; 1 &amp;&amp; y[i] &gt; 1) z[i] ^= 1; ans = (ans + calc()) % MOD; &#125; printf(\"%d\\n\", ans); return 0;&#125; BZOJ1178-[APIO2009]CONVENTION会议中心 给定若干条线段。要求选取最多的线段，使之不重叠。在最多的基础上，要求选取的线段字典序最小。 倍增，贪心。 如果没有字典序最小这个条件，就是一个裸的贪心。然后这就有一个倍增的经典应用。 考虑首先搞掉所有包含其他线段的线段。然后倍增，$f[i][j]$ 表示第 $i$ 条线段之后，所选择 $2^j$ 条线段的最右边一条。只需要贪心预处理 $f[i][0]$ 。 然后仍是贪心地考虑放入线段 $1,2,…$ ，如果放入线段之后，对答案不会产生影响，就选择这条线段。 BZOJ1912-[APIO2010]patrol巡逻 给定一棵有根树，可以加入 $K = 1\\ or\\ 2$ 条边，使得从 $1$ 出发，遍历所有的边，问需要走的最小距离。 DFS，贪心。 对于 $K=1$ 的情况，显然是选取直径的两端，可以减小直径-1次移动。 考虑 $K=2$ ，假设已经增加了一条边。对于一条边，如果它之前已经被覆盖了，第二次仍然被覆盖，那么这条边就要经过 2 次（因为新加入的两条边一定要走，这条边要走两次才能回到原来的一侧）。然后再次求最长链即可。 BZOJ1913-[APIO2010]signaling信号覆盖 给定 $n$ 个平面上的点，任意三点不共线，任意四点不共圆，问随机选择三个点构成的外接圆，能够覆盖的点数的期望值。 $n \\leq 1500$ 计算几何。 注意到对答案的贡献涉及到四个点的关系。所以考虑任意四个点 $A,B,C,D$ ，分成两种情况。构成了一个凹四边形，那么对答案的贡献为 $1$ ；构成一个凸四边形，对答案的贡献为 $2$ （这个很容易通过四点共圆得到），显然这样的统计不会重复。 于是就变成统计凹/凸多边形的个数。一个简单的方法就是，枚举凹多边形的凹点 $C$ ，极角排序。然后对于另一端 $D$ ，统计 $B,C$ 的对数。 USACO BZOJ4757 给定长度为 $N$ 的序列 $ai$ ，对每个 $ai$ 分配 $ci$ ( $ci$ 为正整数)，且 $ci$ 之和等于 $K$ ，求出最小的 $ai/ci$ 之和。 奇妙的贪心。 考虑这样一个事实，对于 $ai,aj$ ，$ci$ 增大 $1$ 的同时， $cj$ 减小 $1$ 。那么偏移量一定是一大一小，而且增大的速度更快。根据贪心玄学的思想，我们二分偏移量，使得这个偏移量最小，那么答案一定是最优的。 BZOJ4768 给定一个长度为 $N$ 的序列，允许翻转一个非连续子序列，求最长不下降子序列长度。所有数 $&lt;=50$ 。 奇妙的DP，附加状态。 用 $f[i][j][l][r]$ 表示 $[i,j]$ 内左边是 $&gt;=l$ ,右边是 $&lt;=r$ 的最大不下降子序列长度。然后两端的数换不换都转移一下。 为什么要这样考虑呢？因为翻转相当于 $[i,j]$ 两边的交换。为了保证是递增的， $[l][r]$ 显然是需要的。 BZOJ4741 有 $n$ 个点，保证不存在三点共线。对于所有构成的三角形，内部的点数就是它的价值。对于每一价值，计算三角形的块数。$n \\leq 300$ 奇妙的容斥原理，计算几何。 似乎很不可做的样子，事实上，利用容斥原理，我们就可以做到 $O(1)$ 计算一个三角形内的点数。考虑预处理： 对于所有二元组 $(u,v)$ ，计算满足向量 $(u,v) \\rightarrow (u,p)$ 的角不大于 $\\pi$ 的点 $p$ 数论。 对于所有三元组 $(u,v,w)$ ，计算满足 $p$ 在向量 $(u,v) \\rightarrow (u,w)$ 之间的个数。 之后配一波系数，容斥一下就好了。 BZOJ4586 给定一个长度为 $n$ 的初始序列 $Ai$ ，和一个目标序列 $Bi$ 。可以花费 $x$ 的代价使得一个数增加 $1$ ，或者花费 $y$ 的代价使得一个数减少 $1$ 。对于 $(i,j)$ 花费 $|i-j|z$ 的代价使得 $Ai$ 减一， $Aj$ 加一。问最小需要的代价总和。$n \\leq 100000$ 奇妙的贪心，反悔操作。 考虑经典的堆来维护返回操作。维护两个堆，分别表示多余的和缺少的。对于每个树默认操作是直接增加或减少，同时把这个反悔后的新代价放入堆。 BZOJ4410 给定一个网格图，拆除所有行的竖向边，拆出所有列的横向边的代价都已经给定。问使得所有方格连通的最小代价。 堆，Kruskal。 考虑Kruskal算法的思想，我们要求最小生成树，就需要按照边权从小到大选择。拆出未连接的边即可。注意一个方向的所有边都拆完不一定连通。 BZOJ4411 给定 $n$ 个点，请你确定一条横线和一条竖线，使得平面划分成的四个区域内点最大值最小. 线段树上二分。 枚举直线 $x=a$ ，显然两边在线段树中可以动态插入/删除。二分 $y=b$ 的位置。注意到两端是一个下凸函数，取 max 之后仍然下凸。这个东西就可以线段树二分辣。 BZOJ4409 有一个 $N$ 个点的环，最终点 $i$ 存在 $ri$ 头牛。有 $\\sum ri$头牛。可以选择最多 $k$ 个点，然后牛分配在这k个点里。之后每一头牛可以不动，也可以顺时针走 $d$ 格并呆在那里，要耗费d的能量。通过合理分配。使得消耗的总能量最小。$n \\leq 1000$ 斜率优化DP。 由于存在环，显然我们可以枚举第一个选择点的位置 $i$ 。用 $f[j][k]$ 表示从 $i$ 出发，选择 $k$ 个点，到 $j$ 的最优解。然后这个东西是可以斜率优化的。 同时有注意到切线是递增的，所以可以做到 $O(n^2k)$ 。然鹅这个东西是要用 $k-1$ 层去更新第 $k$ 层。所以需要把 $k$ 放在外面。 随便一写就rk3了？？ BZOJ3939 有一个 $n \\times m$ 的网格，每个格子有一个取值。从 $(1,1)$ 出发，每一次可以跳到严格右下方的格子。问存在多少中方案能够跳到 $(n,m)$ 。$n, m \\leq 750$ 动态规划，动态开点线段树。 显然DP+容斥嘛。维护一个二维前缀和，减去与当前颜色相同的方案数。 考虑对每个颜色开一个动态开点线段树。每一次最多增加 $O(\\log n)$ 个节点。所以总共的空间是 $O(n^2 \\log n)$ 的。 BZOJ4509 数轴上有 $n$ 个点。可以在任意一个位置上引爆，使得爆炸范围内的点再次引爆，但是引爆半径减一。问最小的初始引爆半径，使得所有点都被引爆。 动态规划，单调性。 注意到左右两部分是无关的，所以我们可以求出前缀和后缀所需要的最小引爆半径。 用 $f[i]$ 表示 $i$ 左边都被引爆的最小半径。于是有： $f[i] = \\min \\{ ai - aj, f[j+1] + 1 | j &lt; i, a[i] - a[j] &gt; f[j] \\}$ 注意到前半部分是随着 $j$ 的变大而单调递减的，而后面是单调递增的。所以我们可以求出两个接近时候的最值。复杂度 $O(n)$ 。 BZOJ4099 数轴上有 $n$ 个点，每个点有一个大小 $si$。从任意一个位置出发，沿着同一方向跑至少 $si$，就可以突破点 $i$，得到更大的空间。问无法逃脱的线段总长度。 set 考虑按照点的大小，从大到小插入。当插入一个点后，查找它的前驱和后继，如果无法突破，就打上标记。由于每个点至多被标记一次，所以复杂度是对的。 BZOJ3429 有一个 $n \\times m$ 的01矩阵，以及他的目标状态。每一次可以修改 $b*b$ 大小的子矩阵，使得原来的矩阵到达目标状态。问最大的 $b$是多少。 模拟？ 显然，这个 $b$ 是满足单调性的。当大的 $b$ 满足时，小的 $b$ 也满足。所以考虑暴力修改，当无法再次修改时，用更小的 $b$ 替换。 Other BZOJ1426-收集邮票 $n$ 种邮票，你要收集所有种类的邮票。每次能买一张，买到的邮票是哪一种，概率均为 $1/n$ 。购买第 $k$ 张邮票需要 $k$ 元钱。现在手中没有邮票，问得到所有种类的邮票需要钱的期望。 期望神题，平方相关。 先挖坑吧。。智商还不够 题解一 题解二 BZOJ2708-[Violet 1]木偶 给定两个序列 $\\{a_i\\},\\{b_i\\}$ ，满足 $a_i = b_i$ 。重复一下步骤，选择任两个 $i,j$ 满足 $|a_i-b_j| \\leq 1$ ，将个两个数配对，直到无法再配对。问最坏情况下，未配对的 $a_i$ 最多有多少个。 贪心，动态规划。 显然可以从小到大排序。这就是一个二分图，一个显然的性质：边不会出现交叉。因为只能连接差的绝对值不超过 $1$ 的数，所以交叉只会是相邻的两个，显然这个可以用连向自己的来代替，并且答案不会更劣。 然后就可以推出结论，配对一定是形如 //..//\\\\..\\\\//... 这样延伸下去的。然后就可以DP了。需要搞一个 $calc(i,j)$ 表示 $[i,j]$ 无法配对的最多有多少。考虑从大到小枚举，判断 应该/不应该 配对的两个数能否配对。","tags":[{"name":"题解","slug":"题解","permalink":"https://xuzhean.github.io/tags/题解/"}]},{"title":"「切题记录」Codeforces","date":"2017-12-31T16:00:02.000Z","path":"2018/01/01/Solutions-Codeforces/","text":"一个良好的算法竞赛社区. 题虽杂，却不乏有趣的想法. 补题记录主要是 NOIP2017 前 Codeforces Round #422 (Div. 2) CF822E。给定长度为 $ n $ 的字符串 $ s $ ，长度为 $ m $ 的字符串 $ t $ （ $ m \\leq n $ ）。问是否能在 $ s $ 中分割出不超过 $ x $ 段不相交的连续子串，使得不打乱顺序后，能够组成字符串 $ t $ ？ $ n \\leq 10^5,x \\leq 30 $ DP，贪心，HASH+二分求LCP。 注意到一个事实，假设已经匹配到 $ s[i] $ ，那么我们一定要让已匹配的长度尽可能长，又由于 $ x $ 的取值并不大，由此得到状态的定义：定义 $ f[i][j] $ 表示 $ s[1..i] $ 划分为 $ j $ 段后，能在 $ t $ 中匹配的最长前缀。 假设 $ f[i][j]=k $ ， $ l $ 为 $ s[i+1..n],t[k+1..m] $ 的 $ LCP $ 。考虑向后转移。 一种是不匹配， $ f[i+1][j]=max(f[i+1][j],f[i][j]) $ 。 一种是匹配， $ f[i+tmp][j+1]=max(f[i+tmp][j+1],f[i][j]+tmp) $ ， $ tmp $ 不大于 $ l $ 。 可是，这里的第二种转移是 $ O(n) $ 的，考虑如何优化。注意到，对于 $ tmp \\leq l $ ， $ i+LCP(i+1,f[i][j]+1)=i+tmp+LCP(i+tmp+1,f[i+tmp][j]+1) $ 。所以从 $ f[i] $ 向后转移一定比从 $ f[tmp] $ 向后转移更优（或是相等，需要划分的段更少）。因此，我们只需要转移到 $ f[i+l][j+1] $ 即可。 $ LCP $ 可以通过后缀数组（窝不会）或者经典的 $ HASH $ +二分求出。 Code CF 822F。给定一棵树，每个节点有一个秒表，可以选择若干条不相交路径。对于一条路径， $ a1,a2,a3…,ak $ ，选择边 $ (ai,ai+1) $ 上距离 $ ai $ 为 $ x $ 的位置出发。先一直走到 $ ak $ ，然后再返回到 $ a1 $ ，如此往复。每秒钟走一条边。当点到达某个节点时，会把节点的秒表置 $ 0 $ 。请构造一种方案，使得节点 $ 1 $ 秒表的最大值最小，如果相同，使得 $ 2 $ 的最大值最小，以此类推。 $ n \\leq 100 $ 贪心，构造。题意比较鬼畜，可能比较奇怪？注意到，一定是把所有单独的边作为路径最优。这样所有的运动就是以 $ 2 $ 为周期的。对于节点 $ i $ ，假设它的度为 $ d[i] $ ，我们将时间 $ 2 $ 划分为 $ d[i] $ 段，让 $ d[i] $ 条边上的点以 $ \\large \\frac 2 {d[i]} $ 为周期访问 $ i $ 。所以说因为这样的最优值唯一，所以和字典序无关。 算法用DFS实现，注意父节点向子节点的传递。 Code Codeforces Round #423 (Div. 2, rated, based on VK Cup Finals) CF828D。请构造一棵包含 $ n $ 个节点， $ k $ 叶子节点的无根树。使得叶子节点的距离的最大值最小。 $ n \\leq 2 \\times 10 ^ 5 $ 贪心，构造。 以 $ 1 $ 为根，分出 $ k $ 个分支，答案一定是最优的。为什么呢？如果不这么做，达到相同的距离需要的边数会更少，增加边数后，答案一定更劣。三个月前的Cyani好傻逼啊。 Code CF828F。给定一个连通图，对于每条边求出它的最大权值，使其在图的所有最小生成树上（不改变其他边的权值）。 $ n,m \\leq 10^5 $ 最小生成树，倍增。 非常套路的题，首先求出MST（也一定是最小瓶颈树），然倍增搞一搞就好了。分为两种情况： 这条边不在MST中。直接倍增求路径的 $ \\max $ 。（如果想要更小的常数，可以并查集按秩合并，不过不能修改？？） 这条边 $ (u,v) $ 在MST中。取连接 $ u,v $ 两端的非MST边， $ (u,v) $ 一定要比最小值还要小，似乎要枚举每一条边？Cyani好傻逼啊。其实也可以倍增，只是从大的推到小的罢了。 嘴巴上AC很容易啊。既然是嘴巴选手，那么我就先不写。。 UPD: Code Codeforces Round #427 (Div. 2) CF835E，交互题。 已知存在 $ n $ 个数，只有两个数是 $ y $ ，其他的数都是 $ x(x\\not=y) $ 。您可以询问任意一个子集的 $ xor $ 和。求出 $ y $ 所在的两个位置。询问数不得超过 $ 19 $ 。 构造好题，异或性质利用，二分查找。 非常巧妙的一道题啊，考虑一个问题：如果只存在一个数为 $ x $ ，应该怎么做？很显然只要二分查找，不断缩小范围。关键在于如何区分两个 $ y $ ， 一开始的想法是随一半的位置，直到两个 $ y $ 存在不同的集合之中？应该不超过7,8就好了，很显然会被卡。由于数据组数过多，不能使用概率算法。 假设两个位置分别为 $ a,b $ 。考虑一个难以发现的性质，我们只需要不超过 $ 10 $ 次询问，询问强制某一位为0的子集，确定 $ a,b $ 在这一位是否相同。就能得到 $ a \\oplus b $ 的值。然后我们对 $ a $ 进行二分搜索即可。可是，似乎这样仍然需要 $ 20 $ 次？ 注意到 $ a,b $ 的顺序是无关对，对于某一位 $ a \\oplus b=1 $ （显然一定存在），只要强制 $ a $ 的那一位为 $ 0 $ 就好了。好妙啊。 一个有趣的事实，官方题解说不存在算法能够小于 $ 19 $ 次来解决这个问题（随机乱搞当然不算啊）。为什么呢？？题解没说。蒟蒻Cyani来口胡一下：对于每一个询问，实际上只能得到 $ 2 $ 种回复，偶数个或是奇数个 $ 1 $ 。总共的情况数为 $ C(1000,2)&lt;2^{19} $ ，所以说至少 $ 19 $ 次询问才能对应唯一一种情况。 Code CF835F。给定一个有 $ n $ 个节点和 $ n $ 条边的图，任意两点相互联通，无自环，无重边，求删掉一条边形成的树的直径的最小值。 $ n \\leq 2 \\times 10 ^ 5 $ 环套树，树的直径。 显然是一个环套树，假设环上有 $ k $ 个点。首先假设每个点对应的最大深度为 $ di $ ，断开 $ (i,i+1) $ 。那么有三种情况， $ [1,i] $ 直径最大的点， $ [i+1,k] $ 直径最大的点， $ [1,i] $ 到 $ 1 $ 的最优距离 $ +1 $ 到 $ k $ 的边 $ +[i+1,k] $ 到 $ k $ 的最长距离，取三者的最大值，来更新最小值。显然这些都可以 $ O(n) $ 预处理。 注意外向树的直径！ 貌似成为一名嘴巴选手了QAQ，代码周末补吧。。 UPD: Code 2KB代码写了1h，我好弱啊啊啊 自我感觉求基环的部分很简洁，以后就这么写啦。。 Codeforces Round #428 (Div. 2) CF839D。给定一个集合，包含一些整数 $ ai $ 。一个子集 $ s={a[i1],a[i2],a[i3],…,a[ik]} $ 的力量定义为 $ k\\times \\gcd{s} $ 。求所有子集的力量总和。 $ n \\leq 100000 $ 数论，容斥原理。 考虑每个 $ gcd $ 的贡献。定义 $ f[i] $ 为大小为 $ i $ 的集合的所有子集，的大小之和，显然有 $ f[i]=2f[i-1]+2^{i-1} $ 。但是这样会算重，由此想到容斥原理。 假设集合中 $ k $ 的倍数有 $ cnt $ 个， $ f[cnt] $ 可以得到， $ \\gcd $ 是 $ k $ 的倍数的贡献。考虑从 $ k $ 从大到小枚举，减去被数的个数，由此可以的得到 $ \\gcd = k $ 的个数。 Code CF839E。给出 $ n(n≤40) $ 个点的邻接矩阵，要求给每个点赋值，使得点的权值和为 $ K $ ，每条边权值为两端点点权的乘积，最大化边的权值和。 最大团问题。 不会做啊，CF的Div2竟然有论文题！！！题解，有时间再补。 Codeforces Round #424 (Div. 2, rated, based on VK Cup Finals) CF831F。有 $ n $ 棵竹子，竹子每天长 $ 1m $ ，每个竹子都有一个临界高度 $ ai $ ，每 $ d $ 天去看竹子，如果有竹子的高度超过了对应的临界高度，就它砍断(不会再长高)，然后把高于 $ ai $ 的部分收集起来现在求一个最大的 $ d $ ，满足最后收集到的竹子长度小于等于给定的 $ k $ 。 $ n \\leq 100,k \\leq 10^{11},ai \\leq 10^9 $ 数论，分块好题。 假设隔 $ d $ 天看一次竹子，那么得到的长度为： $$ \\large \\sum_{i=1}^n \\left( d\\times \\lceil\\frac {ai} d \\rceil - ai \\right)​$$ 又需要满足条件，得到不等数，再两端再同除以 $ d $ ，整理得到，（ $ sum $ 表示 $ k $ 与 $ ai $ 之和） $$\\large \\sum_{i=1}^n \\lceil \\frac { ai } {d} \\rceil \\leq \\lfloor \\frac {sum} d \\rfloor$$ 考虑按照 $ \\large \\lfloor \\frac {sum} {d} \\rfloor $ 来分块，如果存在 $ d1,d2(d1&lt;d2) $ 满足： $$\\large \\lfloor \\frac {sum} {d1} \\rfloor = \\lfloor \\frac {sum} {d1} \\rfloor$$ 如果 $ d1 $ 满足，那么 $ d2 $ 一定满足。所以，我们只要对于块内的最大值进行check。复杂度 $ O(n\\sqrt{sum}) $ 。 Code Codeforces Round #426 (Div. 2) CF834C。有 $ n $ 场游戏，初始分均为1，每回合，胜者分数乘上 $ k^2 $ ，输的分数乘上 $ k $ ，（每一回合的 $ k $ 都是任意的）。给定两个数 $ a,b $ ，问这两个数是否可能是他们最终的分数。 $ n \\leq 3.5\\times 10^5,a,b \\leq 10^9 $ 数论，二分。 注意到 $ a\\times b $ 一定可以表示为 $ k[1]^3 \\times k[2]^3 \\times k[3]^3 \\times … \\times k[m]^3 $ ，此处的 $ k[1],k[2],… $ 有可能相等。考虑二分找到 $ mid=k[1]\\times k[2]\\times … \\times k[m] $ ，如果能找到并且 $ mid|a,mid|b $ ，那么一定是存在一种方式的，反之则不存在。 话说Cyani在VP的时候好傻逼啊，竟然不会做。暴力乱搞搞到TLE69，优化无果就弃了。rk:800+ Code CF834D。有一个长度为 $ n $ 的序列，划分为 $ K $ 个连续子序列，每个子序列的价值为不同的元素种类。求所有子序列的代价总和的最大值。 $ n \\leq 35000,K \\leq 50 $ DP，线段树。 显然是一个DP，首先考虑最暴力的方式：定义 $ f[i][j][k] $ 表示前 $ i $ 个元素划分为 $ j $ 个子序列，最后一个子序列从 $ k $ 开始。两种转移： 从 $ f[i-1][j][k] $ 转移，如果 $ [k,i-1] $ 中没有出现过 $ a[i] $ ，那么加一。判断是否出现，我们只需要记录每个元素上一次出现的位置即可。 从 $ f[i-1][j-1][t]+1 $ 转移到 $ f[i][j][i] $ 。 发现状态难以优化，考虑优化转移。事实上，我们可以将所有 $ f[i][j][] $ 用线段树维护，对于转移1，就是区间修改，转移2就是询问区间最值。维护 $ K $ 棵线段树即可。 Code CF834E。给定区间 $ [L,R] $ ，求区间中的数去掉这个数中的 $ 0 $ 之后，把这个数各个数位上的数从小到大排列后，总共有多少个不同的排列情况。 $ L,R \\leq 10^{18} $ 爆搜。 又是爆搜？？暂时弃了。。 Codeforces Round #429 (Div. 2) CF841D。给定一个包含 $ n $ 个节点， $ m $ 条边的无向图。可能包含重边，但不包含自环。每个节点的值 $ di $ 可能为 $ 0,1,-1 $ 。找出一个边的集合满足：对于每个点 $ i $ ，在集合中 $ i $ 的度数模 $ 2 $ 为 $ di $ ，或者 $ di=-1 $ 。 $ n,m \\leq 3\\times 10^5 $ 构造。 算是比较好的一道构造题。考虑这样一个事实：如果存在解，那么一定存在一个解满足构成的图是森林。为什么？如果存在一个环，那么把所有环的边去掉，节点度的奇偶性仍然不变。于是可以像树一样进行 $ DFS $ ，考虑每一条边是否需要保留即可。 考虑这样一个性质，对于树上的一条路径，只有路径两端的奇偶性才会变化。如果 $ DFS $ 到了节点 $ u $ ，可以通过 $ u $ 将 $ u $ 的子树中的路径配对（如果 $ d[u]=1 $ ，那么 $ u $ 也要配对）。最后只会留下 $ 0,1 $ 条未配对路径，返回给父节点。 Code CF841E。给定包含 $ n $ 个数的数组 $ a[] $ ，对于一个长度为 $ n $ 的置换 $ P $ ，如果对于 $ 1 \\leq i &lt; n $ ，不存在 $ a[p[i]\\times a[p[i+1]] $ 是完全平方数，那么置换 $ P $ 是满足条件的。求有多少个置换是满足条件的。 $ n \\leq 300 $ 组合，DP，好题。 考虑将所有数划分为若干个组，每个组的数两两相乘都是完全平方数（也就是这些数包含的质因子的指数奇偶性相同）。这样就转化为，存在若干种物品，同种物品不能相邻的方案数。设第 $ i $ 组有 $ cnt[i] $ 个数，考虑DP。 定义 $ f[i][j] $ 表示，对于前 $ i $ 组数，存在 $ j $ 对相邻为同组的数的方案，对于同组的数是无序的。于是我们在转移（加入一组新的数）的时候，首先将这组数划分为 $ k $ 段，再挑选 $ p $ 段插入到相邻的同组数中，最后再将剩下的段插入。其中 $ m=cnt[1]+cnt[2]+…+cnt[i-1] $ 。 $$\\large f[i][j+cnt[i]-k-p] = f[i-1][j] \\times C(cnt[i]-1,k-1) \\times C(j,p) \\times C(m-1-j+2,k-p)$$ Code Codeforces Round #431 (Div. 1) CF848B。有一个 $ W*H $ 的矩阵在坐标轴上。从 $ x $ 轴出发有一些舞者，在位置 $ pi $ 时间 $ ti $ ，沿着 $ y $ 轴正方向走。 $ y $ 轴同样如此。当两个舞者相遇时，他们会改变各自的方向为对方的方向。问所有舞者的最终位置。 $ W,H,n \\leq 10^5 $ 脑洞题。注意到满足 $ pi+tj=pj+ti $ 的两个舞者会相遇，可以按照 $ pi-ti $ 的值将所有舞者划分为若干类，每一类都会碰撞一次。根据 $ x,y $ 轴上的舞者数目可以 $ O(1) $ 判断每个舞者交换后对应的舞者。 C，cdq分治。 D，网络流。 E，FFT。 好一场CN Round！ Bubble Cup X - Finals (Online Mirror) CF852A。给一个 $ 10^{200000} $ 以内的数字，支持一种操作：在数字之间加若干个加号，把原数字变为加法运算后的结果，要求在三次操作内把数字变成个位数，输出方案。 随机化。 注意到如果每次在所有数字间加上加号，容易出现 $ 999.. $ 的情况。所以可以随机化，每一次多合并相邻的两位，直到答案符合要求。还是比较容易被满足的。 CF853C。给定一个正 $ 2n $ 边形，每条边被分为 $ n $ 等分，其中第 $ 0,2,..,2n-2 $ 条边上各选择一个蓝点 $ B0,B2,..,B2n-2 $ （保证是 $ n $ 的置换）。 您需要确定 $ B1,B3,..,B2n-1 $ （同样是 $ n $ 的置换），使得这些 $ B $ 点构成的面积最大。 贪心，一次函数。 注意到白色三角形的面积总和是关于 $ B1,B3,.. $ 的一次函数。计算出系数后，根据排序不等式即可贪心配对。 D，二分+网络流。 H，毒瘤。 I，树上莫队。 Manthan, Codefest 16 CF633E。给定 $ n $ 和长度为 $ n $ 的两个数组 $ v[i],c[i] $ ，定义区间的价值 $ \\large p(l,r) = \\min(100 \\times \\max _{k=l} ^{r} v[k],\\ \\min_ {k=l} ^{r} c[k]) $会随机选择一些 $ li $ ，您会选择对应 $ ri(li \\leq ri) $ ，使得 $ p(li,ri) $ 最大。求所有最大值的最小值的期望值。 $ n \\leq 10^6 $ 期望，对数转化。 注意到对于给定的 $ l $ ，我们可以预处理 $ ans[l] $ 为最大的 $ p(l,r) $ 。具体就是 $ ans[i] = \\min ( \\max (100 \\times v[i], ans[i+1]), c[i]) $ 。 发现选择的 $ K $ 个 $ ans[i] $ 中，只有最小的一个才会产生贡献。考虑所有 $ ans[i] $ 按照递增来排序，新的 $ ans[i] $ 的贡献为 $ \\large \\frac {C(n-i,K-1) \\times ans[i]} {C(n,K)} $ 。发现 $ n $ 实在是太大了，所以可以将组合数转化为对数的运算。 Code CF633D。给定一棵带点权的树，选取两条不相交路径，求点权和最大值。 $ n \\leq 10^5 $ 树形，背包DP。 一开始我是拆分为三种状态，然后十分复杂的转移，WA23了QAQ。 后来看见一种很简洁的写法。用 $ f[i][j][k] $ 表示， 以 $ i $ 为根的子树中，已经选择了 $ j $ 条路径，当前 未确定的路径，和根向下延伸的条数。转移就变成类似背包的形式。注意一些特殊情况，还要手动完成选择。 Code 泛做总共进行了3轮，均在 NOIP2017 前后. 第一轮 _From 300 to 360_Codeforces Round #301 (Div. 2)540C,4Y。BFS判连通。注意起始点与终点重合或相邻的情况，终点经过两次，只要有两个空格与终点相邻即可。 540D,1Y。概率DP。乘上转移的概率即可。 540E,3Y。离散化+树状数组统计逆序对。设出现的数为$\\{a\\}$，未出现的为$\\{b\\}$，发现a-&gt;a，a-&gt;b，b-&gt;a有贡献，分类讨论即可。 反思 把所有特殊情况考虑周全，仔细分类讨论。 Codeforces Round #302 (Div. 2)544C,1Y。二维完全背包DP。其实挺套路的，要加个滚动数组。 544D,1Y。暴力BFS。注意到两个点对的最短路径若存在交集，则一定是连续的一段。暴力枚举两点即可。 554E,1Y。状压DP。其实状压DP都挺套路的:①数据范围一般不超过20.②预处理加速转移.③转移时顺序无关，强制转移 $ lowbit $ 。 反思 注意观察题目性质，从多角度思考状态的表示。 Codeforces Round #303 (Div. 2)545C,4Y。贪心。注意到能往左倒就往左倒，否则能往右倒就往右倒，并不会使答案变差。注意 $ n=1 $ 的情形。 545D,2Y。贪心。发现一定是 $ t $ 升序最优，对于一定不会满意的人，显然跳过放在最后最优。 545E,1Y。最短路DAG+DAG的最小树形图。由于数据范围过大，最小树形图并不能用朱刘算法来做。考虑是一个DAG，类似Kruskal依次加入权最小的边，保证弱连通块的入度为1.正确性不难感受到。 Codeforces Round #304 (Div. 2)546C,1Y。暴力。 546D,1Y。欧拉筛。考虑类似求积性函数的方式，可以推出每个数的素因子个数。 Codeforces Round #305 (Div. 2)548C,7Y。暴力求循环节+扩欧。坑点较多，注意分类讨论。 548D,1Y。单调栈或线段树。 548E,1Y。数论，容斥。考虑到一个数的素因子个数很少，直接暴力搜索容斥。 Codeforces Round #309 (Div. 1)553D,3Y。贪心。考虑现将所有的可以的点放入集合，每次取出权值最小的，更新周围点的权值。因为只有取出最小值，最小权才有可能变大。过程用堆维护即可。 Codeforces Round #310 (Div. 1)555D,2Y。贪心+堆。将问题转化为：给定一些数轴上的点，和一些线段，每个线段要匹配一个点。于是按照左端点不断加入线段，用堆维护右端最小的即可。 Codeforces Round #Pi (Div. 2)567E,1Y。最短路。首先求出最短路，反向建图后的最短路。注意到如果所有最短路都经过某一条边，那么相当于前驱最短路条数乘后继最短路条数等于总的最短路条数。如某一条边是最短路上的边，减一就可以满足条件。否则可以继续讨论。 567F,1Y。动态规划。注意到需要构造的序列是单峰的，所以考虑从小到大逐个加入两端。对于限制，DP到较大位置时判断即可。 反思 深入挖掘单调性(单峰亦同)寻找，寻找DP的阶段。 Codeforces Round #315 (Div. 1)568B,1Y。第二类斯特林数。注意到 $ n $ 等价关系能够对于到 $ n $ 完全图。于是答案即为，选取一些点(不能是全部)，划分为几个非空集合的方案数。假设选 $ i $ 个点，划分为 $ j $ 个集合，答案即为 $ C(n,i)\\times S(i,j)$。其中 $ S(i,j)$是第二类斯特林数，可以 $ O(n^2)$ 递推。 反思 从二元关系联系到图。 Codeforces Round #317 [AimFund Thanks-Round] (Div. 1)571A,2Y。正难则反+组合计数。有一个结论，将一个长度为 $ n $ 的序列划分为 $ 3 $ 个(可空)子序列，方案数为 $\\large \\frac {(n+1)(n+2)} {2}$ 。加上不合法的方案，总方案即为 $\\large \\sum \\frac {(n+1)(n+2)} {2}$。考虑减去不合法的情况，假设 $ a,b,c $ 伸长量分别为 $ x,y,z $ ，假设 $ a+x $ 最大。当 $ a+x&gt;=b+c+y+z $ 时不符，可以得到 $ b+c-a \\leq x \\leq l $ ，且 $ 0 \\leq y+z \\leq min(a+x-b-c,l-x)$，于是 $ y,z $ 的方案同样可以由上面的结论算出。 571B,6Y。同余分组+贪心+动态规划。考虑分为 $ K $ 组，所有 $ a\\equiv b\\pmod K $ 分为一组。设 $ d=n/ K $ 发现，前 $ n\\ mod\\ K $ 组都有 $ d+1 $ 个数，后 $ n-n\\ mod\\ K $ 组都有 $ d $ 个数。排序后即可DP。 Codeforces Round #318 [RussianCodeCup Thanks-Round] (Div. 1)573A,5Y。暴力。考虑将所有数的素因子2,3都去除，判断是否相同。 Codeforces Round #319 (Div. 1)576B,1A。构造。首先将置换分解为若干个循环，注意到一个性质，长度为 $ x $ 的置换能连上长度 $ kx $ 的置换，只有长度为 $ 2 $ 的置换能自己连自己。且能作为根的只有长度为1或2的置换，分类讨论即可。 576C,1A。构造。考虑按 $ x $ 轴划分为 $ T $ 个区间，每个区间平均有 $ n/T $ 个，可以来回移动，最坏情况下有 $ T\\times[10^9+(n/T)\\times(10^9/T)]=10^9(T+n/T)$ 的移动距离，显然取 $ T=\\sqrt n=10^3 $ 最优。 576D,1A。矩阵快速幂+floyd。考虑到 $ m $ 很小，可以逐个加边，用矩乘维护连通性，同时用floyd求连通后的最短路。矩阵乘法次数过多，会超时。但由于矩阵维护的是01信息，所以可以用 $ bitset $ 优化。 Codeforces Round #320 (Div. 1) [Bayan Thanks-Round]578A,1Y。公式。发现 $ a&lt;b $ 时无解，由于 $ x $ 要尽可能小，所以点一定都是在所有三角的右侧。根据 $ a/b $ 就可以算出属于第 $ t $ 个三角形。于是$\\large x=\\frac {a+b}{2t}$即可。 578B,1Y。贪心，暴力。考虑到 $ k $ 次操作一定是都乘在同一个数上最优，求出前缀和后缀 $ or $ 值即可。 578C,3Y。三分，贪心。考虑到答案是关于 $ x $ 的单峰函数（显然？），于是三分即可。可以同 $ O(n)$的贪心求出最大字段和。 Codeforces Round #321 (Div. 2)580E,3Y。HASH+线段树。发现[l,r]是周期为d的串等价于 $ S[l,r-d]=S[l+d-r]$，于是考虑维护区间的HASH值即可。 Codeforces Round #323 (Div. 1)582A,2Y。暴力+map。考虑每次取出最大的数 $ x $ ，一定是 $ a $ 中的元素，再将 $ x $ 与之前取出的 $ gcd $ 暴力删除即可。 582B,1Y。LIS变形。考虑保留出现次数最多的元素 $ x $ ，首先取出长度为 $ n^2 $ 的段，求出 $ LIS $ ，发现 $ x $ 一定可以找到某个位置插入，所以还要加上 $ x(T-n)$。 583C,2Y。数论。对于好数组的元素 $ a[i]$有， $\\forall k\\in N, a[i]=a[i+kn],a[i]&gt;=a[i+ks]$ 。即$\\forall k \\in N,a[i]&gt;=a[i+k\\times gcd(s,n)]$。也就是说a[i]是这些a[]中的最大值。考虑枚举 $ d=gcd(s,n)$。求出 $ f[i]$表示以 $ i $ 结尾最长满足条件的长度，以及 $ cnt[i]$即 $ gcd(n,j\\times d) = d\\ (j \\leq i)$ 的的个数。以 $ i $ 结尾，对答案的贡献即为 $ cnt[f[i]/d]$。复杂度 $ O(n的因子数\\times n)$。 Codeforces Round #325 (Div. 1)585A,1Y。模拟。用一个优先队列直接模拟即可。 585C,3Y。GCD。引入Stern–Brocot tree，将苹果数看作分子，橘子数看作分子，每次操作可以把 $\\large (\\frac a b,\\frac c d)$ 变为 $\\large (\\frac{a+c} {b+d}, \\frac c d)$ 或 $\\large (\\frac a b, \\frac {c+a} {b+d})$。也就是它们的和在 $ Stern-Brocot\\ tree $ 上向左或向右移动。由于得到的分数一定是互质的，所以当 $ gcd(x,y)\\not = 1 $ 时，没有答案。当 $ x&gt;y $ 时，会向左子树移动 $\\large \\frac x y $ 次，之后 $ x\\ mod\\ y $ 会成为新的 $ x $ 。整个过程和求 $ gcd $ 类似，复杂度 $ O(log(x+y))$。 Codeforces Round #326 (Div. 1)587A,2Y。贪心。考虑逐个处理从小到大的 $ wi $ ，如果 $ wi=k $ 有偶数个，一定能组成$\\frac k 2 $ 个 $ wi+1 $ ，反之，能组成 $\\frac {k-1} 2 $ 个 $ wi+1 $ 并需要用掉一个。 587B,4Y。DP。考虑将序列复制 $ k $ 次得到长度为 $ nk $ 的序列，然后DP加前缀和优化求出第 $ i $ 块第 $ j $ 结尾的方案数。多余的部分 $(T-nk)$ 答案等同于第 $ k $ 块。 587C,3Y。树上倍增。考虑到树上路径的问题，且不存在修改，考虑使用树上倍增。 $ g[i][j]$表示节点 $ i $ 到他的 $ 2^j $ 的祖先，路径上最靠前的10个人被编号(注意去重)。合并的方式类似于归并排序。复杂度 $ O(10\\times nlogn)$。 Codeforces Round #327 (Div. 1) 590A,4Y。题意：给定一个长为 $ n\\ (n \\leq 5\\times 10^5)$ 的01串，每次对于 $ 2 \\leq i \\leq n-1 $ ，的 $ ai $ 会变成 $ a[i-1],ai,a[i+1]$ 的中位数。问经过多少次会变成一个稳定的串(即不会发生改变)。 构造。考虑长度为2或以上的0/1段一定是不变的，于是我们可以将中间的串单独提取出来，不难发现，由于不存在连续的串，一定是010101….(或101010….)这样的。最终的结果由两端决定。 590B,1Y。题意：要从 $(x1,y1)$ 到 $(x2,y2)$ 。一开始风速为 $(vx,vy)$， $ t $ 秒后$(wx,wy)$。速度不超过 $ Vmax $ ，求最少到终点的时间。保证风速小于你的速度，风速和你的速度都是向量。 二分答案。显然二分答案啊。事实上，可以看作空气是不动的，而目标点是逆风移动，对于答案 $ T $ ，只要新的距离 $ d \\leq Vmax\\times T $ 即可。注意按照 $ T,t $ 的大小关系分类。 590C,5Y。题意：给定一个 $ N\\times M $ 的矩阵，这个矩阵里有’1’, ‘2’, ‘3’, ‘.’, ‘#’，可以把’.’改成桥，使得所有1,2,3四联通，问最少把多少个’.’改变，如果不能输出-1。其中’1’,’2’,’3’本身是连续的。 $ N,M \\leq 1000 $ BFS+分类讨论。 考虑到答案只存在于两种情况。一种是三个连通块都会聚到一点。还有一种是两个连通块连向同一个连通块。于是BFS求出123到所有格子的最短距离即可。 590D,2Y。题意：给定 $ n $ 个数，最多相邻交换 $ s $ 次，求前 $ K $ 个数能达到的最小值。 动态规划。注意到一个性质，当 $\\large s&gt;=\\frac {n(n-1)} 2 $ 时，一定能取到 $ n $ 个数中最小的 $ K $ 个。定义状态 $ f[i][j]$表示固定前 $ i $ 个位置，交换 $ j $ 次能得到的最小的和。然后，为了取消后效性，依次考虑我们从1到n位置上的数。状态 $ f[i][j]$能转移到状态 $ f[i+1][j+k-(i-1)]$， $ k $ 代表放在 $ i+1 $ 位位置的数。 Codeforces Round #330 (Div. 1)594A,1Y。博弈，贪心。注意到后手一定会去掉最外层的 $\\large \\frac {n-2} 2 $ 个点，排序后扫描即可。 594C,2Y。暴力，贪心。显然我们只需要删除最左/上/右/下的点即可。考虑按 $ x,y $ 分别排序。因为 $ k $ 不大，所以我们暴力枚举两端取了多少，之后上下同样处理。注意长宽都至少是1。 594D,1Y。题意：给定 $ n $ 个数，有 $ Q $ 个询问，每个询问要求您回答 $\\large \\varphi(\\prod \\limits ^{r} _{i=l} a[i])$ 的值。 $ n,Q \\leq 2\\times 10^5 $ 离线，线段树，数论。考虑到 $ n,Q $ 的范围过大，我们考虑离线。 根据欧拉函数$\\varphi $ 的定义，$\\large \\varphi(n) = n\\times \\frac {p_1-1} {p_1} \\times \\frac {p_2-1} {p_2}\\times …$，我们只需要求出区间内有那些质因数一颗。考虑按照询问的左端点排序，扫描过程中维护区间$[l,n]$，对于区间 $[l,n]$ 内的每一个质因子，我们只需要在线段树内保留最靠前的一个，因为后面对答案没有影响。 删除 $[l]$ 时，我们只要对于 $ a[l]$的每个质因子找出它后面的第一个质因子，在线段树上更新即可。复杂度 $ O(a\\times loga+Q\\times logn\\times loga)$。 Codeforces Round #333 (Div. 1)601A,3Y。最短路。注意到由于是一个完全图，所以一定存在某一种交通工具可以直达，剩下一个交通工具floyd即可。 601B,1Y。题意：给定 $ n $ 个数字 $ h[1..n]$。定义 $\\large L(h)=max \\lceil \\frac {|h[j]-h[i]|} {j-i} \\rceil $ 给定 $ Q $ 个询问，每个询问给定 $ li,ri $ 求$[li,ri]$所有子序列的 $ L(h)$之和。 单调栈。可以将 $(i,h[i])$ 看作平面直角坐标系上的点。发现定义的就是两点间斜率的最大值。考虑不管这些点是凸或者凹的，斜率的最大值一定是由相邻的两个点产生的。于是，我们只需要用单调栈求出每个 $ h[i]$的作用域即可。 601C,3Y。题意：有 $ n $ 场比赛，每一场比赛都有 $ m $ 人参与。每场比赛的得分都是这个人的排名（没有相等的）总分是 $ n $ 场比赛的分数之和。总排名定义为：总分严格小于他的人数+1。已知小K在n场比赛中的排名。所有人的水平相同，求小K的期望总排名。 期望DP。考虑到直接求出小K的排名过于困难，按照定义，只要求出总分严格小于他的期望人数。于是就想到，用 $ f[i][j]$ 表示 $ i $ 场比赛之后总分为 $ j $ 的期望人数。故有 $\\large f[i][j]=\\sum \\frac{f[i-1][j-k]} {m-1} \\ (1 \\leq k \\leq m, k\\not = a[i])$ 观察式子，考虑到可以前缀和优化转移。 Codeforces Round #334 (Div. 1)603A,1A。贪心，DP。观察到，一个位置对答案产生了贡献，当且仅当这个位置的数与前面一个数不同。又由于只能翻转连续一段，所以DP时定义三种状态即可。 603C,3A。博弈论+SG函数。考虑引入SG函数，当 $ i $ 为奇数时， $ SG[i]=mex\\{ SG[i-1]\\}$。当 $ i $ 为偶数时，能够进行第二种操作， $ SG[i]=mex\\{SG[i-1], SG[i/2]\\ xor\\ SG[i/2]… \\}$，共有 $ k $ 个SG[i/2]的异或和，注意到这只和 $ k $ 的奇偶性有关。 考虑寻找规律。当 $ k $ 为奇数时，由于 $ SG[i]=mex\\{ SG[i-1], 0\\}$，所以之后的 $ SG[i]$一定是0/1间隔出现的。当 $ k $ 为偶数时， $ SG[i]=mex\\{ SG[i-1], SG[i/2]\\}$，并且注意到 $ i $ 为奇数时， $ SG[i]=0 $ ，所以只要 $ log\\ a[i]$次递归调用即可。 Codeforces Round #335 (Div. 1) 605A,1A。题意：给定 $ n $ 的一个排列，每次可以把一个数放到开头或末尾，求变为升序的最少步骤。 贪心。考虑那一段是可以不用变化的，发现就是数字连续上升的最长字段（例如,..,1,2,..,3,..,4,…）于是 $ O(n)$ 扫一遍即可。 605B,1A。题意：有一个 $ n $ 个点， $ m $ 条边的图，然后 $ m $ 条边中有 $ n-1 $ 条边构成了最小生成树，然后边权与是否作为MST的边告诉你，要构造出这个图。 最小生成树的性质，贪心。考虑首先构造出他的最小生成树，再往上面加边。考虑到最小生成树的边不能被新加入的边 $(u,v)$ 代替，所以需要 $ u,v $ 之间的路径的边尽可能少，所以可以强制 $ root=1 $ 剩下的 $ n-1 $ 个点直接连到 $ root $ 。将最小生成树的边与其他边按照边权排序。 每加入一条MST的边，可以与前面的节点产生一些新的点对，由于边权是升序的所以之后的其他边一定不会产生冲突。注意我们只需要保留最小的 $ m $ 条即可。 605C,3A。题意：有 $ n $ 项工作，第 $ i $ 项工作每天可以带来 $ ai $ 的经验， $ bi $ 的钱。问最少几天可以得到 $ p $ 的经验和 $ q $ 的钱。工作天数可以是小数，每次只能进行一种工作。 二分答案，凸包。首先考虑二分答案 $ T $ 。如何 $ O(1)$ 来check？我们将 $(ai,bi)$ 看成坐标系上的一个点 $ Pi $ ，由于工作时间可以是小数，通过线性变换， $ Pi,Pj $ 可以变换为线段 $ PiPj $ 上的点。所以可以先求出凸包，然后二分答案判断即可。 605D,1A。题意：玩家有两个属性 $ x,y $ ，有 $ n $ 个魔法。对于第 $ i $ 个魔法，用$(ai,bi,ci,di)$ 描述。当 $ ai \\leq x, bi \\leq y $ 时，玩家能使用这个魔法。之后玩家的属性 $ x=ci, y=di $ 。求施展第n个魔法最少需要多少次。输出方案，答案不唯一。 线段树（树状数组）+set，BFS。由于需要求出最小的步数，所以需要用到BFS。考虑到达了点$(x,y)$，我们可以到达在它左下角的点 $(x’,y’)$，所以就需要用一个数据结构求出。树套树显然可以，不会写。考虑线段树（树状数组）套set，访问过后暴力删除。考虑其时间复杂度。由于每一个点最多在 $ O(logn)$个 $ set $ 中出现，单次操作复杂度 $ O(logn)$，所以总的时间复杂度 $ O(n\\times logn \\times logn)$，不会超时。 Codeforces Round #336 (Div. 1) 607A,4A。题意：有 $ n $ 个点，点有位置和能量， $ i $ 个点被选择，那么在 $ i $ 左边它这个能量的位置内的所有点都不能选择，如果现在从右到左依次选择点。现在可以在最右边放置一个点，能量和距离随意，问各种情况下最小摧毁的点的个数。 $ N \\leq 100000,ai \\leq 1000000 $ DP。考虑到点的坐标范围较小，令 $ f[i]$ 表示到位置 $ i $ 时，最多能放的点。于是 $ f[i]=max(f[i-1],f[i-d[i]-1]+1)$。 607B,1A。题意：长度为 $ n $ 的字符串，每次消去一段连续的回文串，剩下的两端重新拼接成一个新的串，问最少需要消去多少次。 $ n \\leq 500 $ 区间DP。令 $ f[i][j]$ 表示区间 $[i,j]$ 需要消去的最少次数。发现有两种决策：一种是从 $ f[i][k]+f[k+1][j]$ 转移过来，将 $[i,j]$划分为两个更小的子段；还有一种是从 $ f[i+1][j-1]$转移，因为中间肯定存在其他回文串，所以不用 $+1 $ 。 607C,3A。题意：有两个独立的坑道，由“NSWE”表示。两个球在各自坑道的起点。之后对两个球做相同的操作，上下左右。保证两个小球保持一致的动作，其中一个撞墙的话不用管。问能不能保证两个小球都能从起点到达终点。到达终点后，还有可能因为操作而退出。 脑洞，HASH。考虑依次让两个球分别到达终点，可以猜测一个结论，无法到达当且仅当第一个球达终点后，第二个球需要到达终点的步骤，恰好使得第一个球退出（证明有些困难）。于是可以改变第一个球轨道的方向，就变成字符串匹配的问题。 Good Bye 2015 611C,1A。题意：有一个 $ n\\times m $ 的网格，‘#’不能摆。有 $ Q $ 个询问，每个询问$(r1,c1,r2,c2)$求出这个子矩形内可以有多少种方式放一个 $ 1\\times 2 $ 的骨牌。 $ n,m \\leq 500,Q \\leq 100000 $ DP，容斥。注意到，对于一个询问，我们可以将其拆成4个前缀询问。而这个前缀询问可以预处理，令 $ f[i][j]$ 表示 $[1,1]$ 到 $[i,j]$ 骨牌的摆放方式。 $ f[i][j]=f[i-1][j]+f[i][j-1]-f[i-1][j-1]-[i,j]$能放的骨牌数。对于查询，我们只需要再次容斥，暴力删除边界的答案即可。复杂度 $ O(n^3+nQ)$。 611D,1A。题意：把一个长为 $ n $ 的数字串拆成多个串，要求这些串的数值递增的，并且没有前缀0，问有多少种分法。 $ n \\leq 5000 $ DP，LCP。定义状态 $ f[i][j]$ 表示 $[1,i]$ 中划分了最后 $ j $ 个的方案数。发现状态难以优化，考虑从加速转移入手。假设前一段划分的长度为 $ k $ ，注意到当 $ k \\leq j-1 $ 时，显然能够转移，即 $ f[i][j]=\\sum _{k=1} ^{j-1} f[i-j][k]$，这一部分可以前缀和优化。还有可能是从 $ f[i-j][j]$转移到 $ f[i][j]$，就需要比较 $[i-2j+1,i-j],[i-j+1,i]$ 的大小。由于长度相等，实际上就是在比较字典序。而比较字典序有一个常用的方法，可以求出以 $ i,j $ 开头的最长公共前缀，记为 $ lcp(i,j)$，这样预处理后就可以 $ O(1)$ 转移了。 Codeforces Round #339 (Div. 1) 613A,1A。题意：有个 $ n $ 边形，给定了所有点的坐标。有一个点 $ P(x,y)$。这个 $ n $ 边形会绕着点 $ P $ 旋转。求这个多边形扫过的面积。 计算几何。发现我们只需要求出点到多边形的最近和最远距离，对于最远距离，一定是在某个点上，而对于最近距离，还有可能在边上。发现一定是做垂线最优，利用三角形面积公式和叉积即可，但垂足一定要在多边形上，用点积判断是否是钝角即可。 613C,5A。题意：有 $ n $ 种颜色的珠子，每个珠子有 $ A[i]$个，要把这些珠子串成一个环，你可以在其中一些地方断开，如果断开后是回文， $ Ans+1 $ ，问最大 $ Ans $ 。 脑洞，GCD，构造。首先特判 $ n=1 $ 的情况，就是 $ A[1]$。注意到，若存在两种以上的珠子数目为奇数，则一定无法构成回文串。 不难发现我们可以划分为 $ gcd $ 段，考虑 $ gcd $ 的奇偶性。若 $ gcd $ 为偶数，在每一段内，我们可以任意放置，之后的每一段，间隔着倒置即可， $ Ans=gcd $ 。若 $ gcd $ 为奇数，由于不存在两个以上奇数，所以每一段内恰有一个奇数，我们只需要把这个奇数放在中间，两边对称放置即可。 Wunder Fund Round 2016 (Div. 1 + Div. 2 combined) 618C,2A。题意：给定 $ n $ 个点$(xi,yi)$。求一个三角形 $ ABC $ 。满足其他的点都在三角形以外。输出任意一个三角形三个点的下标。 $ n \\leq 100000 $ 乱搞，计算几何。考虑按照 $ x $ 轴排序，任意三个点形成的区域一定不包含其他点。只要并满足三点不共线即可。 CF618E,2A。题意：给定 $ x $ 正半轴上的 $ n $ 段线段。有 $ m $ 个操作，操作1是给定 $ x $ ，然后把第X段延长 $ y $ 。操作2是把某&gt;一个段按照原先的左端点旋转α°。每次操作询问原先最右边的端点的位置。 $ n,Q \\leq 100000 $ 。 线段树，计算几何，矩阵。有很多方法可以解决此题。考虑使用线段树求解，考虑维护线段另一端到这端的相对位移。对于操作一，只需要求出原长，然后新的$(x’,y’)$可以通过比例求出。需要注意的是操作二，对于某一点$(x,y)$绕原点 $ O $ 逆时针旋转 $ a $ 的弧长，有如下公式（窝不会证）。 $$x’=x\\cdot \\cos\\alpha - y\\cdot \\sin\\alpha \\\\y’=x\\cdot \\sin \\alpha + y \\cdot \\cos \\alpha$$ 事实上，我们需要旋转 $[x,n]$ 所有线段，这样就能解决了。 还有一种方法使用矩阵。维护区间的转移矩阵即可。 CF618F,1A。题意：给定两个多重集 $ A,B $ ，每个数$\\in [1,n]$。在 $ A $ 中选取一个含 $ Ka $ 个元素的非空子集。在 $ B $ 中也是如此（有 $ Kb $ 个元素）。要求使得两个子集之和相等。 $ n \\leq 100000 $ 。 构造，抽屉原理。如果不存在范围的限制，这是一个NP问题？考虑构造，首先我们按照元素大小升序排一遍序，分别求出其前缀和 $ SA[i],SB[i]$，下标为$[0,n]$共 $ n+1 $ 个。不失一般性，我们令 $ SA[n]&gt;=SB[n]$。考虑 $ i $ 从 $ 0 $ 扫到 $ n $ ，每一次求出 $ SB[j]&lt;=SA[i]$最大的 $ j $ 。不难发现 $ 0 \\leq SA[i]-SB[j]&lt;=n-1 $ ，而总共 $ i $ 有 $ n+1 $ 种。所以，根据抽屉原理，一定存在两个不同的 $ i,i’$使得 $ SA[i]-SB[j]=SA[i’]-SB[j’]$。移项得， $$SA[i]-SA[i’]=SB[j]-SB[j’]$$ 于是在 $ A $ 中取$[i’+1,i]$，在 $ B $ 中取 $[j’+1,j]$ 就是一组解。 AIM Tech Round (Div. 1) CF623A,4A。一个由 $ a,b,c $ 组成的字符串，可以这样生成一张图，当 $ s[i]$与 $ s[j]$不是一个 $ a $ 一个 $ c $ 时， $ i $ 与 $ j $ 连一条边。给定生成的图，求是否存在字符串能生成这张图。 $ n \\leq 500 $ 二分图染色。考虑到其反图，一定是由 $ a,c $ 组成的，且相邻的边不同。对于不在反图中的点，考虑改为 $ b $ 。这样似乎就好了？事实上，若原来的图中存在一条边，在新生成的字符串中为 $ a,c $ ，答案是不符的。 CF623B,2A。有一个数列，可以删除其中一段，删一个代价为 $ a $ 。也可以选择对其中一些数进行增加或者减少1，每次代价为 $ b $ ，问最后使得所有的 $ gcd $ 比1大，最小代价是多少。 gcd相关，动态规划。注意到，由于并不能删光全部的，而且删除的是连续一段，所以 $ a1,an $ 中必定存在一个剩余，于是对 $ a_1-1 $ ， $ a_1 $ ， $ a_1+1 $ ， $ a_n-1 $ ， $ a_n $ ， $ a_n+1 $ 操作找到其质因数，用DP求出都变为这个质因数倍数的最小代价。状态定义可参考CF603A。 CF623C,10A。平面上有 $ n $ 个点$(xi,yi)$。每个点可以变成$(xi,0)$，或$(0,yi)$。所有的点变换之后，两点最大距离的平方的最小值是多少。 $ n \\leq 100000 $ 二分答案。细节非常多的一题，需要注意的地方很多。首先按照 $ x $ 排序，求出前缀后缀的 $ y $ 最大最小值。二分答案 $ ans $ ，考虑如何通过 $ O(n)$扫描判断可行性。答案会有三部分影响，一是 $ x $ 轴之间的，取决于 $ x $ 轴上的最高最低点，二是 $ y $ 轴上的，同样如此，三是 $ x,y $ 之间的，取决于 $ x $ 和 $ y $ 的绝对值最大值。 我们需要从左往右，从右往左各进行一次扫描。假设 $ l $ 是选取最左端在 $ x $ 轴上的，显然我们一定是选择连续的一段最优，且右侧的不对答案产生影响， $ r $ 处是满足$|x[l]| &gt;= |x[r]|$最右侧的点，对于每对$(l,r)$还要进行判断。显然 $ l,r $ 都是单调移动的，所以整体判断的复杂度是 $ O(n)$。注意到，移动过程中可能出现一些非法情况，需要通过缩小范围解决。具体参见代码。 CF623D,1A。题意：给定 $ n(≤100)$个人，每轮随机猜一个人，每个人被猜中的概率为 $ pi\\%,\\sum pi\\%=1 $ ，游戏结束当且仅当每个人被猜中一次或以上。问在最优策略下，期望结束轮数是多少。 贪心，DP，神题。以下抄自dalao的博客。设 $ f[i][j]$ 表示第 $ i $ 轮结束之后，第 $ j $ 个人被抓过的概率。设 $ g[i]$表示第 $ i $ 轮结束之后，所有人都被抓过的概率。 首先，考虑到 $ g[i] = \\prod ^{n} _{j=1} f[i][j]$ ，答案即为 $$Ans = \\sum ^{+∞} _{i=1} i\\times(g[i]−g[i−1])$$ 于是最优策略即为，尽量使得 $ i $ 较小时， $ g[i]−g[i−1]$ 较大。注意到 $ f[i][j]$和 $ f[i−1][j]$的关系。 第 $ i $ 轮不选 $ j $ ， $ f[i][j]=f[i−1][j]$ 第 $ i $ 轮选 $ j $ ， $ f[i][j] = f[i−1][j] + (1−f[i−1][j]) \\times pj $ 所以，$\\large g[i] = g[i−1] \\times \\frac {f[i][j]} {f[i−1][j]}$ 。只要求$\\large \\frac {f[i][j]} {f[i-1][j]} $ 最大即可，这个可以枚举。其实 $ 3 \\times 10^5 $ 轮过后答案就不会再有大于 $ 10 ^{−6}$的误差了。误差分析窝不会。 8VC Venture Cup 2016 - Final Round (Div. 1 Edition) CF634A,1A。有 $ n $ 个岛屿，1连2,2连3,…..n-1连n,n连1。初始有n-1个岛屿上有雕像，只有一个岛屿没有。若两个岛屿相邻且一个无雕像、一个有雕像。则可以将雕像移到无雕像的岛屿。给定初状态和末状态，问可不可以达到。 $ n \\leq 200000 $ 暴力。发现空的岛屿可以忽略，对于剩下的岛屿，只要初末状态循环同构即可。可以强制将雕像1放在岛屿1。 CF634B,1A。给定 $ S $ 和 $ X $ ，问有多少对$(a,b)$满足 $ a+b=S, a \\oplus b = X $ 。 位运算的性质。注意到异或是没有进位的加法，两个二进制位 $ a,b $ 发生进位， $ a=b=1 $ 。所以有， $$a + b = a \\oplus b + a\\ \\&amp;\\ b $$ 也就是说，我们可以求出 $ a\\ \\&amp;\\ b $ 的值。逐个考虑 $ a\\oplus b $ 的每个二进制位。若某一位为0，此时只要令 $ x=y=x\\ \\&amp;\\ y $ 恰好仅有一种方案。若某一位为1，则 $ x,y $ 一定是一个1，一个0。当且仅当 $ x\\ \\&amp;\\ y=0 $ 时存在两种情况，否则无解。注意，题目中要求的是正整数，所以 $ S=X $ 时，答案需要减2。 CF634C,1A。题意：工厂每天产出 $ a $ 件商品，设备需要维修，维修前每天产出 $ b $ 件商品，维修需要 $ k $ 天。这 $ k $ 天没有产出。给出一些订单的日期和数量以及一些查询，每次查询给出一个维修开始日期 $ p $ ，表示第 $ p $ 天开始维修在 $ n $ 天内最多可以接多少单（商品数量），注意订单只能当天完成。 $ n,Q \\leq 200000 $ 树状数组。考虑建立两个树状数组，一个是维修之前，一个是维修之后，能最多完成的商品数量。只要不超过上限即可。 Codeforces Round #345 (Div. 1) CF650A,2A。题意：给定 $ n $ 个点，求存在多少点对，满足它们的欧几里德距离等于曼哈顿距离。可能包含相同的点。 容斥原理。注意到仅有当两个点在同一行或列时，满足条件。所以只需要求出每一行或列的个数即可。相同位置的点会计算多次，减去即可。 CF650B,1A。题意：有 $ n $ 张图片，有 $ T $ 时间。每次可以往左者往右翻阅，1的左边是 $ n $ 。然后，每张图片有2种阅读方式，一种是w，一种是h，其中w的照片需要花费 $ b $ 的时间翻转然后变成h，花费1的时间看。问最多能看多少照片。 滑动窗口。因为存在环，所以首先考虑倍长。可以看照片一定是一段区间，所以维护左右指针，单调移动即可。 CF650C,3A。题意：给定一个 $ n \\times m $ 的表格，您需要压缩它，压缩后仍是 $ n \\times m $ 的表格。需要保证压缩前后，同一行，同一列，它们的相对大小关系不变（小于还是小于，等于还是等于）。求压缩后表格最大数的最小值。压缩前后的表格上的数都是正数。 $ nm \\leq 10^6 $ 贪心，并查集。依次考虑从小到大的所有数。对于一个数 $ a[i][j]$它需要大于第 $ i $ 行和第 $ j $ 列所有已经加入的数，对于所有相等的 $ a[i][j]$，因为在同一行或列时必须相等，可以使用并查集将所有点连起来，找到这些点至少需要的新的值。 CF650D,1A。题意：给定一个长度为 $ n $ 的数列，和 $ m $ 个询问，每个询问给出 $ Ai,Bi $ 表示把第 $ Ai $ 个数改成 $ Bi $ 之后，这个数列的最长上升子序列（严格大于,询问相互独立）。 $ n,m \\leq 400000 $ LIS，树状数组，离线。考虑离线，对于一个询问，可以发现答案由两部分。一是改为 $ Bi $ 后，经过 $ i $ 的LIS，这个只需要从前到后，从后到前各扫描一遍即可。二是不经过 $ i $ 的LIS。如果 $ i $ 不一定是原序列LIS一定经过的数，则该部分的答案为LIS，否则为LIS-1。 考虑如何判断一个位置是否一定是LIS要经过的。如果满足 $ pre[i]+suf[i]=LIS+1 $ ，存在LIS经过 $ i $ 。如果还满足 $ pre[i]=pre[j]\\ (i\\not = j),pre[j]+suf[j]=LIS+1 $ 则说明 $ i,j $ 是可以互换的，则不是LIS一定经过的数。 CROC 2016 - Elimination Round CF645C,1A。题意：有一个有 $ n $ 个房间的酒店，FJ带上了他的 $ k $ 头cow。有一些房间是空闲的，FJ要订 $ k+1 $ 间房间，使得FJ到最远的奶牛距离最小。 $ n \\leq 100000 $ 二分答案。考虑枚举FJ所在的位置，二分答案 $ d $ 。只需要满足区间内空的房间数大于等于 $ k+1 $ 即可。只需要预处理前缀和。 CF645D,1A。题意：有一个有向图，如果不构成唯一的拓扑排序，输出$-1 $ ，否则输出最小的 $ k $ ，使得前 $ k $ 条边就能满足唯一的拓扑排序。 二分答案，拓扑排序。发现显然答案具有单调性，考虑二分答案 $ k $ 。只要有向图的最长链为 $ k $ ，就存在唯一的拓扑序。 CF645E,2A。题意：给定 $ n,k $ ，和一个字符串 $ t $ ，要在 $ t $ 后面加上n个不超过’a’+k-1的字母。问不同的子序列最多能有多少。 $ n,|t|&lt;=1000000,k \\leq 26 $ 动态规划好题，单调性。考虑如何求一个给定字符串的不同子序列个数。其实，难点就在于如何避免重复计数。定义 $ f[i][j]$表示前 $ i $ 个字符串中取出，且结尾字符为 $ j $ 的方案数。两种情况： $\\forall str[i] \\not = j, f[i][j] = f[i-1][j]$ $\\exists str[i] = j, f[i][j] = \\sum _{t=1} ^{k} f[i-1][t]+1$ 如何理解第二种转移？事实上就是在前 $ i-1 $ 个的基础上，强制增加了 $ str[i]$，加一指的是单个的 $ str[i]$，不难发现，对于每一个 $ i $ ，都不存在重复计数的情况。通过维护 $ sum = \\sum f[i][j]$可以在 $ O(n)$ 的时间内求出所有的 $ f[]$。 如何才能使得新增 $ n $ 个字符后最优，还是从状态转移方程入手。要使得 $ sum $ 尽可能地大，就要使得 $ f[][j]$最小，因为这样增加的值最大。可是这里是取过模的，如何比较大小？注意到 $ f[i][str[i]]$是随着 $ i $ 单调递增的，所以我们只需要维护所有字符上一次出现的位置即可。 IndiaHacks 2016 - Online Edition (Div. 1 + Div. 2) CF653E,2A。题意：有 $ n $ 个点， $ m $ 条不是树的边，其中节点1的度数为 $ k $ 。问能不能构成这样一棵树。 set优化BFS。考虑从2到n的点构成的连通块。发现存在三种情况会无解： 1连出去的边少于 $ k $ ； 存在连通块，不能和1相连； 存在多于 $ k $ 个连通块，一定有连通块无法连接。 如何求出所有连通块？朴素的BFS由于需要寻找出边，复杂度 $ O(n)$。考虑到有很多点已经访问过，所以用set维护未访问的点，记为 $ list $ 。如果是无法连接的点，则需要跳过，为什么这样复杂度仍是对的？注意到，这种情况只会出现 $ O(m)$次，所以总的时间复杂度 $ O((n+m)\\times \\log n)$。 VK Cup 2016 - Round 1 CF639B,4A。给定 $ n,d,h $ ，请构造一颗有 $ n $ 个节点的树，满足其高度为 $ h $ ，深度为 $ d $ 。 构造。首先判断无解的情况，如果满足 $ d&gt;=2h $ ，或 $ d=2 $ 且 $ n \\not = 2 $ ，则一定无解。首先构造长为 $ h $ 的链，再构造长为 $ d-h $ 的链，剩下的都连到1即可。注意要特判 $ d=h $ 的情况。 CF639C,1A。定义一个合法的 $ n $ 次多项式 $ f(x)$，满足最高项系数 $ a[n]\\not=0 $ ，所有系数 $ ai $ 都是整数，且绝对值不超过 $ K $ 。现在给您一个合法的 $ n $ 次多项式 $ P(x)$，但 $ P(2)\\not=0 $ 。您需要改变其中一个系数，得到一个 $ n $ 次多项式 $ Q(x)$。满足 $ Q(2)=0 $ 。求方案数。 $ n \\leq 200000 $ 贪心，脑洞。考虑从低位到高位上传系数，使得系数 $ ai $ 变为 $ 1,-1,0 $ ，只有 $ an $ 不满足。不难发现，如果我们需要更改系数 $ ai $ ，若$\\exists j&lt;i,a[j] \\not = 0 $ 则无法通过改变 $ ai $ 使得满足答案，记最大能够满足的为 $ flag $ 。 从高位向低位扫描，每一次维护更高项的等价系数 $ sum=sum \\times2 + a’[i]$，也就是说高位的数字之和等于 $ sum \\times 2^i $ 。若 $ i \\leq flag $ 可以尝试将原来的 $ a[i]$改为 $ a[i]-sum $ ，若其绝对值不大于 $ K $ ，是满足条件的。注意最高项的新系数不能为0。 CF639D,2A。有 $ n $ 个人，每个人都有自己的贡献 $ ti $ （任意整数）可以花费 $ b $ ，使得某个人的贡献$+5 $ 。花费 $ a $ ，使得某个人的贡献$+1 $ 。求至少使得k个人的贡献相等，最少需要的花费。 $ 1 \\leq k \\leq n \\leq 200000 $ 模意义下分类，贪心，优先队列。首先考虑 $ 5c $ 和 $ b $ 的关系，当 $ 5c&lt;b $ 是显然令 $ b=5c $ 可以更优。由于两种操作的代价不同，所以无法简单地通过两个指针来解决。 考虑按最终答案模 $ 5 $ 的值$=d $ 来分类，首先我们要修改所有的数使得所有的数模 $ 5=d $ ，记这一部分花费为 $ x $ 。我们还要选择一个最大的 $ a[r]$，修改其他的 $ k-1 $ 为 $ a[r]$。贡献如何计算，即为$\\large \\sum(x + \\frac {(a[r] - a[i])b} {5})$。于是将这个括号拆开，拆出一部分与 $ a[r]$无关的，用堆维护最小的 $ k $ 个即可。 Codeforces Round #347 (Div. 1) 663A,2A。给定一些形如$?+?-?+?+?=n,?-?-?+?=n $ 的表达式，最后一个数字为n，在前面填$[1,n]$的数，问是否满足条件的等式，可能输出“Possible“并给出一组解。 $ n \\leq 1000000 $ 构造。考虑怎样的等式能够满足条件，记增加的数的个数为 $ A $ ，减少的为 $ B $ 。若 $ A-nB \\leq n \\leq nA-B $ 则一定有解。于是每次一确定一个数，此时两边消掉这个数，得到新的 $ N $ ，同时 $ A $ 或 $ B $ 减一，只要新的 $ N $ 仍满足这个条件即可。 663B,1A。有一个 $ n $ 个点， $ m $ 条边的无向图。开始每条边的颜色都是给定的，玩家选择一个顶点，把相邻的边的颜色反转一下，问使得所有边颜色相同。最少反转几下，输出那些反转的顶点。只有两种颜色。 $ n,m \\leq 30000 $ 并查集。不失一般性，考虑将所有边的颜色改为蓝色。然后每一个点有选，或不选两种状态。逐个考虑每一条边，若这条边是红色的，则两个点的状态不同，否则这两个点的状态相同。 于是可以维护两个并查集即可。如何要保证最小？对于每一个连通块，一定被分为两个集合，只需要取其中较小的即可。注意将所有边改为红色也要尝试，因为对应并查集的合并方式不同。 CF663E,2A。有一个 $ n\\times m $ 的表格，包含0或1。每一次可以选择一行，或一列翻转(0&lt;-&gt;1)。求一些操作后，1的个数的最小值。 $ n \\leq 20,m \\leq 100000 $ 快速沃尔什变换。考虑 $ O(2^n\\times m \\times n)$的暴力，枚举每一行的状态，然后 $ O(nm)$统计。事实上，统计可以优化到 $ O(m)$，假设第 $ i $ 列的状态为 $ a[i]$，行的状态为 $ s $ ，于是第 $ j $ 列的个数即为$\\min(|a[j] \\oplus s|,n-|a[j]\\oplus s|)$。 $$\\large Ans[s] = \\sum _{i=1} ^m \\min(|a[j] \\oplus s|, n-|a[j] \\oplus s|)$$ 记 $$\\large v[i] = \\min(|i|, n-|i|)$$ 那么 $$\\large Ans[s] = \\sum _{i=1} ^m v[s\\oplus a[i]]$$ 令 $$\\large cnt[x]为a[i]=x的个数$$ 得到 $$\\large Ans[s] = \\sum _{i=0} ^{2^n-1} cnt[i] \\times v[s \\oplus i]$$ 发现就是异或卷积的形式： $$\\large C = \\sum _{j \\oplus k = i} A[j] \\times B[k]$$ 就可以用 $ FWT $ 啦。 VK Cup 2016 - Round 2 CF641B,1A。原来有一个 $ N \\times M $ 的矩阵，要求满足一些操作：某一行循环左移，某一列循环上移，给定某个位置的元素是什么，求出最初的矩阵。 $ n,m \\leq 100, Q \\leq 10000 $ 模拟。注意到一个性质，这些操作都是可逆的，所以我们只要倒着执行操作即可。 CF641C,1A。给定 $ n $ 个数， $ 1, 2, 3, 4, 5, 6,…, n $ 。有两种操作，第一个操作是所有数向右边移动x个位置。第二个操作奇数和偶数的位置互换。输出最后的数。n为偶数。 $ n \\leq 1,000,000, Q \\leq 2,000,000 $ 脑洞，模拟。如果仅仅只是暴力修改的话，时间复杂度将无法忍受。注意到一个性质，不管如何操作，奇数偶数都是间隔排列的，而且它们内部的顺序并不会发生改变。所以我们只需要维护 $ 1,2 $ 所在的位置即可。为了方便，可以令下标从 $ 0 $ 。 CF641D,1A。有两个不同的骰子，点数 $[1,n]$。得到每个点数的概率可能不同（总和一定是 $ 1 $ ）。掷出这两个骰子，得到点数 $ a,b $ 。取$\\max(a,b), \\min(a,b)$。给出$\\max(a,b)=c $ 的概率分布，和$\\min(a,b)=c $ 的概率分布。还原两个骰子点数的概率分布，所有概率之和为 $ 1 $ 。 $ n \\leq 100,000 $ 概率，数学。假设第一个骰子的概率分别为 $ x[i]$，第二个 $ y[i]$。考虑位置 $ p $ ，不难注意到， $ P(p\\ is\\ \\min)+P(p\\ is\\ \\max) = x[p]+y[p]$。而根据 $ 1 $ 是最大值的概率，得到 $ x[1] \\times y[1]$，能知道 $ x[1]$和 $ y[1]$。然后逐个处理每个位置 $ p $ 。根据 $ x[p] \\times \\sum _{i=1} ^{p-1} y[i] + y[p] \\times \\sum _{i=1} ^{p-1} x[i] + x[p] \\times y[p] = P(p\\ is\\ \\max)$ ，就可以推出所有的 $ x[p],y[p]$了，需要维护 $ x[],y[]$ 的前缀和。 CF641E,2A。有三种操作。 $ 1\\ x\\ y $ ，在第 $ x $ 秒插入一个 $ y $ 。 $ 2\\ x\\ y $ ，在第 $ x $ 秒移走一个 $ y $ 。 $ 3\\ x\\ y $ ， ，问第 $ x $ 秒有多少个 $ y $ 。 $ n \\leq 100000 $ map，树状数组。考虑首先离散化时间，以时间建立两个树状数组。维护区间时间内，删除和增加的元素个数。考虑到存在重复，所以可以用map维护。注意，虽然也可以用mulitset，但由于它的count复杂度为 $ O(n)$，会超时。 Codeforces Round #349 (Div. 1) CF666A,1A。给定一个字符串，这个字符串可以划分成最前面$[5, \\infty]$个字符，然后后面接着每次 $ 2 $ 个或 $ 3 $ 个，后面的相邻字符串不能重复，问所有可能的情况中，后面所有字符的集合是什么。 $ len \\leq 10^4 $ DP，set。由于只要满足相邻的字符串不重复即可，所以可以DP判断所有位置的可行性。把答案存入set，就可以保证不重复。 CF666C,4A。给定一个字符串 $ s $ 和 $ m $ 次操作。第一种操作，是将字符串 $ s $ 替换为一个新的字符串。第二种操作，给定 $ n $ ，询问长度为 $ n $ ，仅包含小写字母且 $ s $ 是其子串的字符串个数。 $ n,\\sum |s|&lt;=100000 $ 分块，DP。首先注意到一个性质，答案仅与字符串的长度有关。考虑如何求出只有一个字符串的情况。考虑 $ f[i]$表示母串长度为 $ i $ 时的方案数。于是， $$\\large f[i] = f[i-1] + C _{i-1} ^{len-1} \\times 25 ^{i-len}$$ 如何理解第二部分？事实上就是强制第 $ i $ 放最后一个 $ s[len]$然后前面的 $ i-1 $ 个位置任意选择 $ len-1 $ 个，强制每一个都是第一次出现，所以剩下的所有位置都有 $ 25 $ 种选择。 看上去复杂度不对？事实上，由于 $\\sum |s|&lt;=100000 $ ，所以不同的 $ len $ 最多有$\\sqrt{\\sum |s|}$个。复杂度 $ O(n \\sqrt n)$。 VK Cup 2016 - Round 3 CF643B,1A。给定 $ N,K $ 和 $ a,b,c,d $ ，问是否存在这样两条路径，使得这两条路径经过所有城市，并且从 $ a $ 到 $ b $ ，和从 $ c $ 到 $ d $ ，长度为 $ N $ ，整个边数不超过 $ K $ 。要输出两条路径，要满足 $ a $ 到 $ b $ 没有路， $ c $ 到 $ d $ 没有路。 $ 4≤n≤1000, n-1≤k≤2n-2 $ 构造。首先我们需要根据 $ a,b,c,d $ 是否存在重复来分类，对于每一类，我们需要图的边数尽可能少，这样的话，我们可以在中间构造一条链，然后两端是两个三角形。这样一定是最优的。 CF643C,1A。要求维护一棵树，支持以下两种操作：1、以某个节点为父亲，插入一个节点；2、询问对于以某个节点为根的子树，若子树当中每条边有 $ 0.5 $ 的概率被删除，那么整棵子树最大深度的期望值是多少。初始时，树中仅有一个节点。 $ Q \\leq 100000 $ 树形概率DP。考虑定义状态 $ f[i][j]$表示以 $ i $ 为根的子树，其最大深度不超过$j $ 的概率。于是， $$\\large f[i][h] = \\prod _{j \\in {son[i]}} 0.5 + 0.5 \\times f[j][h-1]$$ 如何理解这个式子？有 $ 0.5 $ 的概率新加入的边删去， $ 0.5 $ 的概率未删去，此时还要保证 $ j $ 的最大深度不超过 $ h-1 $ 。可以注意到，如果增加了一个节点，我们可以修改它所有的祖先节点。但由于改变量减少极快，所以经过 $ limit = 60 $ 次左右的更新，已经可以忽略不计。复杂度 $ O(n \\times limit)$ Codeforces Round #352 (Div. 1) CF671A,1A。有两个人独立地捡垃圾，求他们一起捡完所有垃圾所走的最短路程，从初始点找到第一个垃圾，然后送到垃圾桶，再从垃圾桶出发捡垃圾再送回。人，垃圾，垃圾桶都在二维坐标系中。一个人一次只能拿一个垃圾。 $ n \\leq 100000 $ 贪心。注意到，其他的垃圾到垃圾桶的距离和不变，只要第一次人拿垃圾的代价最小即可。 CF671B,1A。有 $ n $ 个数，和 $ K $ 次操作。每一次需要把最小的数$+1 $ ，最大的数$-1 $ 。求最后，最大最小的数之差。所有数相同后，不会再改变。 $ n,K \\leq 100000 $ 二分答案。我们可以二分出最小，最大的数。对于 $ K $ 较大的情况，只要判断总和是不是 $ n $ 的倍数即可。 Codeforces Round #353 (Div. 2) CF675E,1A。有 $ n $ 个火车站，第 $ i $ 个火车站能够到$[i+1,ai]$。令 $ p[i][j]$表示从 $ i $ 到 $ j $ 的最少次数。求$\\sum p[i]j$。 $ n \\leq 100000 $ 贪心，DP。令 $ f[i]$表示$\\sum p[i]j$，我们尽可能希望，通过走两次之后，能够到达的位置最远。假设这个位置是 $ m $ 。那么 $ f[i]=f[m]+n-i-(a[i]-m)$，如何理解？对于剩下的 $ n-i $ 个位置，有 $ a[i]-m $ 是可以通过一次转移到达的，否则都是在先走到 $ m $ 的基础上再走到别的点。 第二轮 _From 200 to 210_Codeforces Round #200 (Div. 1) CF343A。你有无限个阻值为 $ 1 $ 的电阻。需要组成(并联，串联)成一个 $ a/b $ 的电阻。求最少需要多少电阻。 $ a,b \\leq 10^{18} $ GCD。注意到，一个阻值为 $ a/b $ 的电阻，与 $ 1 $ 串联，得到 $ (a+b)/b $ ；与 $ 1 $ 并列，得到 $ a/(a+b) $ 。这个过程类似与GCD，只要求 $ \\gcd(a,b) $ 时加上 $ a/b $ 即可。 至于为什么这样是最优的，窝也不知道QAQ。 CF343B。有两条分别为红色，蓝色的线，波浪形排列（具体可以看原题）。在 $ n $ 处位置相交，给出每个位置是哪种颜色的线在上，问两条线能否解开。 $ n \\leq 10^5 $ 栈。考虑怎样的两条线能解开，只要存在”++”或者”–”，那么这两个位置的线可以分开。分开之后就可以删除了。整个过程用栈维护即可。 CF343C。一条水平的磁道上有 $ n $ 个磁头和 $ m $ 个待扫描的点，磁头可以左右互不干扰的移动去扫描点，每秒移动一个单位，求最少要花多少时间。 $ n,m \\leq 10^5 $ 二分答案，贪心。二分时间 $ T $ ，从左往右考虑每一个磁头。显然最左端的点一定是被当前的磁头去扫描，贪心地尽可能多选即可。注意一开始，磁头也可以先往右。 CF343D。给定一棵有根树。每个点的权值可以为 $ 0 $ 或 $ 1 $ 。有3种操作； $ 1,u $ 。 $ u $ 所在的子树所有点的权值赋为 $ 1 $ 。 $ 2,u $ 。 $ u $ 到根的链的所有权赋为0。 $ 3,u $ 。询问 $ u $ 的权。 $ n,m \\leq 5\\times 10^5 $ DFS序，树链剖分。树剖也可以做，不过比较优美的做法是DFS序+线段树维护。对于操作1，3，由于DFS序之后可以维护子树信息和节点信息，所以就没有问题。比较麻烦的是操作2，需要更新链的信息。 考虑用线段树维护子树内是否进行过操作2的清除标记。当进行过操作1后，如果 $ u $ 的子树有清除标记，那么把 $ u $ 子树的所有标记清空，同时，给 $ fa[u] $ 打上标记。对于操作3，只要判断 $ u $ 的子树中是否有标记即可。 注意因为一开始所有权值都为0，所以一开始需要对每个节点都打上标记。 Codeforces Round #201 (Div. 1) CF346A。给定 $ n $ 个数，有 $ A,B $ 两个玩家轮流操作。选择集合中的数 $ x,y $ ，如果 $ |x-y| $ 没有在集合中出现，则将 $ |x-y| $ 加入集合。无法进行操作的人输。 GCD。假设 $ g=\\gcd\\{ai\\} $ ，那么对于所有小于等于 $ \\max\\{ai\\} $ 的 $ g $ 的倍数，以后一定都能在集合中出现。只要判断当前未在最终集合出现的数的个数的奇偶性即可。 考虑为什么这个操作不会中断。对于每一种状态，通过类似辗转相减的方式，一定能操作。在某一刻一定能得到 $ g $ ，通过每个数和 $ g $ 相减就能填补完剩下的数。 CF346B。给定两个字符串 $ s1 $ 和 $ s2 $ ，以及一个病毒串 $ v $ 。求 $ s1 $ 与 $ s2 $ 的最长公共子序列，使得病毒串不是它的子串。 $ |s1|,|s2|,|v|&lt;=100 $ KMP，DP。其实这题挺套路的，一开始看错题了QAQ，怎么都和KMP联系不上。 其实我们只需要在原本经典 $ O(nm) $ 求 $ LCS $ 的算法之上，附加一维状态 $ [k] $ ，表示当前匹配到了病毒串的第 $ k $ 位。然后转移的时候根据 $ next[] $ 搞一搞就好了。 CF346C。给定一些数字 $ xi $ 。有两个数 $ a&gt;=b $ 。可以执行两种操作：令 $ a– $ ； 对于 $ xi $ ，令 $ a=a-a\\%xi $ ；求最少几次操作可以使得 $ a=b $ 。 $ b-a \\leq 1e6, n \\leq 10^5 $ 单调性，贪心，暴力，复杂度证明。非常巧妙的一道题。令 $ f(i) $ 表示从 $ b+i $ 变为 $ b $ 最少操作次数，不难注意到 $ f(i) $ 具有单调性，于是，我们需要贪心地使得每一次减少得尽可能大。看上去这个复杂度是平方级别的，事实上这个的复杂度只有 $ O(b-a) $ 。为什么呢？ 假设 $ x’ $ 是最大的 $ xi $ ，通过至多2次操作，我们就可以让 $ a $ 减小 $ x’ $ 。而不超过 $ x’ $ 至多有 $ O(x’) $ 个，所以每次 $ a $ 减小1是均摊 $ O(1) $ 的。为了防止复杂度退化，我们需要一开始就去重，同时对于操作后会令 $ a&lt;b $ 的 $ xi $ 要及时删除。 Codeforces Round #202 (Div. 1) CF348A。有 $ n $ 个人玩游戏，每轮需要 $ 1 $ 个主持人， $ n-1 $ 个玩家，给出每个人想当玩家的局数，求满足条件的最少局数。 $ n \\leq 10^5 $ 二分答案，贪心。二分需要玩的局数，对于一个人，我们可以让他玩到需要的局数，对于剩下的局数，全部都当主持，这样就可以判定了。 CF348B。给定一颗树，和所有叶子的权值。需要对于所有节点 $ u $ ， $ u $ 所有儿子 $ v $ 的权值都相等。一个节点的权值是所有叶子的权值之和。问最少减少多少叶子的权值。 $ n \\leq 10^5 $ GCD，树相关，贪心。考虑转化为最多保留多少权值。 考虑节点 $ u $ 和他的所有子节点 $ vi $ （共 $ k $ 个）。对于每一个字节点，首先求出至少保留多少权值，记为 $ f[vi] $ ，为了使 $ u $ 满足条件，所有子节点的权值都要变为 $ lcm\\{f[vi]\\} $ 。那么， $ f[u]=k\\times lcm\\{f[vi]\\} $ 。 之后再进行第二次DFS。记 $ s[i] $ 为当前 $ i $ 子树中的节点数，对于 $ u $ ，我们需要选取最小 $ s[v] $ ，把所有 $ s[vi] $ 都变成 $ s[v]/(f[u]/k)*(f[u]/k) $ 。DFS过程中记录删除的总和即可。 CF348C。给定一个包含 $ n $ 个数的数组 $ ai $ ，和 $ m $ 个集合 $ S1,S2,..,Sm $ 。每个集合包含若干下标 $ Sk,i $ 。有两种询问：对于集合 $ Sk $ ，求 $ S[k,i] $ 所对应的 $ a[S[k,i]] $ 之和。对于集合 $ Sk $ ，使得 $ S[k,i] $ 所对应的 $ a[S[k,i]] $ 都加上 $ x $ 。对于询问 $ 1 $ ，输出答案。 所有集合的大小总和不超过 $ 10^5 $ ， $ n,m,Q \\leq 10^5 $ 暴力，分块（分类？？），复杂度分析。考虑首先从暴力入手，复杂度是 $ O(n^2) $ 的（这里假设 $ n,m,Q $ 同阶）。 考虑暴力的复杂度瓶颈，是因为操作的集合非常大，考虑以 $ T=\\sqrt n $ 为界限分类解决。注意到一个性质，集合大小超过 $ T $ 的只有 $ O(T) $ 个。我们称大小超过 $ T $ 的为重集合，否则为轻集合。 首先我们要任意一个集合与每一重集合的交集大小，这个可以 $ O(n \\sqrt n) $ 解决。接下来考虑两类集合的四种贡献： 对于轻集合对轻集合的贡献，我们只需要暴力修改/查询即可。复杂度 $ O(\\sqrt n) $ 。 对于轻集合对重集合的贡献，我们只需要枚举每一个重集合，根据交集大小更新即可。复杂度 $ O(\\sqrt n) $ 。 对于重集合对轻集合的贡献，由于轻集合个个数太多了，所以可以在这个重集合上打上标记，同时在轻集合询问的时候计算贡献即可。复杂度 $ O(1),O(\\sqrt n) $ 。 对于重集合对重集合的贡献，暴力枚举重集合即可。复杂度 $ O(\\sqrt n) $ 。 Codeforces Round #204 (Div. 1) CF351A。给定 $ 2n $ 个实数，执行 $ n $ 次操作：选择两个未选择的位置 $ i,j $ ，使得 $ a[i] $ 向上取整， $ a[j] $ 向下取整。问变化前后的总和之差，最小为多少。 $ n \\leq 1000 $ 贪心。注意到一个性质，对于一个非整数 $ a $ ， $ \\lceil a \\rceil - \\lfloor a \\rfloor=1 $ 。假设其中存在 $ cnt $ 个整数。然后枚举向下取整的个数，取最大值即可。 CF351B。给定一个序列 $ a[] $ ， $ A $ 和 $ B $ 轮流进行操作：对于 $ A $ ，选择相邻的两个数 $ a[i],a[i+1] $ 并交换。（采用最优策略） 对于 $ B $ ，有 $ 1/2 $ 的概率，任意选择 $ i $ ，满足 $ a[i]&gt;a[i+1] $ 并交换；有 $ 1/2 $ 的概率，任意选择 $ i $ ，满足 $ a[i]&lt;a[i+1] $ 并交换；如果不存在这样的 $ i $ ，就 $ B $ 重新操作（步数 $ +1 $ ）。 如果序列变为增序，游戏结束。 $ A $ 希望游戏尽快结束，求结束游戏的期望步数。 $ n \\leq 3000 $ 逆序对，期望。注意到序列最终变为升序，逆序对为0，而交换相邻的逆序对可以使逆序对数量减一。于是我们只需要关注逆序对数量。推一发公式即可。 CF351C。给定 $ n,m $ 和长度为 $ n $ 的数组 $ ai,bi $ 。请构造一个长度为 $ nm $ 的匹配序列，如果第 $ i $ 个位置为’(‘，代价为 $ a[i\\%n] $ ，否则，代价为 $ b[i\\%n] $ 。求最小代价。 $ n \\leq 20,m \\leq 10^7 $ 动态规划，矩阵快速幂。首先可以证明一个结论：对于任何位置，未匹配的左括号数量一定不会超过 $ n $ （可以通过反证法，按照模 $ n $ 分类来证明）。注意到 $ m $ 非常大，所以不难想到矩阵快速幂，不过此处的矩阵为 $ floyd $ 矩阵。考虑用动态规划求出转移矩阵 $ T[i][j] $ ——从 $ i $ 个未匹配左括号到 $ j $ 个未匹配左括号的最小代价。 CF351E。给定一个长度为 $ n $ 的序列 $ a[] $ 。你可以对 $ a[] $ 中的一些数乘上 $ -1 $ ，使得序列 $ a[] $ 的逆序对个数最少。求逆序对个数的最小值。 $ n \\leq 2000 $ 脑洞，贪心。考虑到所有数都能变为相反数，所以一开始可以把所有数都变为正数。考虑一个逆序对中的绝对值较大数对答案产生贡献。如果位置 $ i $ 的数为正数， $ j&gt;i $ 且 $ a[j]&lt;a[i] $ 会对答案产生贡献，因为不管 $ a[j] $ 是否改变符号，都是一对逆序对； $ a[i] $ 改变后为负数同理。对于每一个 $ i $ ，只要加上较小的贡献即可。 Codeforces Round #206 (Div. 1) CF354A。给定长度为 $ n $ 的序列 $ wi $ ，参数 $ l,r,ql,qr $ 。对于每一次操作，可以删除左端的数字，代价为 $ wi\\times l $ 。如果上一次操作也是删除左端的数字，那么代价需要增加 $ ql $ 。删除右端的数字同理。求删除所有数字的最小代价。 $ n \\leq 10^5 $ 水。枚举左端删除的个数。为了使代价最小，所以需要交替从两端选取。 CF354B。给定一个 $ n\\times n $ 的字母矩阵。从 $ (1,1) $ 开始，每步往下或往右走，得到的任意长度字符串，称之为好串。 现在有两个人 $ A,B $ 玩一个游戏：一开始有一个空串， 轮流在字符串中添加一个字母，要求每次得到的都是好串，2n-1次后，游戏结束。如果a的个数比b的个数多，则A胜；反之，B胜。如果相等，为平局。假设A，B都以最优策略执行。游戏的结果。 $ n \\leq 20 $ 。 博弈，状压DP，记忆化搜索。 本题有一个坑点：不能用 $ f[i][j] $ 表示 $ (i,j) $ 到 $ (n,n) $ 的最优解，并以此来DP。 因为只要求是好串，不一定是矩阵上的路径，比如， bac dce aba 在位置 $ (1,3) $ 时，也能到达位置 $ (3,2) $ 。 同时注意到，对于第 $ i $ 步，一定是在第 $ i $ 条对角线上。而最多只有 $ n $ 个位置，可以考虑状压 $ DP $ ， $ f[i][j] $ 表示第 $ i $ 根对角线上的等价情况为 $ j $ 时，到达 $ (n,n) $ 。先手能比后手多得的分数的最大值。 通过位运算以简化代码。具体参见代码。 CF354C。给定一个长度为 $ n $ 的序列 $ ai $ 。可以减少其中的某些数，但是减少不能超过 $ k $ 。求修改后，所有序列的 $ gcd $ 的最大值。 $ n,k \\leq 10^6 $ 暴力，调和级数，前缀和。一个直观的想法就是暴力枚举GCD，同时判断每个数是否能变成GCD的倍数，复杂度为 $ O(nk) $ 。瓶颈出现在第二步，考虑如何优化。 对于一个GCD的倍数 $ x $ ，对于 $ [x,x+k] $ 内的数都是满足条件的。也就是说我们求出所有在区间内的数的个数之和，如果就是 $ n $ ，那么这个GCD是满足条件的。由于调和级数，时间复杂度 $ O(k\\log k) $ 。 CF354E。给定一些数 $ n $ ，求是否能表示为6个数之和，每个数仅由4或7构成。 $ T \\leq 5000,n \\leq 10^{18} $ 暴力。注意到4或7在哪个位置并没有关系，只要枚举每一位4或7的个数即可。 Codeforces Round #207 (Div. 1) CF356A。有 $ n $ 个骑士进行 $ m $ 轮PK。对于第 $ i $ 论， $ xi $ 站在台上，将 $ [li,ri] $ 的骑士都打败。如果一个骑士被打败，就出局。输出每个骑士是被哪个骑士打败的。胜利者输出0。 $ n \\leq 3\\times 10 ^5 $ Set。用set维护未打败的骑士集合，每次lower_bound和upper_bound找出区间。由于每个只会被删除一次，所以复杂度为 $ O(n\\log n) $ CF356B。给定 $ n,m $ ，和两个串 $ x,y $ 。由 $ x $ 重复出现 $ n $ 次得到串 $ a $ ，由 $ y $ 重复出现 $ m $ 次得到串 $ b $ 。问存在多少个 $ i $ ，满足 $ a[i]\\not =b[i] $ 。 $ n,m \\leq 10^{12},lenX,lenY \\leq 10^6,n\\times lenX = m\\times lenY $ GCD。注意到我们只需要考虑 $ lcm(lenX, lenY) $ 的答案。令 $ g=\\gcd (lenX, lenY) $ 。 注意到对于 $ i,j $ ，当且仅当 $ i \\equiv j \\pmod g $ ， $ x[i],y[j] $ 才有可能产生贡献。同时，注意到 $ \\gcd (lenX/g, lenY/g)=1 $ ，也就是说 $ x[i]=y[j] $ 时，恰好在 $ lcm $ 中出现一次。 Codeforces Round #210 (Div. 1) CF360A。有一个长度为 $ n $ 的数组 $ ai $ ，两种操作： $ 1,l,r,d $ ，令区间 $ [l,r] $ 内的数增加 $ d $ 。 $ 2,l,r $ ，询问区间 $ [l,r] $ 内的最大值。 现在给定所有操作，和询问 $ 2 $ 的结果。请还原数组 $ ai $ 。 $ n,m \\leq 5000 $ 贪心，模拟。考虑时光倒流，倒序处理所有询问，于是我们可以得到每个位置初始的最大值。于是我们再对这些初始数进行模拟，如果能完全符合回答的，则一定可以，否则一定不存在。 为什么说，不符合就一定不存在呢？因为我们一开始求出的是最大值，如果不符合，那么一定是没有达到最大值。如果再使得初始的序列变小，肯定也会不符合。 CF360B。给定一个长度为 $ n $ 的数组 $ ai $ ，可以修改至多 $ k $ 个数。令 $ c(a)=\\max(|a[i+1]-a[i]|) $ ，求 $ c(a) $ 的最小值。 $ n,K \\leq 2000 $ 二分答案，DP。首先显然需要二分答案，通过DP来判定。 一种比较套路的定义方式为，定义 $ f[i] $ 表示，以第 $ i $ 个数结尾且不改变时，相邻绝对值都不超过 $ limit $ 的最小操作次数。转移的时候，只需要枚举上一个不改变的数 $ j $ ，只要满足 $ |a[i]-a[j]|&lt;=limit*(i-j) $ 就能转移。 CF360C。给定一个长度为 $ n $ 的字符串 $ s $ 和 $ K $ 。一个字符串 $ t $ (长度为 $ n $ )的美丽度定义为：存在多少对 $ i,j(i s[i..j] $ (以字典序比较)。求存在多少字符串的美丽度为 $ K $ 。 $ n,K \\leq 2000 $ DP好题，前缀和优化，调和级数。很好的DP题啊，我太弱了，抄一波官方题解。。 首先考虑 $ t $ 确定时， $ t[i] $ 与 $ s[i] $ 对答案的贡献。 若 $ t[i]&lt;s[i] $ , $ 0 $ 若 $ t[i]&gt;s[i] $ , $ n-i $ 若 $ t[i]=s[i] $ , 找到最小的 $ k(k&gt;i) $ 满足 $ t[i]\\not =s[i] $ 若 $ t[k]&lt;s[k] $ , $ 0 $ 若 $ t[k]&gt;s[k] $ , $ n-k $ 也就是说，若 $ t[i]&gt;s[i] $ ，对答案贡献了 $ (pre+1)(n-i) $ 。其中， $ pre $ 是 $ s[1..i-1], t[1..i-1] $ 的最长公共后缀。 $ f[i][sum] $ 表示 $ s[i]\\not =t[i] $ 时，前 $ i $ 个对答案贡献 $ sum $ 的方案数。(如果 $ s[i]=t[i] $ ，则枚举 $ pre $ 时得到错误的贡献，正是状态定义精妙之处)，枚举 $ pre $ 进行转移，于是有： 当 $ t[i]&lt;s[i] $ 时， $ f[i][sum]+=f[i-1-pre][sum]_(s[i]-‘a’) $当 $ t[i]&lt;s[i] $ 时， $ f[i][sum]+=f[i-1-pre][sum-(pre+1)_(n-i)]*(‘z’-s[i]) $ 前一部分可以通过前缀和优化，而对于后面一部分， $ pre $ 枚举量为 $ O(k/1+k/2+..+k/k)=O(k \\log k) $ 。所以，总的时间复杂度为 $ O(k(n+k log k)) $ 。 第三轮 _2013 集训队作业_ 手残选手来泛做一波Codeforces啦。。 （其实就是因为看到了许昊然的成套题解 既然有题解了嘛，那我也就懒得写啦。。 这里记录一些有趣的想法。 7E 根据四则运算的结合律，优先级，来简洁地表示状态。 15E 很不错的递推题，关键是找到阶段，以及合理地分类讨论。 19E 图的 DFS树 ，根据 返祖边 搞搞。二分图，环的奇偶性。 30E 各种子串拼接/回文都是套路，反向串匹配、KMP、manachar，ExKMP。 36E 四个奇点，两条互不重合的欧拉路径？连接两个奇点，再断开。 46F 最大表示法 思想。观察到操作是可逆的，于是令两个状态达到极大/极小的等价状态。 51F 巧妙的边双，缩点完之后变成一棵树。各种 树形DP/dfs序/树剖。。 53E 状压DP，强制顺序。这种防止重复计数的trick应该很套路了吧。。 67C 奇怪的性质带来了无后效性，毒瘤-&gt;傻逼DP。 70E 又是一类奇妙的附加状态。涉及到与子树外节点的关系，附加这一维状态。 193D 超赞的线段树 。离线，从差分角度考虑贡献。利用 正 整数 $\\leq 2$ 的一定是最小值/次小值，避免了分块。 193E 斐波那契数在模 $10^x$ 意义下，循环节为 $1.5 \\times 10^x (2 \\leq x)$。 76F DP条件的转化。变成二维数点之类的东西，然后离线/数据结构。 76A 动态加边MST。只有原有的边和新加入的边有用，边数 $O(n)$，暴力插入排序即可。 77E 圆的反演。一个圆关于单位圆反演之后，会得到一条直线（圆经过原点），或是另一个圆。相切的关系不变。简单的初中几何知识就可以了。。有意思的 79D 区间修改相关嘛。。考虑异或的 前缀和/差分 转化，区间转单点。一波分类讨论贪心后，转化为图论模型，直接状压DP。 81E 基环外向树DP。一般套路：先外向树DP，再在基环上 序列/区间 DP。但此题呢，可以利用基环的相邻两边至多选择一条的性质，直接两次树形DP。 164D 对于存在各种 互斥/.. 关系，只能染2种颜色，果断二分图。 101E 奥妙重重的分治，减少空间复杂度（加大时间复杂度 113D 对于多个线性方程组，只有右边的向量不同，放在右边一起消元。 115D 表达式DP，一般的想法是区间DP，可是有很多状态是无用的（就像树形DP）。考虑附加的状态是前缀左括号数量。 125E 限制点 $1$ 度 $=K$ 的MST。二分偏差值 $delta$ ，与 $1$ 相连的一边加上这个偏差值，然后直接MST（用两个指针就不用重复排序了）。如果出现两条特殊边与其他边的边权相同，可能永远无法到达 $K$ ，比较好的一个做法是加入一个随机的抖动值。 140F 最多增加 $K$ 个点使得点集对称，按照 $x$ 优先排序，那么两端的各 $K+1$ 个点中，任意一个配对方案都能对应到这两个点配对，从两端暴力扫描即可。 147B 期望的线性性，从另一个角度表示贡献。同时利用单调性，只有在需要的时候计算。 217E 倒着思考，舍弃无用的量。树状数组倍增。 135E 主要是找到一个神奇的性质：选出的一定是前缀/后缀。那么分类讨论，组合数算一下就好了。 163D 利用不等式给爆搜剪枝，这里利用了均值不等式。 178F 比较妙的题。LCP嘛，考虑建出Tire，然后直接树形背包DP。但是这样点数是 $O(n^2)$ ，于是我们可以像后缀树那样压缩点（若干个连续点只有一条出边），因为有用的就是这条边的长度，点数就是 $O(n)$ 。然后树形背包DP，复杂度 $O(n^2)$ ，复杂度 $O(n^2)$ ，复杂度 $O(n^2)$ ！ 以前这种树形背包DP的数据范围都是 $300$ ，我也一直以为是 $O(n^3)$ 的 QwQ，那么来强行口胡一下证明： 设 $T(n)$ 就是规模为 $n$ 的复杂度，于是 $T(n)=T(s)+T(n-s)+s(n-s)$ ，我们要证明 $T(n) \\leq n ^ 2$ 。 显然有 $T(1) = 1$ 。假设对于 $k \\leq n-1$ ，有 $T(k) \\leq k^2$ 。 当 $k=n$ 时 $T(k) = T(k-s) + T(s) + s(k-s) \\leq (k-s)^2 + s^2 + 2s(k-s) = k^2$。 就是一个简单的数学归纳法嘛.. 187D 有些情况（最简单的单点修改，区间最值）下可以用 set 代替线段树，还不用 离散化/动态开点。 176E 有用的神结论：考虑一个树上 $k$ 个点 $v_1,v_2,…,v_k$ （DFS序递增）的导出子图，边权之和为$\\large \\frac {(d(v_1,v_2)+d(v_2,v_3)+…+d(v_{n-1},v_n)+d(v_n,v_1)} 2$ ，就变成了裸题。 200A 在网格上，覆盖了 $K$ 个点之后，任意一个点到未被覆盖的点的最近距离为 $O(\\sqrt K)$ 。并查集的经典应用：滋瓷删除点，求出每个点未被删除的前驱/后继。 207A 已经有序的序列可以通过归并排序合并，为这道题的构造提供了方向。 第四轮 _???_#001 2016-2017 ACM-ICPC, NEERC, Moscow Subregional ContestA,B,F,G，签到。K，克鲁斯卡算法。L，期望，用线段树维护，或者倒着处理。H，模拟。E，DP，输出方案。 I. 交互题。给定 $n$ ，系统生成了两个数 $0 \\leq x0 &lt; m \\leq n（n \\leq 10^{18}）$。 第 $i$ 次询问，你可以给出一个数$ai$ 。那么 $x[i]=(x[i-1]+ai)\\%m$ 。系统会返回 $x[i]$ 与 $x[i-1]$ 的大小关系。求 $x0，m$ 的值。不能有超过 $2016$ 次询问。 交互，倍增。 首先感谢r爷，赐予我神奇的题解Orz。 基本思路： 考虑先搞出 $m$ ，同时，我们统计累加的 $a$ 之和，就可以得到 $x0$ 了。 方便处理，我们用以下一段代码来询问：如果爆出来了，就返回 $1$ 。 123456int ask(LL a) &#123; tot2 += a; tot1 += tot2 / MOD; tot2 %= MOD; printf(\"%I64u\\n\", a); fflush(stdout); getchar(); char ch = getchar(); return ch != '&gt;';&#125; 关键性质： $+a$ 爆出去后的值 $\\in [0, a)$ 。 任意时刻只要 $a \\leq m$ ，就不会套圈，而影响判断。所以我们要一直做到 $a \\leq m$ 。 具体步骤： 首先搞出一个 $step$ ，不超过 $m$ ，但又不至于太小。考虑倍增，依次加 $2^0,2^1,2^2,…$ 。直到第一次爆出去。然后再依次倍增，直到又爆出去。两个取 $\\max$ ，就会得到 $m$ 的级别 $step$。此时，$step$ 不会小于四分之一的 $m$ 。 123s1 = 1; while (!ask(s1)) s1 += s1;s2 = 1; while (!ask(s2)) s2 += s2;step = max(s1, s2); 考虑每一次 $+step$ ，同时令 $ M+= step$ ，直到第一次爆出去。 此时 $x[i] \\in [0,step)$ ，可以发现 $x[i]+M-step$ 一定不会爆出去（因为 $M &lt; m$ ，所以这个值也小于 $m$ ）。 之后 $step /= 2$ ，就可以逐步缩小 $x[i]$ 的范围。但是如果是 $step$ 为一步慢慢跳，显然询问次数会爆炸。所以直接可以跳 $M-step$ （上面的结论）。 直到 $step = 1$ ，此时 $x[i] = 0$ 。那么重新跳一遍就可以得到 $m$ 的值。 于是代码如下： 12345678910while (step) &#123; bool flag = 0; while (!ask(step)) m += step, flag = 1; if (flag) m -= step; if (m &gt; 0) ask(m); step &gt;&gt;= 1; &#125;while (!ask(1)) m++; m++;x = (m - (MOD % m * tot1 + tot2) % m) % m;printf(\"0 %I64u %I64u\\n\", x, m); #002 Bubble Cup 8 - Finals [Online Mirror]B,D,F,H签到。 A. 定义一个序列 $F_n$ 。满足 $F_n=s_{n-1}F_{n-1}+s_{n-2}F_{n-2}, F_0=0, F_1=1$ 。 其中 $s$ 是一个近乎循环序列。给定 $N$ ，同时给出 $s_0,s_1,s_2,…,s_{n-1}$ ，满足 $s_i=s_{i \\bmod n}$ 。同时存在 $m$ 个特殊位置，$si$ 的值是给定的。求 $F_K \\bmod P$ 的值。 线段树维护矩阵。 显然，我们可以预处理 $s_0,s_1,s_2,…,s_{n-1},s_0$ 构成的转移矩阵 $S$ 。然后，对于改变的 $si$ 的值，只会影响两个矩阵。对于每一个周期，会影响的也至多只有 $2m$ 个，记为 $E_1,E_2,…,E_t$ 。 最终的转移矩阵类似于 $S \\cdot S \\cdot E_1 \\cdot S \\cdot …\\cdot E_2\\cdot S\\cdot…$ 。中间的可以利用快速幂，时间复杂度 $O(m \\log K)$ 。考虑如何计算 $E_i$ ，显然我们需要计算一段矩阵的乘积，线段树维护即可。 总的复杂度 $O(m \\log K + m \\log K)$ 。 C. 爆搜+匈牙利算法。直接这样是 $O(\\binom n {n/2} n^3)$ 的，可以减少一个 $n$ 。未理解。 E. 求 最大 的一个圆，能够覆盖所有斜放的正方形（都是整点）。要求这个圆经过三个顶点。求这三个顶点。 计算几何。 一眼看 最小 圆覆盖，于是跑去学算法，想法还是很高明哒。。套在这题当然是萎的。。（你怎么又看错题了。。 考虑首先求出凸包。然后选择的三个点一定是凸包上相邻的，否则显然有更优的方案来代替。 然后求外心，就，，没了。。。 F. 存在 $O(n)$ 的贪心做法。维护当前答案的可行区间。 G. 给定一个带权无向图，每条边的代价为边权/当前速度，每次到达一个新节点，速度都会除以$10$ 。求 $1$ 号点到 $n$ 号点的最小代价，如果多解输出点数最少的解，输出代价、路径点数、路径经过的点。$1 \\leq n,m \\leq 10^5, 0 \\leq w \\leq 9$ 基数排序，贪心，BFS。 首先，如果存在到终点距离为 $0$ 的点，可以额外处理。否则选越短的路径越好，而路程的距离相当于边的权值构成的十进制数，我们考虑从高位贪心。 具体可以预处理出到起始点的距离，按照层来处理，再基数排序。 I. 有一个正方形区域，要求支持两个操作：1、放置等腰直角三角形，给定放置方向（有4个方向，直角边与坐标轴平行），直角顶点坐标，边长。2、查询一个点被覆盖了多少次。 $1 \\leq n \\leq 5000,1 \\leq Q \\leq 10^5$ 树状数组，坐标转换。 #003-8VC Venture Cup 2017A,B,C签到。E高精度+DP，F代码题。 D. 考虑这道题的一个性质，每一个单独的元素看成一个区间。每一次操作就相当于移动左边界或者右边界。很重要的一个性质就是：相对位置不变，只是长度改变。考虑预处理 $Next[i][j]$ 数组。表示从第 $i$ 个位置开始的下一个 $j$ 的位置。然后DP，$f[i][j]$ 表示填充了前 $i$ 个位置，最后一个位置是原来的第 $j$ 个元素。然后枚举下一个字母 $k$ 转移即可。 考虑优化，我们搞一个辅助数组 $g[]$ 和 $sum$ 。$sum$ 用来动态维护答案，$g[s[j]]$ 用于保存当前以 $s[j]$ 结尾的 $g[i][j]$ 。每一次循环的时候，$sum = sum + f[i-1][j] - g[s[j]-‘a’]$， 同时令 $g[s[j]-‘a’] = f[i-1][j]$。表示之后如果通过 $s[j]-$a 来转移，就要从新的位置转移过来。 #004-Codeforces Round #372 (Div. 1)A签到。C点分治，E奇怪的图论+DP+FFT？ B. 给定一个带权无向图，有若干条边权未知，构造出一种方案使得最短路为 $L$ 。 考虑首先令每一条未确定边的边权为 $1$ ，跑一遍Dij，如果最短路不小于 $L$ ，显然没救了。 假设当前最短路与 $L$ 相差 $need$ 。考虑再一次跑Dij，需要令 $dist2[u]$ 尽可能等于 $dist1[u]+need$ （每次更新时，如果能放大，就尽量放大）。最后检查 $dist2[t]$ 是否满足要求即可。 D. 需要你构造一个 $n \\times m$ 的方格，每条边都可以设置障碍，只能向右/下走，使得从 $(1,1)$ 到 $(n,m)$ 的方案数为 $T$ 。 按照进制分解，逐步构造。 题解 #005-AtCoder Regular Contest 090A，B，签到。C，最短路计数，特殊的容斥（每个元素至多属于两个集合）。 D. 定义 $f(n)$ 为 $n$ 的位数，问存在多少对 $(l,r)$ ，使得 $\\sum _ {i=l} ^{r} f(i) = S$ ？ $S \\leq 10^8$ 分类讨论。 考虑这样一个性质，当 $l \\geq 8$ 时，$r = l+1\\ or\\ l$ 。于是我们可以对 $l$ 分类。（注意这里的 $l,r$ 指的是位数） 首先是 $l \\leq 7$ 的情况，考虑预处理 $F(n) = \\sum _{i=1} ^{n} f(i) $ 。我们用双指针滑一下就好了。 对于其他情况。当 $l=r$ 时，枚举 $S$ 的因数，就是符合答案的 $l$ 。 当 $r = l + 1$ 时，就是要算出 $lx+ry=S$ 的正整数解个数，注意到 $l,r$ 是互质的，于是有： $$x = x_0 + kr \\geq 1$$ $$y = y_0 - kl \\geq 1$$ 转化为关于 $k$ 的不等式组，求 $k$ 的整数解个数即可。 如何求 $x_0,y_0$ ？ExGCD ？显然要 T，发现 $y_0 = S \\bmod l$ 就是一个可行解。当然这种做法会因为常数过大而超时。 更好做法是直接求出 $x_{\\min}, x_{\\max}$ ，剩下的留给大家思考。 （参考自zyy的代码，虽然我没有看懂，但是还是给了我启发。。可以参考我的代码？） #006-2015-2016 ACM-ICPC, NEERC, Southern Subregional ContestA,B,D,F,I,J，签到。G，主席树。C，递归处理，折半。 K，性质，暴力。H，构造，随便搞一棵生成树，然后贪心。 专题训练数论 CF222C 给出两个集合，第一个集合数的乘积是分子，第二个集合的数的乘积是分母，要求够造一个同样大小的集合，但是得到的分数是化简过的。$1≤n,m≤10^5,ai,bi \\leq 10^7$ 质因数分解，构造。考虑首先筛出$10^7$内的所有素数，然后对所有数质因数分解。最后暴力消除即可。为了保证一定能存在答案，只需要在原来数的基础上消除即可。 CF446C 给定$n$个元素的数组$a[]$。操作$1, l, r$。要求对于$l \\leq i \\leq r$，$a[i] += f[i-l+1]$。询问$2,l,r$。返回$\\sum_{i=l}^{r} a[i]$，对$10^9+9$取模。其中$f[i]$为斐波那契数列，$f[1]=1,f[2]=1$。$n,m \\leq 300000$ 斐波那契数列，线段树维护等比数列。本题似乎无从下手，因为每一个数增加的值不同。事实上，我们可以利用斐波那契数列的的通项公式（可以用母函数证明，是线性常系数其次递推关系，可窝不会）。 $$\\large fib(i) = \\frac {1} {\\sqrt{5}} \\left( \\left(\\frac {1+\\sqrt{5}} {2}\\right)^n + \\left( \\frac {1-\\sqrt{5}} {2} \\right)^n \\right)$$ 令 $\\large q1= \\frac {1+\\sqrt{5}} {2}, q2 = \\frac {1-\\sqrt{5}} {2}$，于是我们只需要维护两个等比数列即可，由于公比是 $q1,q2$ 不变，所以直接利用等比数列求和即可，用线段树维护区间和。注意，本题需要得到 $q1,q2$ 在模意义下的值，只需要暴力算出 $\\sqrt5$ 即可。 顺便提一下，我们需要利用等比数列求和公式 $\\large \\frac {q^n-1} {q-1}$ ，但是本题中 $q1,q2$ 满足 $q^2-q-1=0$，就是说 $rev(q-1)=q$，原来的公式就变为了 $q^{n+1}-q$，足以见得斐波那契数列的神奇。 CF711E,2A。给定 $n,k$，已知一年有 $2^n$ 天，选取 $k$ 个人，两个人的生日是在同一天的的概率。要求答案写成最简分数。$n,k \\leq 10^{18}$ 欧拉定理降幂，组合相关。首先需要特判一个情况，就是 $k&gt;2^n$ 概率就是 $1$。从反面情况入手，总共生日的方案数为 $A=2^{nk}$，所有人的生日互不相同的情况为 $B=A_{2^n}^{k}$。答案即为 $\\large \\frac {A-B} A$ 。注意到，$A$ 的质因数仅有 $2$，所以我们需要知道$B$中质因数$2$的个数即可。考虑其展开式， $$\\large B = A_{2^n}^k = 2^n \\times (2^n-1) \\times (2^n-2) \\times … \\times (2^n-k+1)$$ 首先，$2^n$ 中有 $n$ 个，然后若存在 $2^n-a2^b(b&lt;n)$ ，那么显然这一项含有 $b$ 个质因数$2$，所以我们只要统计 $(k-1)!$ 的质因数 $2$ 的个数即可。 但是 $A=2^{nk}$，指数过大，应该如何处理。考虑降幂大法，欧拉定理： $$\\large a^{\\varphi(m)}\\equiv a^{0} \\pmod m$$ 所以指数对 $\\varphi(m)$ 取模即可。 CF121C,1A。对于一个数，如果它仅包含 $4$ 或 $7$，则称之为幸运数。求 $[1,n]$ 的第 $K$ 个置换，有多少幸运数位于的位置也是幸运数。$n,k \\leq 10^9$ 观察，求第$K$排列。注意到 $k$ 很小，当 $n&gt;=14$ 时，最前面的 $n-13$ 位是不发生改变的。而且 $10^9$ 内的幸运数只有 $1023$ 个，所以，对于前面的数字，我们暴力计算，后面的，暴力求出第$K$排列即可。 CF772C,1A。给定 $m$ 和 $n$ 个整数 $ai(0 \\leq ai \\leq m-1)$，请您构造一个最长的序列，满足对于所有前缀积对 $m$ 取模，它们互不相同，且不等于任意一个$ai$。$n,m \\leq 200,000$ GCD，DAG最长路。考虑最后一个数与 $m$ 的 $\\gcd\\ t$，可以注意到，这个数通过乘与$m$ 互质的数，可以得到任意一个与 $m$ 的 $\\gcd$为$t$。同样我们也可以乘上一个与 $m$ 不互质的数，得到与 $m$的 $\\gcd$为 $kt$ 的数。DP得到最长路后，dfs输出答案即可。 考虑证明这一点。其中$kax \\equiv bcx \\pmod m$，$x$ 是原来最后一个数与 $m $的 $gcd$（所以 $a$ 与 $m$ 互质），$cx$ 是新的 $gcd$，由乘上一个 $k$ 得到。然后 $ka \\equiv bc \\pmod {\\frac m x}$ ，因为 $a$ 与 $m$ 互质，所以一定存在 $k$。 CF396B,1A。定义函数 $v(n)$ 为不大于 $n$ 的最大素数。定义函数 $u(n)$ 为大于 $n$ 的最小素数。求 $\\large \\sum \\frac 1 {v(i) \\times u(i)}(2 \\leq i \\leq n)$。$T \\leq 500,n \\leq 1e9$ 裂项，素数判断。思路很巧妙，考虑到， $$(u(n)-v(n)) \\times \\frac 1 {v(n) \\times u(n)} = \\frac 1 {v(n)} - \\frac 1{u(n)}$$ 所以我们就可以裂项相消了，于是， $$Ans = 1/2 -1/3 + 1/3 - 1/5 + …….. -1/v + \\frac 1 {v\\times u\\times (n-v+1)}$$ 消掉，约分即可。 CF283D。对于 $(x,y)$ ，如果满足 $x$ 可以表示为连续 $y$ 个整数之和，则它是酷的。如果$(a1,a2),(a2,a3),..,(an-1,an)$ 都是酷的。那么整个序列就是酷的。给定长度为 $n$ 的序列，求最少改变几个数字，使得整个序列是酷的。$n \\leq 5000$ 数论，动态规划。首先考虑 $(x,y)$ 符合要求的条件，根据等差数列求和公式，可以知道：当 $y$ 为奇数时，只要 $x$ 是 $y$ 的倍数；当 $y$ 为偶数时，只要 $2x$ 是 $y$ 的奇数倍即可。观察第二个条件，也就是说 $x$ 质因数 $2$ 的个数比 $y$ 质因数 $2$ 的个数少 $1$，对于其它部分 $x’$ 是 $y’$ 的倍数。受此启发考虑令 $a[i]=2^{x[i]}\\times y[i]$，以方便状态的转移。 定义 $ f[i] $ 表示 $ i $ 是不变的，以 $ i $ 结尾的序列，需要满足条件，可以不改变的最长子序列。于是对于一个状态 $ i $ 我们寻找 $ j $ 同样是不改变的。 如果 $ a[i] $ 是奇数( $ x[i]=0 $ )，且 $ y[j] \\bmod y[i] = 0 $ ，则 $ f[i] $ 可以由 $ f[j] $ 转移过来 如果 $ x[i]!=0 $ ，条件就比较复杂。首先 $ y[j] \\bmod y[i] = 0 $ 是一个必要条件，接下来考虑 $ x[i] $ 与 $ x[j] $ 考虑 $ x[i] $ 向前移动，如果向前移动一位，则 $ x $ 必定会减一，于是会出现两种情形。 一是 $ x $ 还没有到 $ j $ 已经变为了 $ 0 $ （也就是 $ x[i]&lt;i-j $ ），变为了奇数，一定能够在最后一次变为 $ x[i] $ 。 二是 $ x $ 到 $ j $ 时仍然不是 $ 0 $ ，这就要求 $ x=x[j] $ ，也就是说 $ x[i]-x[j]=i-j $ 。 至此，问题得到完整的解决。注意一点，我们可以在序列的最后增加一个数 $ 1 $ 使得之前所有状态的答案会聚到这一状态。 CF172D。给定 $ a,n $ ，求 $ [a,a+n-1] $ 所有数的贡献总和。一个数的贡献是其除掉所有平方因子后的部分。 $ n \\leq 10^7 $ 莫比乌斯函数。考虑求出 $ [1,x] $ 的贡献，考虑首先 $ O(\\sqrt x) $ 枚举所有平方因子 $ p^2 $ 。于是我们就需要知道 $ [1,\\frac x {p^2}] $ 中不是完全平方数的倍数的数之和，于是可以 $ O(\\sqrt {\\frac x {p^2}}) $ 的容斥求出答案，容斥的系数就是莫比乌斯函数。复杂度 $ O(n) $ 。 CF451E。有 $ n $ 种颜色的❀，第 $ i $ 种❀有 $ fi $ 朵。求选出 $ s $ 朵❀的不同方案。 $ n \\leq 20,s \\leq 10^{14},fi \\leq 10^{12} $ 容斥原理，卢卡斯定理。考虑如果有 $ a $ 种颜色，选 $ b $ 朵，那么方案数就是 $ C(a+b-1,b) $ 。但是本题中❀数量的限制，所以考虑容斥。答案即为至少0个超过-至少1个超过+至少2个超过-…。 比如至少1个超过的是 $ i $ ，那么我们强制选择 $ i $ 所有的❀。组合数的计算可以利用卢卡斯定理。 CF448E。给出一个 $ x,k $ ，每次操作都会将 $ x $ 分解因数，得到新的序列，然后每次再分解序列中的每一个数，按照每一个数分解因数从小到大排，整体顺序不做调整。 $ x \\leq 10^{12}, k \\leq 10^{18} $ DFS+剪枝。为了加速分解，我们可以预处理 $ x $ 的所有因数。DFS(x,k)表示将 $ x $ 分解 $ k $ 次，只要枚举 $ x $ 的因数，如果可以整除继续DFS，如果超过 $ x $ 直接跳出。加了这个优化以后就很快了。 CF216E。给定一个进制 $ k $ 和一位数 $ b $ 。以及长度为 $ n $ 的序列（均小于 $ k $ ）求这个序列存在多少子序列，能通过变换变为 $ b $ ？这里的变换指的是，每次将k进制数x的每一位相加（k进制加法）得到一个新的数 $ x’ $ ，直到最后得到一个一位数。 $ 0 \\leq b&lt;k \\leq 1e9, n \\leq 100000 $ $ k $ 进制下模 $ k-1 $ 的性质。注意到一个性质：对于一个 $ k $ 进之下的数，模 $ k-1 $ 后的余数等于，各个数码之和模 $ k-1 $ 的余数。考虑用 $ ans[i] $ 表示前 $ i $ 个数之和模 $ k-1 $ 后的余数，若满足 $ ans[i]-ans[j-1] $ 模 $ k-1=b $ 则 $ [j,i] $ 是符合答案的，于是在扫描过程中记录一个数组 $ cnt[i] $ 表示 $ ans[j] \\mod k-1=i $ 的 $ j $ 的个数。注意特殊处理 $ b=0,k-1 $ 的情况。 CF703E。给定 $ n,k $ ，和 $ n $ 个数 $ a[] $ 。求任意一个最短的序列 $ \\{i\\} $ 满足 $ a[i1]\\times a[i2] \\times … \\times a[im] $ 是 $ k $ 的倍数。输出方案，当存在多种方案时，选择 $ \\sum i $ 最小的序列。 $ n \\leq 1000,k \\leq 10^{12} $ 。 GCD,动态规划。考虑到对于一个 $ 10^{12} $ 数量级的数，其因数个数不超过 $ 10^4 $ ，而且本题中 $ a[] $ 是否满足条件是其乘积与 $ k $ 的GCD决定的。首先，预处理出所有 $ k $ 的因数 $ d[] $ ，定义状态 $ f[i][j] $ 表示前 $ i $ 个数中，乘积与 $ k $ 的GCD为 $ d[j] $ 所需要选择的最少数字。按照 $ i+1 $ 是否选择转移即可。 组合数学 CF57C。给定 $ n $ ，求存在多少长度为 $ n $ 的序列满足：所有数在 $ 1 $ 到 $ n $ 之间，这个序列是非递增或非递减的。 $ n \\leq 100000 $ 组合数的格路模型。不失一般性，我们考虑序列是非递减的方案数。可以注意到，假设最后一个数字是 $ n $ ，其等价于从 $ (0,0) $ 走到 $ (n-1,n-1) $ 的方案数。为什么呢？我们可以把向右走看作是到下一个数，向上走可以看成是当前位置的数 $ +1 $ ，并且，序列的数是非递增的。最后一个数可以是 $ [1,n] $ ，同理求出。 CF689E。给定 $ n $ 和 $ K $ ，然后给定 $ n $ 个区间，在 $ n $ 个区间中选择 $ K $ 个，求它们的交集总和。 $ n \\leq 100000 $ 离散化，贡献。本题似乎难以直接穷举所有的情况，考虑离散化，并计算每一条线段被多少个区间覆盖。假设某一段被 $ x $ 条线段覆盖，那么，我们只需要从这 $ x $ 条中选取 $ K $ 个，就会对答案产生贡献。即为 $ len \\times C_{x} ^{K} $ 。 CF28C。有 $ n $ 个人等概率随机进入 $ m $ 个房间，一个房间可以有多个人，第 $ i $ 个房间有 $ ai $ 个水龙头，在一个房间的人要去排队装水，他们会使得最长的队尽可能小，求所有房间中最长队列长度的期望。 $ n,m \\leq 50 $ 概率，动态规划。注意到，一个房间内原来有多少人到达最长是无法记录在状态中的，所以直接求概率十分困难。考虑概率的原始定义：方案数除以总方案数。也就是说我们求出状态的方案数即可。 用 $ f(i,j,l) $ 表示已经分配了前 $ i $ 个房间和 $ j $ 个人，最长队列长度为 $ l $ 的方案数。首先 $ f(i,0,0)=1 $ 。 状态可以有两种决策转移，一种是当前房间队列到达 $ l $ ，前面的房间任意；另一种是前面有房间队列到达 $ l $ ，但当前的房间任意，于是， $$\\large f(i,j,l) = \\sum _{k=0} ^{l} \\left( ^{n-j+p} _{\\ \\ \\ \\ p} \\right) f(i-1,j-p,k) \\\\ \\large + \\sum _{k=0} ^{\\min p -1} \\left( ^{n-j+k} _{\\ \\ \\ \\ \\ k} \\right) f(i-1,j-k,l)$$ 其中 $ p $ 为使得第 $ i $ 个房间队列长度为 $ l $ 的数的集合，需要枚举。 CF15E。给定一个整数 $ N $ ，当 $ N=12 $ 的时候是这样一幅图： 然后你要从最上面的 $ H $ 点出发，走一条道路，这条道路中间不包括任何灰色三角形，最后回到 $ H $ 。 $ N $ 是偶数， $ n \\leq 10^6 $ ，问有多少情况，答案对 $ 1e9+9 $ 取模。 递推。为了方便起见，我们以下图所示的阶段划分。 由于整个图是对称的，所以我们考虑左半部分。除去几种特殊情况，我们都需要从绿点出发回到紫点，方案数记为 $ g[1] $ 。令 $ f[i] $ 表示陷进去 $ i $ 层的方案数（强制不能从洞口经过，防止重复计数）。令 $ g[i] $ 表示第i个蓝点到红点的方案数，于是显然有， $$\\large f[0] = 0,\\ f[1] = 4,\\ f[i] = 4 + 2 \\times f[i-1]$$ 通过 $ f[] $ 我们可以很容易地递推出 $ g[] $ 。首先， $$\\large g[n/2] = 1$$ $ g[i] $ 可以从哪些方面转移呢，第一种是从蓝点 $ i $ 不经过蓝点 $ i+1 $ 回到红点 $ i $ ，根据是否进入洞穴来分；第二种是经过了蓝点 $ i+1 $ 。综上，即为， $$\\large g[i] = 3 \\times f[i-1] + 4 + g[i+1] \\times (f[i-1]+1)$$ 如何根据 $ g[1] $ 来计算答案？可以注意到，一种是从绿点到紫点再到绿点；一种是从绿点到紫点再直接回去；还有 $ 2 $ 种情况是不经过绿点。于是答案即为： $$\\large ans = 2 \\times (g[1] \\times g[1] + 2 \\times g[1] + 2)$$ CF40E。给出一个 $ n\\times m $ 的矩阵，每个元素都是 $ 1 $ 或 $ −1 $ ，其中有 $ k $ 个位置元素已经确定，并且这个矩阵满足每一行、每一列元素的乘积都是 $ −1 $ ，问有多少种不同的矩阵。 $ 1≤n,m≤1000,0≤k&lt;\\max(n,m)。 $ 组合，观察。注意到乘积为 $ -1 $ 的等价条件为 $ -1 $ 有奇数个。需要注意一个条件 $ k&lt;\\max(n,m) $ ，这意味至少存在一行（或列）是空的。这是极其重要的一条性质。 假设空的一行为 $ x $ ，我们可以先去填上其他行。此后满足其他行的乘积都为 $ -1 $ ，这个可以通过组合数很容易地算出来。然后，我们要求列的乘积也是 $ -1 $ ，不难发现，第 $ x $ 的每一个数都是唯一确定的。也就是是说，其他行方案的乘积就是总的方案数。 但是这样还没有完，我们仍需要保证第 $ x $ 行的乘积是负数，如何确定呢。注意到，所有数的乘积是 $ (-1)^m $ ，如果 $ (-1)^m \\not= (-1)^n $ 则一定无解，否则第 $ x $ 行的乘积一定是负数。 CF830D。给定 $ n $ ，现有深度为 $ n $ 的满二叉树，对于一个节点，给它与它的所有父亲连一条边。 问得到的新的图有多少条不同的简单路径（1-&gt;2和2-&gt;1算不同路径） 。 $ n≤400 $ 树形DP，巧妙非常规的状态定义。首先考虑一个错误的算法，通过对错误的分析，可以得到正确的算法。 假设状态 $ f[i] $ 表示深度为 $ i $ 的满二叉树，方案的个数为 $ f[i] $ 。我们考虑按照是否通过根结点来讨论。一种是根经过根据所在子树不同，有 $ f[i-1] \\times f[i-1] \\times 4 $ 种情况，一种是从根出发或结束，有 $ f[i-1] \\times 4 $ 种情况，还有一种是不经过根 $ f[i-1] \\times 2 $ ，当然，只包含 $ 1 $ 的简单路径也算，就是要 $ +1 $ 。 可以发现，这比答案大很多。问题出在哪里呢？可以发现，如果我从左子树到根再到左子树，就会发生方案不合法，同时注意到 $ n $ 比较小，考虑附加一些状态来避免非法。 我们需要在同一个子树中选择两个不相交的路径，然后与根相连。此后不相交的路径条数会不变或减小。 这就启发我们还要记录一个状态：此时树中有多少个不相交路径。即 $ f[i,j] $ 表示从深度为 $ i $ 的树中，选出 $ j $ 条不相交的路径的方案数。那么答案就是 $ f[k,1] $ ，按照根所在路径，枚举 $ f[i-1,j] $ 和 $ f[i-1,k] $ 转移如下： 如果让根成为单独的一条路径，那么 $ f[i,j+k+1]\\ += f[i−1,j] × f[i−1,k] $ 如果不选根，那么 $ f[i,j+k] += f[i−1,j] × f[i−1,k] $ 让根与左儿子中的一条路径结合或和右儿子中的一条路径结合，那么 $ f[i,j+k] += f[i−1,j] × f[i−1,k] × 2 × (j+k) $ 从 $ j+k $ 条边中选出两条，让这两条边与根结合形成新的一条边，那么 $ f[i,j+k−1] += f[i−1,j] × f[i−1,k] × C(j+k, 2) × 2 $ 真的是一道DP神题！ 数据结构 CF538F。现在有一个长度为 $ n $ 的数组 $ a1, a2, …, an $ 。然后对于 $ k $ 从 $ 1 $ 到 $ n-1 $ 别对该数组建 $ k $ 叉堆。现在要统计对于每一个 $ k $ 叉堆，里面有多少结点是不满足最小堆的性质的。即值比父亲的要小的结点有多少个。他的 $ k $ 个儿子编号是 $ k(v − 1) + 2, …, kv + 1 $ 。 $ k $ 叉堆的性质，调和级数，树状数组。注意到一个性质 $ k $ 叉堆的父亲只有 $ n/k $ ，也就是说父亲的总数不会超过 $ O(n(1+1/2+1/3+…+1/n))=O(n\\log n) $ 。这就成为了本题的突破口。 考虑从小到大加入每一个数到树状数组，可以枚举这个点作为 $ k $ 叉堆的父亲。由于属于它的儿子一定是一个区间，所以我们可以用树状数组在 $ O(\\log ) $ 的时间内统计出贡献。总的复杂度为 $ O(n \\log^2 n) $ 。 CF101B。给定 $ n,m $ 。需要从 $ 0 $ 到 $ n $ ，有 $ m $ 种公交车。第 $ i $ 辆公交车从 $ si $ 走到 $ ti $ （可以在中途上车），问有多少种方案可以选择。注意人只能坐车，不可以走。 $ m \\leq 100000 $ 动态规划，树状数组。首先离散化，按 $ t $ 来排序，我们可以 $ DP $ 。注意到可以转移的状态是一段区间，所以直接用树状数组即可。 CF677D。给定一个 $ n\\times m $ 的地图，标有数字 $ [1,p] $ 。需要从 $ 1 $ 出发，依次经过一个 $ 2,3,4… $ 直到 $ p $ 。求最少所需要的步数。 $ n,m \\leq 300 $ 二维树状数组。考虑从数字 $ k-1 $ 走到 $ k $ 的转移。存在四种转移的方向，以从左上角转移为例。于是转移方程即为 $ f[i][j]=f[x][y]+i-x+j-y $ ，可以拆开使得与 $ i,j $ 无关。 $ f[x][y]-x-y $ 于是把这个东西放在树状数组里，询问二维前缀最小值即可。细节较多，代码较长QAQ CF372C。有 $ n $ 个点， $ m $ 个烟花要放。给定放的地点 $ a[i] $ 、时间 $ t[i] $ ，如果你当时在 $ x $ ，那么可以获得 $ b[i]-|a[i]-x| $ 的高兴值。每个单位时间可以移动不超过 $ d $ ，初始位置是任意的，求通过移动能获取到的最大的值。 $ $ n \\leq 150000, m \\leq 300 $ $ DP+单调队列。设 $ f[i][j] $ 表示在放第 $ i $ 个烟花的时候，站在位置 $ j $ 能得到的最多的高兴值。于是有状态转移方程： $ f[i][j]=\\max(f[i-1][k])+b[i]-|a[i]-j| $ ，其中， $ \\max(1,j-td)&lt;=k&lt;=\\min(n,j+td)(t是两次烟花的时间差) $ 。这个复杂度是 $ O(n^2m) $ 。 考虑优化，发现每一次转移的 $ k $ 都是一个区间，于是我们可以用单调队列维护。注意使用滚动数组。 CF827C。给定一个只包含 $ A,T,C,G $ 的字符串 $ S $ ,有如下两种操作。1) $ \\ x,c $ ，修改第 $ x $ 个字母为 $ c $ 。2) $ \\ l,r $ ,字符串 $ e $ ，生成一个由 $ e $ 重复组成的新串，像 $ eee… $ ，问 $ [L,R] $ 中有几个字母跟这个新的字符串对？ $ |S|,Q \\leq 100000，|e|&lt;=10 $ 树状数组，剩余类。考虑对 $ S $ 为 $ 4 $ 个字符，分别建立 $ 10\\times 10 $ 的树状数组。表示第 $ i $ 个字符在位置 $ x $ 满足 $ x\\%j=k $ 的个数之和。看上去很暴力，对吧？接下来分析复杂度。对于一个修改操作，我们需要修改在 $ O(|e|) $ 个树状数组中的值，每次修改的代价为 $ O(\\log n) $ 。对于一个询问操作，我们需要询问 $ O(|e|) $ 询问的代价为 $ O(\\log n) $ 。所以总体的复杂度为 $ O(Q\\times \\log |S| \\times |e|) $ 。 树相关 CF543D。输入给出 $ N $ 和一些边的关系 $ (p2，p3，p4,…,pn) $ 表示 $ i $ 和 $ pi $ 有连边。对于以任意 $ i $ 为根时，把树边黑白染色，使得任意点走到根的路径上不超过一条黑边，输出染色的方案数。 $ n \\leq 200000 $ 树形DP，DFS转移。考虑以 $ 1 $ 为根的情况，定义 $ f[i] $ 表示以 $ i $ 为根的方案数，于是有 $ f[i] = \\prod (f[j]+1) $ 。 那么，如何将答案转移到子节点上呢？假设 $ u $ 的祖先（非子树）的方案为 $ x $ ，需要转移到 $ u $ 的子节点 $ v $ 。假设 $ u $ 到 $ v $ 的边的颜色为黑色，显然只有一种；为白色时，有 $ \\large \\frac {x \\times f[u]} {f[v]+1} $ 种方案。两者之和作为新的 $ x’ $ 转移到子节点即可。每个节点的答案为 $ x \\times f[u] $ 。 值得注意的是，由于涉及到除法和取余，所以需要我们计算逆元。但是，特别的，如果 $ f[v]+1=MOD $ ，则不存在逆元，所以需要我们暴力重新计算。 CF396C。给定以 $ 1 $ 为根的树，从节点 $ 2 $ 开始给出每个节点的父节点。 $ m $ 次操作，操作分为两种， $ 1\\ u, x, k $ ，表示在以 $ u $ 为根的子树上，对于所有其它与 $ u $ 节点的距离为 $ i $ 的点 $ v $ ，加上 $ x-i\\times k $ 。 $ 2\\ v $ ，查询节点 $ v $ 值。 $ n,m \\leq 300000 $ DFS序，树状数组。从 $ x-i\\times k $ 这个式子入手，显然 $ x $ 可以用DFS序来维护，那么如何处理后一个数字呢？考虑拆开： $ x-i \\times k = x - (d[v] - d[u]) \\times k = (x + d[u] \\times k) + d[v] \\times k $ 。可以发现，我们将答案分为了两部分，一部分与 $ v $ 的深度无关，可以用树状数组维护。另一部分与 $ v $ 的深度有关，于是维护 $ k $ 之和即可。区间修改可以差分化，然后用树状数组维护。 CF696B。给定一棵以 $ 1 $ 为根的树，在时刻 $ 1,2,3… $ 访问节点。一开始在 $ 1 $ ，之后以随机的方式 $ DFS $ （保证不重复访问）求对于每个节点，访问它的期望时间。 $ n \\leq 100000 $ 期望的线性性，树形DP。假设一个节点 $ u $ 已经知道访问父节点 $ fa $ 的期望时间 $ ans[fa] $ ，那么这个节点 $ u $ 的期望时间为多少？考虑到， $ u $ 的兄弟节点各有 $ 50\\% $ 在 $ u $ 的前面访问，而且需要的代价为整颗子树的 $ size $ 。由此我们可以得到在子树 $ fa $ 访问 $ u $ 的期望时间。再根据期望的线性性，于是， $$\\large ans[u]=ans[fa] + 0.5 \\times (size[fa] - size[u] - 1) + 1$$ 图论 CF208C。给定一个有 $ n $ 个节点的无向图。选一个点成为特殊点，与特殊点相连的边称之为特殊边。求，对于所有 $ 1 \\rightarrow n $ 的最短路，经过的特殊边数量的平均值，的最大值。 $ n \\leq 100, m \\leq n(n-1)/2 $ 最短路，拓扑图的DP。考虑到有两种情况，一种是 $ 1 $ 或 $ n $ 成为了特殊点，此时答案一定为 $ 1 $ 。否则我们可以求出经过每个点的最短路条数，即可。在BFS之后，按照距离来排序就完成了拓扑排序。 CF154C。有编号为 $ [1,n] $ 的 $ n $ 个人，并给一些相识关系。对于两个人 $ (i, j) $ 有，对所有剩下的人， $ k $ 要么与 $ i,j $ 相识， $ k $ 要么与 $ i,j $ 不相识，求这样的 $ (i,j) $ 有多少对。 图上的HASH。考虑到我们可以将点连出去的边进行 $ Hash $ ，如果两个点的 $ Hash $ 值相同，则这一对点满足条件。还存在着一个问题，就是说，如果 $ (i,j) $ 本身存在连边，他们的 $ Hash $ 值不同，于是它们可以把自己加入各自的 $ Hash $ 。由于这个 $ Hash $ 函数要求与顺序无关，所以我们可以对每个点赋予一个值，然后加起来或者异或，即可。 CF825E。给定一个有 $ n $ 个节点的 $ DAG $ 。所有的点权是一个 $ [1,n] $ 的置换，如果存在 $ u \\rightarrow v $ 的一条有向边，需要满足 $ u $ 的点权比 $ v $ 的点权小。求这个置换，要求最小字典序最小。 贪心，堆，拓扑排序。显然需要贪心，我们有如下两种贪心策略： 按照原图进行拓扑排序，每一次将位置最靠前的赋值为最小值。 按照原图的反图进行拓扑排序，每一次将位置靠最后的赋值为最大值。 哪一种贪心是正确的呢？考虑第一种贪心，不难发现，如果位置最靠前的没有赋值为最小值，对答案或许不造成影响。考虑第二种贪心，如果位置最靠后的没有赋值为最大值，也就是最大值不是在位置最后的点，导致答案的字典序更大。于是用一个堆维护最靠后的位置即可。 动态规划 CF67D。两条直线，各有 $ n(1≤n≤10^6) $ 个点，每个上面的点会和下面的一个点相连，构成一条线段，共 $ n $ 条线段，问这 $ n $ 条线段中，最多有多少线段，它们两两相交？ 最长上升子序列。考虑两两相交的条件，对于第一行一些点 $ (a,b,c,..) $ ，如果它们的线段互相相交，则在第二行一定是以 $ (..,c,d,a) $ 的顺序出现。将第二行倒序，就变成了裸的LIS问题。 CF398B。给出 $ n $ 和 $ m $ ，在一个 $ n\\times n $ 的平面上有 $ n\\times n $ 个瓷砖，其中有 $ m $ 块已经涂色。现在随机选中一块进行涂色（如果已经涂色跳过，也消耗时间），消耗 $ 1 $ 个时间。终止条件为每行每列都有至少有一块瓷砖被涂色。问说涂成满意的情况需要时间的期望。 $ n \\leq 2000 $ 期望DP。定义状态 $ f[i][j] $ 表示剩余 $ i $ 行和 $ j $ 列没有涂色，直到满足条件的期望时间。划分为四类转移即可。 CF762D。你有一个 $ 3\\times n $ 的格子，每个格子都有权值，问从 $ (1,1) $ 出发，到 $ (3,n) $ ，路上经过的权值最大是多少。 巧妙的状态转移。注意到一个性质，一定是在中间一行往回走的。类似与 $ S $ 形的路线。同时可以知道，一定至多往回走一次，因为往回走多次都可以等效地代替。 考虑 $ f[i][j] $ 表示走到第 $ i $ 行第 $ j $ 列时，权值的最大值。于是从 $ f[i][j] $ 可以转移到 $ f[k][j] $ ，只要加上经过的若干个权值。同样的，如果我们往回走一次，可以从 $ f[1][j] $ 转移到 $ f[3][j+2] $ ，从 $ f[3][j] $ 转移到 $ f[1][j+2] $ 。","tags":[{"name":"题解","slug":"题解","permalink":"https://xuzhean.github.io/tags/题解/"}]},{"title":"「切题记录」AtCoder","date":"2017-12-31T16:00:01.000Z","path":"2018/01/01/Solutions-AtCoder/","text":"一个小清新OJ. 题意简短，超赞！ 题目新颖，超赞！ 解法巧妙，超赞！ 标程简洁，超赞！ AtCoder Regular Contest 068 E - Snuke Line 给定$n$个区间$[l,r]$和一个数$m$。对于$d=1,2,3…,m$，求$kd(1 \\leq kd \\leq m,k\\in Z)$被多少个不同区间覆盖（对于不同的$k$，只算一次）。$1 \\leq n,m \\leq 3\\times 10^5,1 \\leq l \\leq r \\leq m$ 记区间的长度为$len=r-l+1$。想到可以$O(mlogm)$暴力枚举所有的$kd$，用线段树算出它被几个区间包含。容易发现当$d&lt;len$时，有可能被多次计算。 考虑当$d \\leq len$时，则一定存在$k$使得$kd$被这个区间覆盖。于是我们记录满足$d \\leq len$的区间个数即可。而对于$d&gt;len$的情况，至多有一个$kd$被区间覆盖，于是就可以用线段树维护。即当$d&gt;len$时加入这个区间，同时单点询问$kd$被多少个区间覆盖。复杂度$O((mlogm+n)logm)$。 Code F - Solitaire 有一个双端队列，依次往首或尾插入数1到n。然后你可以从队列的首或位取出一个数，顺次相接组成一个序列。求有多少个序列的第$K$位为$1$？$1 \\leq k \\leq n \\leq 2\\times 10^3$ 显然，当$n$个数全部插入后，队列一定是递减到1再递增的。不难发现，得到的序列的前$K$位，一定是由两个递减序列交错得到的，且第$K$位为1。 从$n$到$1$逐个考虑每一个数是否选择，且属于哪一个序列。定义$f(i,j)$ 已经得到了序列的前$i$位，其中第$i$位为$j$的方案数。将$j$加入序列1，则$f(i,j)$可由$f(i-1,k), k&gt;j$转移过来。 如果将新的数加入序列2，该如何转移？可以发现，这个数一定是没选择的数中最大的数（序列2也是递减的）。则$f(i,j)$可由$f(i-1,j)$转移过来。 事实上，DP的过程还有一个非法的转移。$f(K-1,1)$会转移到$f(K,1)$，不是以1作为第$K$个数。 对于剩下的$n-K$个数，每次可以取头或尾。于是答案$ans=(f(K-1,1)-f(K-1,1))\\times 2^{n-K-1}$。 时间复杂度$O(nK)$。 Code AtCoder Regular Contest 069 E - Frequency 有$n$堆石头，第$i$堆有$ai$个石头。每一次，你需要记录下石头最多的堆的序号（当石头数相同时，取最左端的），然后你可以从某堆中拿走一块石头。直到石头被全部拿走。需要使得序号组成的序列字典序最小，问1到n在序列中出现的次数。 可以发现，这个序列一定是非递增的。假设现在最多的石头堆为$x$，在1到x-1中石头最多的堆为$y$。考虑贪心的过程，我们需要把x到n中，石头数大于$ay$都取到$ay$，因为这样能使得序号尽可能快地减小。离散化石头数，再从小到大考虑，用树状数组维护小于某个值的石头堆数量，以及石头数总和即可。 事实上，存在排序后$O(n)$的做法。 Code F - Flags 你在一条线上插$n$个$flag$，其中第$i$个$flag$可以插在$xi$或$yi$。记所有$flag$两两间的距离最小值为$d$，求$d$的最大值。 暂未编写。 考虑二分答案$d$。于是是否放在$xi,yi$变成了$2-SAT$判定性问题，对于$xi$和$yi$恰好放一个，距离小于$d$的位置不能同时放，构成了一些约束条件。暴力枚举所有点对，可以在$O(n^2logMAX_{x})$的时间内解决。 发现许多约束条件是无用的。考虑类似线段树的分治结构来建图，对于每个点，至多与$O(logn)$个区间相连；令一方面，线段树中父子相连的边也只有$O(n)$条。单次判定的复杂度可以做到$O(nlogn)$。总的时间复杂度$O(nlognlogMAX_{x})$，可以通过此题。 存在$O(n(logn+logMAX_x))$的算法，暂未理解。 AtCoder Regular Contest 070 D - Need 给定$n$个数$ai$。如果存在子集满足其和大于等于$K$，则称为是好的子集。如果一个数$ai$所在的所有好集中，去除$ai$后仍是好集，则$ai$是无用的。求无用的数的个数。 对于$x&lt;y$，若$y$是无用的，则$x$一定无用的，所以答案满足单调性。考虑判断$x$是否是无用的，用$bitset$维护$n-1$个数相加能组成的集合（$x$除外，可以用类似$DP$的方式求出）。 显然，如果其他的数能组成$K-x$到$K-1$中的任意一个数，则$x$是有用的。时间复杂度$O(\\frac {n^2logn} w)$ ，此处$w$一般为$32$或$64$。 Code AtCoder Regular Contest 071 E - TrBBnsformBBtion 有字符串$S,T$，仅由$A$或$B$构成。有如下操作：①选择一个字符:$A\\rightarrow BB$ 或 $B\\rightarrow AA$。②删除连续3个相同的字符:$AAA$或$BBB$。给定$Q$个询问，对于每个询问，回答$S[a,b]$能否变换为$T[c,d]$。$|S|,|T|,Q \\leq 10^5$ 想了几分钟就YY了一个结论：把A看作1，把B看作2，两个串能变换当且仅当两个区间和模3同余。然后就A掉了。首先，必要性显然，因为对于区间和模3，不论如何操作都不会改变。 看了官方题解才知道如何证明充分性。首先主要到所有的操作都是可逆的：$A\\rightarrow BB\\rightarrow AAAA\\rightarrow A$。且$A,B$可以任意地加3个或减3个。考虑将$S$和$T$中的$B$全变为$A$。如果$S,T$的$A$个个数关于3同余，则一定能变换。就证明了结论。 Code F - Infinite Sequence 给定$n\\ (n \\leq 10^6)$，问存在多少个无穷序列满足：1.每个数都在1到$n$之间。2.对于任意$n \\leq i,j$，都有$a_i=a_j$。3.对于任意的$i$，若存在$i+1 \\leq j&lt;k \\leq i+a_i$，都有$a_j=a_k$。 发现只有前$n$位是有用的，考虑到动态规划更容易向前转移，定义$f(i)$为子序列$[i,n]$满足条件的个数，于是我们考虑$a_i$的值即可转移。 发现1是一个比较特殊的数，当$a_i=1$时，$f(i)=f(i-1)$。 当$a[i]\\not=1,a[i+1]\\not=1$时，序列为$ABBBBBB…$的形式，$f(i)=(n-1)\\times (n-1)$。 当$a[i]\\not=1,a[i+1]=1$时，序列为$A,1,1,,..,1,B…$的形式，$f(i)=f(i-3)+f(i-4)+…+f(1)+n-i+2$。 Code AtCoder Regular Contest 072 D - Alice&amp;Brown A和B在玩一个游戏。一开始，有两堆石子分别有$X$和$Y$个。你可以从一堆中取$2i$个，然后放$i$个到另一堆。无法操作的玩家输。问先手是否存在必胜策略?$0 \\leq X,Y \\leq 10^{18}$。 通过打表发现，当$|X-Y|&gt;=2$先手必胜，否则后手必胜。考虑如何证明。 对于$(X,Y)=(0,0),(0,1),(1,0),(1,1)$，满足$|X-Y|&lt;=1$，是必败态。 对于必胜态，设$|X-Y|=3k+r&gt;=2\\ (r=0,1,-1,\\ k&gt;=1)$ ，取$i=k$，即可转移到必败态。 对于必败态，操作后$X-Y$至少改变3，一定会转移到必胜态。 Code E - Alice in linear land 给定长度为$n$的操作序列$ai$和距离$di$。对于每个$ai$，当$|d-ai|&lt;d$时$|d-ai|$会成为新的$d$，若最终$d=0$，则称是可达的。给定$Q$个询问$qi$，问能否改变$a[qi]$，使得操作序列是不可达的？$n,Q \\leq 5\\times 10^5$ 首先可以预处理前缀$a[1,qi-1]$操作后的$d$，记为$pre[qi-1]$。发现对于询问$qi$，只需要知道后缀$a[qi+1,n]$使得序列不可达的最小的$d=suf[qi+1]$，只要$pre[qi-1]&gt;=suf[qi+1]$就一定能做到。 于是问题转化为如何就$suf[i]$。显然，$suf[n+1]=1$，而且随着$i$的减小，$suf[i]$一定是非递减的。当$ai&gt;=2\\times suf[i+1]$，可以取到$suf[i]=suf[i+1]$（此时无法执行操作）；否则$suf[i]=suf[i+1]+ai$。 Code F - Dam 有一个水坝容积为$L$，一开始没有水。此后$n$天，在第$i$天早晨，会进来体积为$Vi$，温度为$Ti$的水；为了下一天水不会溢出，第$i$天傍晚需要排出一些水。对于体积$V1$，温度$T1$和体积$V2$，温度$T2$的水混合，体积为$V1+V2$，水温为$\\large \\frac {T1\\times V1+T2\\times V2}{V1+V2}$。回答$n$个询问，对于第$i$个询问，输出在第$i$天能够达到的最大水温。$n \\leq 5\\times 10^5$ 假设混合得到的水体积为$V2$，温度为$T3$。由题目可知$T1\\times V1+T2\\times V2 = T3\\times V3$。考虑将$(x,y)=(V,TV)$抽象为一个向量，那么，水的混合就变成了向量之和！ 观察这个向量，发现$T$对应的就是它的斜率！将水排出，相当于是原向量乘上&lt;1的实数！将可能的状态画在坐标系上，可以发现这一定是一个上凸包。如图。 而新加入一个向量后，最右端的会被删除。此时不一定还是凸包，在左端比较相邻的斜率，合并即可。 整个过程用双端队列维护，复杂度$O(n)$。 AtCoder Regular Contest 073Code E - Ball Coloring 有$n$个包，每个包里各有两个球，权值为$xi$和$yi$。你需要将一个球涂为红色，另一个球涂为蓝色。令$Rmin$为红球中的最小权值，$Rmax,Bmin,Bmax$同样定义。求出$(Rmax-Rmin)\\times (Bmax-Bmin)$的最小值。$n \\leq 2\\times 10^5$ 假设所有权值中的最大值为$Max$，最小值$Min$。不失一般性地，有两种情况： $Rmax=Max,Bmin=Min$，此时需要最大化$Rmin$，最小化$Bmax$，于是将两个球中较大的涂为红色，较小的涂为蓝色。 $Rmax=Max,Rmin=Min$（Min和Max不在同一包里），此时需要最小化$Bmax$，最大化$Bmin$，令$xi \\leq yi$，之后按照$x$升序排序。我们说，最优方案一定是，排序后，前$k\\ (1 \\leq k \\leq n)$个的$xi$涂为红色，后$n-k$个涂为蓝色。如何证明，考虑反证法。 假设第$p(p&gt;=k+2)$涂为了红色，那么$Bmin$并不会增大，而$Bmax$并不会减小，所以一定不会是更优解。于是简单证明了结论。 Code F - Many Moves 在一根长度为$n$的数轴上，有两个方块，位置为$A,B$。并且在同一时刻，你能移动一块方块一个单位距离。你需要依次到达位置$xi$，求最少所需时间。$n,Q \\leq 2\\times 10^5$ 以$xi$作为阶段，注意到上次的一个方块位置一定是在$x[i-1]$，于是不难想到$O(n^2)$的DP。$f[i,j]$表示到位置$xi$，另一个位置为$j$的最小时间。若原来位置为$x[i-1]$的到位置$xi$，即有$f[i,j]=f[i-1,j]+|x[i]-x[i-1]|$。否则即有$f[i,x[i-1]]=f[i,j]+|j-x[i-1]|$。 考虑如何从优化转移的时间。对于前面的状态转移方程，事实上就是线段树的区间加。对于后面的状态转移方程，考虑维护$f[i,j]-j$和$f[i,j]+j$的值，在$[1,x[i-1]]$取$f[i,j]-j$的最值；在$[x[i-1],n]$取$f[i,j]+j$的最值即可。阶段间的转移优化到了$O(logn)$。 Code AtCoder Regular Contest 074 D - 3N Numbers 给定$3n$个数$A$，你需要删除其中的$n$个数，使得剩下$2n$个数$A’$中前$n$个数之和-后n个数之和之差最大。求最大值。$n \\leq 10^5$ 发现对于删除后$A’$的第$n$个数一定是在原来$A$的$[n,2n]$，考虑暴力枚举$A’[n]$的取值，剩下的贪心地选取。整个过程用堆维护。 Code E - RGB Sequence 您需要构造一个长度为$n$， 由R,G,B构成的序列，满足以下$m$个限制。对于限制$i$，满足$[li,ri]$间不同的颜色种数恰好为$xi$。求满足条件的序列数。$n,m \\leq 300$ 考虑到如果存在不满足的情况，一定是DP过程中最后的R,G,B发生冲突。于是考虑状态$f[R][G][B]$表示$R,G,B$最后的位置，发现当前位置$p=max\\{R,G,B\\}$。考虑暴力转移，转以后判断是否冲突即可。 Code AtCoder Regular Contest 075 D - Widespread 有$n$只怪兽，第$i$只怪兽初始血量$hi$。每次可以选定一只怪兽攻击，造成$A$点血量的伤害。同时其他怪兽受到$B$点血量的伤害。求最少的攻击次数。$n \\leq 100000$ 考虑二分答案次数$T$。当某只怪物的血量$hi \\leq BT$时，不需要主动攻击。否则需要$\\large \\lceil \\frac {hi-BT} {A-B}\\rceil$次主动攻击，判断主动攻击次数之和是否不超过$T$次即可。 Code F - Mirrored 对于一个正整数$n$，记$rev(n)$为$n$的倒置，例如$rev(123)=321,rev(4000)=4$。给定$D$，求存在多少$n$满足$rev(n)=n+D$。$D \\leq 10^9$ 以5位数为例，$\\overline{edcba}-\\overline{abcde}=9999(e-a)+990(d-b)$ 考虑到如果$D$不是9的倍数，一定无解，否则我们考虑现将$D$除以9。然后DFS，发现$(e-a)\\ mod\\ 10$可以确定，同样可以逐位确定剩余的位，最后乘法原理确定总方案数即可。注意奇偶分类。 Code AtCoder Regular Contest 075 E - Connected? 给定$R \\times C$棋盘上的$n$对点，要求这$n$对点彼此连线，保证这些线不相交。求是否存在方案满足。 考虑到，如果不是两个点都在边界上，一定存在方案。所以我们只要考虑边界点即可。考虑使用一个栈，顺时针处理所有的点$x$，如果栈顶的点是$x$，则出栈，否则令$x$入栈。最后只要检查栈是否为空即可。 Code AtCoder Regular Contest 077 D - 11 给定$n$和长度为$n+1$的子序列，每个数都在$[1,n]$，且恰有一个数出现两次。对于$k=1,2,…,n+1$，求出长度为$k$的互异子序列个数。$n \\leq 10^5$ 首先找出相同的两个数$x$的位置$l,r$，可以发现剩下的数都是等价的。对于每个$k$，分类讨论计数。按照选取$x$个数，就是$C_{n-1}^k+2C_{n-1}^{k-1}+C_{n-1}^{k-2}$。注意到，如果在$(l,r)$内没有选数，选择$l$和选择$r$会被当作同一情况，于是答案还要减去$C_{u+v}^{k-1}$。 E - guruguru 有一盏灯具有$1,2,…,m$种亮度。遥控板可以一次操作可以将亮度加一（为$m$时，变为$1$）或跳转到固定的亮度$x$。一开始亮度为$a_1$，接下来$n-1$次，你需要将亮度从$a_{i-1}$调节到$a_i$。选取一个$x$，使得调节的总次数最小。$n,m \\leq 10^5$ 记$f(x_0)$为：当$x=x_0$时，需要调节的总次数。考虑亮度$s\\Rightarrow t$ 对$f(x)$的贡献（假设$s&lt;t$， 其他情况同样处理）。 对于$x \\leq s$，$f(x)+=t-s$ 对于$s&lt;x \\leq t$， $f(x)+=t-x+1$ 对于$t&lt;x$，$f(x)+=t-s$ 发现是区间操作，并且只有在最后查询。于是考虑差分，特别的，需要分为常数部分和系数部分。 F - SS 定义“双串”，由两个相同的字符串拼接而成。定义$f(S)$，在双串S后追加最少字符得到的双串。给定$S0S0$和$l,r$。求$f^{10^{100}}(S0S0)$在$[l,r]$内，26个字母分别出现的个数。$|S|&lt;=2*10^5,l,r \\leq 10^{18}$ _有待更深入理解。_用KMP预处理Next[]，可以的到S0的最短相同前后缀T，设$f(S0S0)=STST$。通过画图发现，若$|T|$是$|S|$的因数，那么S就是由一些T拼成的，$f(STST)=STTSTT$。否则，$f(STST)=STSTST$。设$g(S)g(S)=f(SS)$ ，能得到$g^{i+2}(S)=g^{i+1}(S)+g^i(S)$（显然，对于$i$无限大时也满足第一种情况）。考虑求出前缀的贡献，按照类似fib数列的递推方式计算即可。","tags":[{"name":"题解","slug":"题解","permalink":"https://xuzhean.github.io/tags/题解/"}]},{"title":"「学习笔记」Prufer 序列","date":"2017-12-31T15:59:59.000Z","path":"2017/12/31/Algorithms-Tree/","text":"参考资料 prufer序是无根树的编码表示，对于一棵$n$个节点带编号的无根树，对应唯一一串长度为$n-2$的prufer编码。 无根树转化为prufer序列找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下$2$个节点。 根据以上过程，显然有推论 一个节点的度数=其在prefer序列出现的次数+1。 prufer序列转化为无根树首先prufer序列中的出现次数+1可以得到每个节点的度。 先执行$n-2​$步，选取最小标号度为1的点$u​$与Purfer序列的第$i​$个数$v​$表示的顶点相连，并将$u​$和$v​$的度减$1​$。最后再把剩下的两个度为$1​$的点连边。 由此发现，一棵无根树和与一个prufer序列一一对应。 一些推论 一个无向完全图的生成树个数为$n^{n-2}$。 设节点$i$的度数限制为$di$，求满足条件树的个数。对应到prufer序列，相当于$i$在序列中出现了$di-1$次，不同的排列数。即为$n!$除以每个$(di-1)!$。 对于一些没有限制度数，稍微修改一下即可。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"「学习笔记」字符串の黑魔法","date":"2017-12-31T15:59:58.000Z","path":"2017/12/31/Algorithms-String/","text":"怎样AC—— 字符串の黑魔法 [TOC] _例题挑一些做！_ _习题别做！_ Part 1 基础字符串算法####HASH 在 $seed$ 进制下取模，快速判断两个串是否相等 维护集合。能支持简单的删减 维护前缀。能支持简单的修改，提取子串 双模数 HASH ，自然溢出 维护动态串 HASH ：线段树 or 平衡树 一道简单题？一道难题？区间修改，查询区间是否是周期为 $c$ 的串 思考5min… 比较难的一道题 CF452F Permutation 给定一个长度为 $n$ 的置换，问是否存在 $a,b\\;(a \\not=b,a\\equiv b \\pmod 2)$ 满足 $\\large c = \\frac {a+b} 2$ 的位置在 $a,b$ 之间 $n \\leq 300000$ 思考10min… 考虑从左至右枚举 $c$ ，如果不存在 $a,b$ 那么一定满足 $a,b$ 在 $c$ 的同一边 即 $a,b$ 要么都在 $c$ 前出现，要么都在后面出现 也就是数值 $c$ 两边的出现情况是否对称 考虑正着倒着各维护一个 HASH 值 即可判断是否对称 KMP求出所有位置结尾的最长匹配长度 常见套路：作为DP的状态，最小周期串 ，名次匹配 没啥好说的 ExKMP求 S 的后缀与 T 的LCP，记为 $EX_{S,T}[i]$ 考虑先求出 $EX_{T,T}[i]$ ，保存当前最大的 $k+ex[k]-1$ ，在范围内的，直接用之前的信息求出，否则暴力匹配，复杂度线性 如何理解第 5 行代码？ 123456789101112131415//此模版下标从0开始void exKMP(char s[], char t[], int n, int m) &#123; int mx = 0; f[0] = m; rep (i, 1, m-1) &#123; f[i] = max(0, min(f[i-mx], mx+f[mx]-i)); while (i+f[i] &lt; m &amp;&amp; t[i+f[i]] == t[f[i]]) f[i]++; if (!mx || i + f[i] &gt; mx + f[mx]) mx = i; &#125; mx = 0; rep (i, 0, n-1) &#123; g[i] = max(0, min(f[i-mx], mx+g[mx]-i)); while (i+g[i] &lt; n &amp;&amp; s[i+g[i]] == t[g[i]]) g[i]++; if (!mx || i + g[i] &gt; mx + g[mx]) mx = i; &#125;&#125; 例题 51Nod1638 字符串重组 $s$ 是一个长度为 $n$ 的字符串，定义 $$f(s,i,j) = s_{i+1…j−1} + r(s_{j…n−1}) + r(s_{0…i})\\;(0 \\le i&lt;j&lt;n)$$ 给定 $a$ 和 $b$ 。找出相应的 $i$ 和 $j$ ，使得 $f(a,i,j) =b$ 取 $i$ 最大，其次 $j$ 最小的方案 思考7min… 将 $a$ 反向与 $b$ 进行 KMP，得到 $i,j$ 的值 用 ExKMP 判 $a[i+1],b$ 的最长公共前缀 需要预处理一下 $i$ 的上界 $\\mathrm{limit}$ 注意细节 Manachar求出 $r[i]$ ，表示以 $i$ 为回文中心的最长回文半径 与 ExKMP 类似，保存扩展的最右边节点。范围内利用已有信息，否则暴力扩展。为了处理长度为偶数的回文串，在所有中间字符插入 # ，两端插入其它字符 复杂度 $O(n)$ 观察其扩展的方式，不难得到：任意一串的本质不同的回文串最多有 $O(n)$ 个 12345678910111213141516const int maxn = 200009;char s[maxn], str[maxn];int r[maxn], n;void manachar(char s[], int n) &#123; int mx = 0, p = 0; for (int i=1; i&lt;=n; i++) &#123; str[i&lt;&lt;1] = s[i]; str[i&lt;&lt;1|1] = '#'; &#125; str[0] = '$'; str[1] = '#'; str[(n+1)&lt;&lt;1] = '@'; for (int i=1; i&lt;=(n&lt;&lt;1|1); i++) &#123; r[i] = max(1, min(r[2*p-i], mx-i)); while (str[i+r[i]] == str[i-r[i]]) r[i]++; if (i + r[i] &gt; mx) &#123; p = i; mx = i + r[i]; &#125; &#125;&#125; 一道题 BZOJ2342 [SHOI2011]双倍回文 给定一个字符串，求最长的一个形如 $ww^rww^r$ 的子串 $n \\leq 500000$ 思考10min… 考虑枚举大回文中心 $i$ ，而$j$ 满足条件当且仅当 $i-r[i]/2\\le j&lt;i,\\;j + r[j] \\ge i$ 对于每一个 $i$ ，我们要求出最小的 $j$ 注意到第二个不等式右边单调递增，并查集维护 exercise BZOJ2565 最长双回文串 BZOJ3103 Palindromic Equivalence 最小表示法$O(n)$ 求出字符串的最小字典序的循环同构。两个指针单调移动 123456789i = 0; j = 1;while (i &lt; n &amp;&amp; j &lt; n) &#123; k = 0; while (a[i+k&gt;=n?i+k-n:i+k] == a[j+k&gt;=n?j+k-n:j+k]) k++; if (k == n) break; if (a[i+k&gt;=n?i+k-n:i+k] &lt; a[j+k&gt;=n?j+k-n:j+k]) j = max(j+k+1, i+1); else i = max(i+k+1, j+1);&#125;res = min(i, j); 裸题：BZOJ2176 Strange string 最小表示法思想：简化状态的表示 红红火火恍恍惚惚哈哈哈 Codeforces 524F 给出一个仅由 ( 和 ) 构成的字符串，现在可以加入若干字符，或者把末尾的字符移到最前面。求一个长度最短的合法括号序列，如果有多个输出长度最短的且字典序最小。 思考10min… 长度是否能确定？ 是原长加上两种括号的差值 $t=\\mathrm{cnt\\;)}-\\mathrm{cnt\\;(}$，$t$ 也是需要加上的左括号数量 所有位置都能成为左端点吗？ 如果一个括号序列可以匹配，当且仅当 所有位置的前缀 ( 数量大于 ) 的数量 单调队列维护 ) 与 ( 差值的前缀和单调递减，判断 $t$ 个左括号是否够用 循环同构，字典序最小？ 最小表示法即可 随便一写就可以秒 SA 做法了 Codeforces 46F 思考3min… 操作可逆，达到极大/极小的状态，bellman-ford ExKMP，Manachar Codeforces 30E 思考10min… 是否有 $O(n)$ 做法？ 套路，将串反向与原串ExKMP 一个重要性质，$T[x+1,n-x]$ 一定越长越好 枚举回文中心，预处理前缀最大值 Part 2 基础字符串数据结构Trie常常与前缀相关 类似于主席树，可以可持久化 小优化：如果一个节点只有一个孩子，那么可以把这个节点省略 Compacted-trie ，节点数量降为 $O(n) $ 两个简单应用 Codeforces 178F 给你 $n$ 个串 $a_i$ ，要求选择 $k$ 个串，求 $$\\begin{eqnarray} \\large \\min \\left\\{ \\sum _ {i=1} ^ {k-1} \\sum _ {j=i+1} ^ {k} lcp(a_i,a_j) \\right\\} \\end{eqnarray}$$ 思考5min… 建出 Copacted-trie ，暴力树形背包DP，复杂度 $O(n^2)$ BZOJ4546 [CodeChef]XRQRS 给定一个初始时为空的整数序列（元素由 1 开始标号）以及一些询问： 在数组后面就加入数字 $x$ 在区间 $[L,R]$ 中找到 $y$ ，最大化 $x \\oplus y$ 删除数组最后 $k$ 个元素 在区间 $[L,R]$ 中，统计小于等于 $x$ 的元素个数 在区间 $[L,R]$ 中，找到第 $k$ 小的数 思考 5min… 可持久化Tire 裸题，不说了 卡内存差评 exercise BZOJ4523 [CQOI2016]路由表 BZOJ2741 [FOTILE模拟赛]L AC自动机KMP 的 Trie 版本。两种构造方式： 暴力跳 Fail，复杂度不够优 Trie图 ！$p[i]$ 保存加入 $i$ 后会到达的节点，$p$ 和 $Fail$ 相互计算 Fail树 AC自动机中，Fail 指针指向深度比它小的一个节点，构成了一棵树 一个点在 Fail 上的祖先是所有能和这个后缀匹配的前缀节点 Fail树 上的 LCA 是两个前缀的最长公共后缀，并且在前缀中出现 常见套路：自动机状态作为 DP 状态，矩阵快速幂优化，Fail树搞搞 经典题 51Nod1440 迈克打电话 有 $n$ 只熊，从 $1$ 到 $n$ 进行编号。第 $i$ 只熊的电话号码是$s_i$。每只熊会给那些电话号码是他的子串的熊打电话（可能会给自己打）。 $call(i, j)$ 表示第 $i$ 只熊给第 $j$ 只熊打电话的次数，也就是第 $j$ 个串在第 $i$ 个串中出现的次数。 迈克会有 $q$ 次询问。每个询问中给出 $l,r,k$ 然后请您计算一下 $\\sum ^r _{i=l} call(i,k)$ 思考7min… 简单套路 离线，Fail树，DFS序 exercise BZOJ3881 [COCI2015]Divljak 回文自动机 PAM提取所有本质不同的回文串，是 $O(n)$ 的 回文自动机的每一个节点都是原串的一个回文子串，状态只记它的长度 PAM 的有符号边 x-trans：首尾各添加一个字符 x 到达的状态 PAM 的无符号边 Fail：这个回文串的最大真回文后缀 在线构造，维护 last 表示当前的最大回文后缀 令 $p=last$ ，加入一个字符 $x$ 之后，$p$ 不断跳 Fail，直到个这个回文子串的前一个字符为 $x$ 如果不存在 x-trans ，新建一个节点，新状态的 Fail 就是 p 继续跳 Fail 知道这个回文子串的前一个字符为 x 为止 裸题 BZOJ3676 [APIO2014]回文串 假设 $cnt[i]$ 是回文串 $i$ 在 $s$ 中出现的次数，求 $$\\large \\max \\{ cnt[i] \\cdot i \\}$$ 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 300009;struct PalindromicTree &#123; int p[26], fail, cnt, len;&#125; T[maxn];int n, size, last, cur;long long ans;char s[maxn]; int newNode(int x) &#123; T[size].len = x; return size++;&#125;void build() &#123; newNode(0); newNode(-1); s[0] = '#'; T[0].fail = 1;&#125;int get(int o) &#123; while (s[n-T[o].len-1] != s[n]) o = T[o].fail; return o;&#125;int main() &#123; gets(s+1); build(); for (n=1; s[n]; n++) &#123; cur = get(last); if (!T[cur].p[s[n]-'a']) &#123; last = newNode(T[cur].len + 2); T[last].fail = T[get(T[cur].fail)].p[s[n]-'a']; T[cur].p[s[n]-'a'] = last; &#125; else last = T[cur].p[s[n]-'a']; T[last].cnt++; &#125; for (int i=size-1; i&gt;=0; i--) &#123; T[T[i].fail].cnt += T[i].cnt; ans = max(ans, 1LL * T[i].cnt * T[i].len); &#125; printf(\"%lld\\n\", ans); return 0;&#125; execise Gym 100543G 更多应用请参考 翁文涛 的 2017集训队论文 Part 3 后缀三兄弟注意，这是本次讲课最重要的内容！ 发现前面很多东西只能处理前缀，那么如何处理子串？ 每个子串都是某个后缀的前缀！那么就提取所有后缀！ 后缀数组 SA算法概述定义三个数组：SA ，Rank ，height SA ，第 i 小的后缀的编号 Rank，后缀 i 的排名 于是有 Rank[SA[i]]=i, SA[Rank[i]] height[i] ，后缀 SA[i-1] 和 后缀 SA[i] 的 LCP 求 Rank 倍增，进行 $O(\\log n)$ 次基数排序。常用的算法 DC3，线性求，但是常数大 没有用 求 height 直接暴力求，复杂度为线性 原因：height[Rank[i]] &gt;= height[Rank[i-1]] - 1 假设 SA[Rank[i-1]-1] = k，考虑删除后缀 i-1 和 k 的第一个字符 于是得到 k+1 和 i 的 LCP 至少是 height[Rank[i-1]] - 1 而 k+1 的排名比 i 小，所以有 height[Rank[i]] &gt;= height[Rank[i-1]] - 1 后缀数组模板其中 $tax$ 表示桶，$tmp[i]$ 表示第二关键字排名为 $i$ 对应的后缀标号 基数排序的过程： 统计每一个后缀排名的个数，并求出前缀和 然后按照第二关键字的排名从大到小处理 $tax[Rank[tmp[i]]]–]$ 就是 $tmp[i]$ 的新排名 一开始， $Rank[i]$ 就是后缀i的第一个字符，第二关键字就是它的位置 考虑每一次倍增子串的长度 $w$，考虑一次完整的循环 首先是没有后半部分的串，那么它们的第二关键字为0，所以按照位置是排在最前面的那几个 之后在是利用 SA 来求出剩下的第二关键字，SA[i]-w 是其对应的子串 再是一次基数排序。用 tmp 临时存储 rank 的值 最后重新离散化 按照 i，升序暴力求 $height[rank[i]]$ 即可 123456789101112131415161718192021222324252627const int maxn = 100009;int SA[maxn], rank[maxn], height[maxn], tax[maxn], tmp[maxn], n, m;char s[maxn];inline int cmp(int s[], int x, int y, int w) &#123; return s[x] == s[y] &amp;&amp; s[x+w] == s[y+w];&#125;void Sort() &#123; for (int i=0; i&lt;=m; i++) tax[i] = 0; for (int i=1; i&lt;=n; i++) tax[rank[i]]++; for (int i=1; i&lt;=m; i++) tax[i] += tax[i-1]; for (int i=n; i&gt;=1; i--) SA[tax[rank[tmp[i]]]--] = tmp[i];&#125;void SuffixArray(char s[], int n) &#123; for (int i=1; i&lt;=n; i++) &#123; rank[i] = s[i]; tmp[i] = i; &#125; m = 127; Sort(); for (int w=1,p=1,i; p&lt;n; w+=w,m=p) &#123; for (p=0,i=n-w+1; i&lt;=n; i++) tmp[++p] = i; for (int i=1; i&lt;=n; i++) if (SA[i] &gt; w) tmp[++p] = SA[i] - w; Sort(); swap(rank, tmp); rank[SA[1]] = p = 1; for (int i=2; i&lt;=n; i++) rank[SA[i]] = cmp(tmp, SA[i], SA[i-1], w) ? p : ++p; &#125; int j, k = 0; for (int i=1; i&lt;=n; height[rank[i++]]=k) for (k=k?k-1:k,j=SA[rank[i]-1]; s[i+k]==s[j+k]; ++k);&#125; 模版：UOJ #35 后缀排序 回顾一下 SA[],Rank[] 的性质，我们来看一道题 BZOJ4319 [CERC2008]Suffix reconstruction 给定 SA[] ，构造一个原字符串，只能包含小写字母 贪心？ 按照 SA[] 的顺序，每个位置能小就尽量小 如何知道一个位置是否要增大 1 ？ exercise LOJ Hello 2018 的 B ，同样是一道利用 SA[],Rank[] 性质的题 常用技巧 二分答案 利用 height 对后缀分组 重复出现的子串变为两个后缀的 LCP 两个后缀的LCP就是对应 Rank 的 height 的 左开右闭区间min 多个串，合并为一个长的串，中间用特殊字符隔开 本质不同的子串数目：所有子串个数减去所有 $height$ 不重叠：$SA$ 的最大与最小值 单调栈，RMQ 更多内容请参考文件夹内 罗穗骞 的集训队论文 具体这些套路的模版题不展开介绍 常用技巧选讲我怎么敢不讲啊QAQ 可重叠最长重复子串 给定一个字符串，求最长重复子串，这两个子串可以重叠 —— height 最大值 不可重叠最长重复子串 不可重叠 —— 二分答案，按 height 分组，组内 SA 的 min,max 可重叠的 $k$ 次最长重复子串 要求重复 $k$ 次 —— 二分答案，分组，后缀个数 最长回文子串 —— 对称，用特殊字符隔开 连续重复子串 给定 S ，求最大的 R 使得 S 为某个字符串重复 R 次得到 —— 枚举答案 R ，判断 suffix(1),suffix(k+1) 的最长公共前缀是否等于 $n-k$ ，只需求 height[] 的每一个数到 height[rank[1]] 的最小值 重复次数最多的连续重复子串 （一定要记住的经典套路） —— 考虑枚举答案长度 L ，注意到一个性质，如果一个长度为 $L$ 的字符串重复出现，那么他肯定经过了 s[0],s[L],s[2L],S[3L],... ，枚举 $i$ ，只要看字符 s[Li],s[L(i+1)] 往前往后各能匹配多远即可，如果长度为 k ，那么就出现了 k/L+1 次，复杂度 $O(n \\log n)$ ！ 两个串の最长公共子串 —— 考虑拼接起来，中间用特殊字符隔开，考虑求 排名相邻且不再同一个字符串的 height 最大值 思考：为什么只要考虑排名相邻的？ 两个串の长度不小于 $k$ 的公共子串对数 —— 考虑 A 和 B 所有后缀的最长公共前缀的长度，单调栈实现，细节自己yy 多个串の出现在不小于 $k$ 个字符串中的最长子串 —— 二分答案，分组 一些🌰 UOJ#219 [NOI2016]优秀的拆分 如果一个字符串可以被拆分为 $AABB$ 的形式，其中 $AA$ 和 $BB$ 是任意 非空 字符串，则我们称该字符串的这种拆分是优秀的。 现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它 所有子串 的所有拆分方式中，优秀拆分的总个数 $T \\leq 10, n \\leq 30000$ 思考10min… 显然，我们可以统计每个前缀的后缀 AA 的个数，后缀同理 用之前的第 6 个技巧即可 求 LCP 用 ST 表即可 区间修改，差分即可 （如果泥萌二分＋hash ，也可以卡过） Codeforces 802I 求一个串中，所有本质不同子串的出现次数的平方和 思考5min… 不久？之前 vp 中的一道题 显然可以单调栈，考虑求出所有 LCP 的出现次数，细节比较多，请自己yy 很多这种单调栈+后缀数组的题都可以用后缀树做 更多的练习习题不多不多 据说有些用 SAM 做更简单 BZOJ 3172 [TJOI2013]单词 BZOJ 3230 相似子串 BZOJ 2119 股市的预测 BZOJ 4278 [ONTAK2015]Tasowanie BZOJ 4516 [SDOI2016]生成魔咒 BZOJ 4556 [TJOI2016]字符串 BZOJ 2534 L-gap字符串 BZOJ 3796 Mushroom追妹纸 BZOJ 3682 Phorni CodeChef STRQUERY String Query 后缀自动机 SAM如何理解 SAM ？ 确保理解后缀自动机的结构，特别是 Right集合 的意义 在讲之前，先来感性理解一下 SAM 的结构 概述 串 S 的后缀自动机能识别 且仅能识别 S 的所有 后缀 同时，所有子串包含在 SAM 的某个状态 如果暴力对后缀建 Tire，复杂度是 $O(n^2)$ 发现很多状态是重复的，考虑 最小化 SAM ，合并所有的重复状态 状态的优化一个节点的到根路径必然是 一些 子串，这个节点所能够识别的后缀是这些子串出现的所有位置对应的后缀 假设一个子串 s 在 $\\{[l_i,r_i]\\}$ 出现，那么 从 s 出发，能识别子串 $[r_i+1,|S|]$ 可以发现，节点 A,B 能合并，当且仅当 A,B 在字符串中出现的结束位置完全一样 定义 Right(sub) 表示 sub 右端 在 S 中出现的集合 考虑将所有相同 Right() 的状态合并为一个节点 .【一个 Right 集合 + 一个长度】能够对应一些相同的子串 显然合法的长度是一个区间，记为 [min(u),max(u)] _深刻理解 Right集合 的意义_ 考虑从串 S 的 i 位置开始走，走到了位置 j ，当前状态为 u 那么 Right(u) 包含 j ，同时 min(u) &lt;= i-j+1 &lt;= max(u) 当走到某个状态时，已经匹配的串已经失去原有的信息，它可以是满足这个状态的任意串，因为在 SAM 中这些串都是等价的 状态数的线性性若 Right(a)，Right(b) (|a|&gt;|b|)中有公共元素 那么 串 a 是串 b 的后缀 ，Right(b) 是 Right(a) 的 真 子集 所以任意两个节点 要么没有交集，要么是真包含 令 Right(par[u]) 是 Right(u) 的最小超集 这种关系构成一棵 Parent树 （满足 任意节点至少两个子节点，性质显然） 节点数 $O(n)$ 例如串 aaabbabd 的 ParentTree 注意那些叶子节点还有其他含义 一个重要性质max[parent[u]] + 1 = min[u] 转移数的线性性考虑搞一棵有向生成树 对于一条非连续的边 $(a,b)$ 构造从根到状态 a 的路径 + (a-&gt;b) + b 到任意一个 end状态 这必然是一个后缀 （不然这条边有什么用） 显然一个非树边至少被一个后缀所对应 而后缀至多对应到一条非树边 所以非树边的数量不会超过后缀的数量 边也是 $O(n)$ 的，SAM是个线性结构 其他的性质 子串的个数，就是状态中 Right集合 的大小 一个节点的 Right集合 是对应子孙的所有叶子节点的并集 （+ 前缀） 按照 dfs序 排列，一个节点的 Right集合 就是一段区间，可以快速求出一个子串的所有出现位置 考虑一个状态 s ，它的 Right集合 为 $\\{r_1,r_2,r_3,\\cdots,r_k\\}$。 加入有一条 s-&gt;t 标号为 c 的边，考虑 t 的 Right 集合，由于多了一个字符，s 的 Right 集合中，只有$S[r_i+1]=c$ 的 $r_i$ 符合要求，于是 t 的 Right 集合为 $\\{r_i+1\\}$ 那么如果 s 出发有标号为 x 的边，那么 Parent(s) 出发必然也有 反证法可以证明：$\\mathrm{Right}(\\mathrm{trans}(s,c)) \\subset \\mathrm{Right}(\\mathrm{trans}(\\mathrm{Parent}(s),c))$ 如果有 s-&gt;t ，Max(t) &gt; Max(s) （根据 Right集合 的定义，这条性质显然，同时能够保证 SAM 是个 DAG ） 线性构造 SAM，前方高能！掉线用户请重连！每次添加一个字符，并更新 SAM 使得它包含这个新字符 令当前字符串为 T ，新字符为 x 考虑所有表示 T 的后缀（也就是 Right集合 中包含 |T| ）的节点 $v_1,v_2,v_3,\\cdots,v_k$ 必然 存在 Right(p) $=\\{|T|\\}$ 的节点 p $v_1,v_2,v_3,\\cdots,v_k$ 由于 Right集合 都含有 |T| ，那么它们在 Parent树 中必然全是 p的祖先 同时我们添加一个字符 x 后，令 np 表示 Right(np) $=\\{|T|+1\\}$ 的节点 不妨让他们从后代到祖先排为 $v_1=p,v_2,v_3,\\cdots,v_k=root$ 考虑其中一个 v，其 Right集合，$\\{r_1,r_2,\\cdots,r_n=|T|\\}$ 如果它没有标号为 x 的边，它的 Right集合 没有 $r_i$ 满足 $s[r_i+1]=x$ 也就是只能达到 $\\mathrm{Right(u)} = {|T|+1}$ 的状态 $u$ 于是让它连一条到 np ，标号为 x 的边 $$\\Large \\Longrightarrow$$ 这一部分请仔细体会 假设 $v_p$ 是第一个存在标号 $x$ 的边，其中 $\\mathrm{trans}(v_p,x)=q$ 那么 q 的 Right集合 是 $\\{r_i+1 : S[r_i + 1]=x\\}$ 但是我们不一定能够直接插入 $|T|+1$ 到 $q$ 接下来分成两种情况： $\\max(q)=\\max(v_p)+1$ ，$np$ 满足条件范围为 $[\\max(v_p)+1,|T|+1]$ 此时 $q$ 代表的所有串的 right集合 仍然相同 那么直接令 $\\mathrm{parent}(np)=q$ 可以发现 $v_p$ 及其祖先的 x 转移的 Right集合 都并上了 |T|+1 否则 $\\max(q)&gt;\\max(v_p)+1$ 这种情况下 $q$ 代表的串中，长度不超过 $\\max(v_p)+1$ 的串的 Right集合 会多出一个值 |T|+1 ，而长度更大的其他串不会 于是我们新建一个节点 nq ，代表原来 $q$ 中长度不超过 $\\max(v_p)+1$ 的串，于是 $\\mathrm{Right}(nq)=\\mathrm{Right}(q) \\cup \\{|T|+1\\},\\;\\max(nq)=\\max(vp)+1$ $\\mathrm{parent}(nq)=\\mathrm{parent}(q)，\\mathrm{parent}(q)=\\mathrm{parent}(np)=nq$ $|T|+1$ 开始不能转移，所以 $nq$ 的转移可以从 $q$ 复制过来 会存在 $v_p, \\cdots, v_e$，$\\mathrm{trans}(v,x)=q$，那么把它设置为 $nq$ 即可 （显然 $\\max(\\mathrm{trans}(v_t)) \\leq \\max(v_p)=\\max(nq)$ ，可以转移） 如果始终不存在这样的点，令 parent(np)=root 即可 SAM模板 12345678910111213141516171819struct node &#123; int p[26], pa, val; &#125; t[maxn&lt;&lt;1];int size = 1, root = 1, last = 1;void extend(int c) &#123; int p = last, np = ++size, q, nq; t[np].val = t[p].val + 1; for(; p &amp;&amp; !t[p].p[c]; p = t[p].pa) t[p].p[c] = np; if (!p) t[np].pa = root; else &#123; q = t[p].ch[c]; if (t[q].val == t[p].val + 1) t[np].pa = q; else&#123; nq = ++size; t[nq] = t[q]; t[nq].val = t[p].val + 1; t[q].pa = t[np].pa = nq; for(; p &amp;&amp; t[p].p[c] == q; p = t[p].pa) t[p].p[c] = nq; &#125; &#125; last = np;&#125; 以串 aabbabd 为例，我们看一下它是如何构造的，此处的 len 即为 $\\max(u)$，重点为图3至图4 我们来考虑图3至图4的改变，泥萌可能会说： 不是只要把 5 接在 4 后面就好了嘛…. 但是会发现此时 4 的 Right集合 为 $\\{3,4\\}$ ，$[\\min,\\max]=[1,3]$ 也就是说能代表状态 aab,ab,b,abb,bb,b ？ 但是实际上只能代表 abb,ab,b,b 所以我们不能把 |T|+1 放入 4，必须要新建一个 6 ，6 是 4 和 5 的并集 剩下的构造过程自行体会…. 常见套路拓扑序DP在 SAM 上走，是拓扑序正序 在 parent树 上走，是拓扑序逆序 如何求出拓扑序？ 如何求 right集合 ？首先，在所有前缀所在状态的 Right集合 中加入 $i$ 可以按照 parent树 ，平衡树启发式合并 or 线段树合并得到 right集合 利用 parent树由于是一棵树，所以就可以干很多事情… 树上倍增、LCT、点分治… 自行想象 建出后缀树这个之后再讲 不就是反串的 Parent树 嘛 一些简单的经典应用泥萌赶紧来秒题！ 一些简单小应用，SAM 可以用来… 求最小循环同构！Hint：倍长，走标号最小的转移 求所有长度为 1..|S| 的子串的出现次数最大值！Hint：Right集合 大小即为出现次数 SPOJ SUBLEX 给定一个字符串，问所有本质不同的非空子串中，字典序第 $K$ 大的 $n \\leq 90000, Q \\leq 500$ 思考5min… 考虑建出 SAM ，$f[i]$ 表示从状态 $i$ 出发的方案数 正着贪心即可求出第 $K$ 大 SAM 是个 DAG ，那么如何求出拓扑序？ 注意到一个重要性质 SAM 中的转移一定是从 Max 较小的状态 到 Max 严格大于它的状态 类似后缀数组，用一个桶记录一下即可 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;#define rep(i,a,b) for (int i=(a); i&lt;=(b); i++)using namespace std;const int maxn = 200005;struct SAM &#123; int p[26], pa, val; &#125; t[maxn];int tax[maxn], cur[maxn], n, Q, now, v;int root = 1, size = 1, last = 1;long long f[maxn], K;char s[maxn];void extend(int c) &#123; &#125;int main() &#123; scanf(\"%s\", &amp;s); n = strlen(s); rep (i, 0, n-1) extend(s[i]-'a'); rep (i, 1, size) ++tax[t[i].val], f[i] = 1; rep (i, 1, size) tax[i] += tax[i-1]; rep (i, 1, size) cur[size+1-(tax[t[i].val]--)] = i; //注意这是拓扑序的倒序 rep (i, 1, size) rep (j, 0, 25) f[cur[i]] += f[t[cur[i]].p[j]]; scanf(\"%d\", &amp;Q); while (Q--) &#123; scanf(\"%lld\", &amp;K); now = 1; while (K) &#123; rep (i, 0, 25) if (v = t[now].p[i]) if (f[v] &gt;= K) &#123; putchar('a'+i); now = v; --K; break; &#125; else K -= f[v]; &#125; puts(\"\"); &#125; return 0;&#125; SPOJ LCS 给两个长度小于 100000 的字符串 A 和 B ，求出他们的最长公共连续子串 思考5min… 对 A 建 SAM ，读入 B 放进 SAM 跑就好了 严肃.jpg 令当前状态为 s ，同时最大匹配长度为 len 我们读入字符 x 。如果 s 有标号为 x 的边，s=Trans(s,x),len = len+1 否则我们找到s的第一个祖先anc，它有标号为x的边 令 s=Trans(anc,x), len=Max(anc)+1 如果没有这样的祖先，那么令 s=root,len=0 在过程中更新状态的最大匹配长度 思考：如果是 $n\\;(n \\leq10)$ 个串呢？ SPOJ LCS2 同样建出其中一个串的 SAM 考虑一个状态 $s$，如果 A之外其它串对它的匹配长度分别是 $a_1,a_2,\\cdots,a_{n-1}$ 用 $\\min(a_1,a_2,\\cdots,a_{n-1},\\max(s))$ 更新答案 更多例题 BZOJ1396 识别子串 给定一个字符串，对于每一个位置，求包含这个位置，同时只在串中出现一次的最短的串的长度 $|S| \\leq 10^5$ 思考10min… 注意到 只出现 $1$ 次 这个性质，我们可以找出所有 Right集合 元素个数为 1 的状态 按照拓扑序倒着转移，得到所有 Right集合 的元素个数 右端点固定，左端点可以移动 两个线段树维护，直接标记永久化，最后 $O(n)$ 递归即可 Codeforces 316G3 Good Substrings 求字符串 $s$ 有多少本质不同的子串是好的，一个字符串 $t$ 是好的，当且仅当它满足所有的 $n$ 条规则，$t$ 在 $p_i$ 中出现了 $l_i$ 到 $r_i$ 次 $|s|,|p_i| \\leq 50000, n \\leq 10$ 此题难度较大，我直接讲… 考虑把 $s$ 和 $p_i$ 用特殊字符隔开，连成一个字符串（注意 $s$ ，一定要放在最前面），建 SAM 按照拓扑序倒着 DP 即可得到 SAM 在所有子串中的出现次数，记 cnt[i][j] 表示自动机状态 $i$ 在 $p_i$ 中的出现次数，其中 $p_0=s$ 我们考虑所有满足 cnt[i][0] &gt; 0 的状态 u ，只要 $\\forall i, l[i] \\leq cnt[u][i] \\leq r[i]$ ，就要把答案加上 $\\max(u) - \\min(u)+1$ 我们为什么一定要把 $s$ 放在最前面呢？ 如果状态 $u$ 的 $cnt[0]$ 不为 $0$ ，那么状态 $u$ 所代表的子串 一定不会横跨分隔字符 ！ 这也就保证了：如果一个状态 Right集合 的某个元素（注意这仅仅只是右端点）在某个匹配串中，整个串一定在这个匹配串中 代码同样简单易懂 比 SA 高到不知道哪里去了 12345678910111213141516171819202122232425void extend(int c, int pos) &#123; ... cnt[np][pos] = 1; ... //注意 cnt 不要放在结构体里！&#125;int main() &#123; scanf(\"%s%d\", &amp;s, &amp;n); for (int i=0; s[i]; i++) extend(s[i] - 'a', 0); extend(26, n+1); rep (j, 1, n) &#123; scanf(\"%s%d%d\", &amp;s, &amp;l[j], &amp;r[j]); for (int i=0; s[i]; i++) extend(s[i] - 'a', j); extend(26, n+1); &#125; rep (i, 1, size) tax[t[i].val]++; rep (i, 1, size) tax[i] += tax[i-1]; per (i, size, 1) cur[tax[t[i].val]--] = i; per (i, size, 1) &#123; u = cur[i]; rep (j, 0, n) cnt[t[u].pa][j] += cnt[u][j]; if (!cnt[u][0]) continue; flag = 1; rep (j, 1, n) flag &amp;= (l[j] &lt;= cnt[u][j] &amp;&amp; cnt[u][j] &lt;= r[j]); if (flag) ans += t[u].val - t[t[u].pa].val; &#125; printf(\"%d\\n\", ans); return 0;&#125; 引入广义后缀自动机平常的 SAM 都是只能搞一个串的，但是我们也可以将多个字符串建成 Tire 再造广义 SAM 在这里，right集合 的定义变为在每个串中出现的位置之并。通常用来维护多个独立的串（没写过不知道）或者一棵 Trie树 考虑建立多个串的 SAM ，构造时一个一个串插入，插入完一个串后将 last 设为 root 再重新开始 考虑建立 Trie 的 SAM 。插入完 Trie 节点 u 的时候记录一下 tmp = last ，然后插入完 u 的某个子树后，再将 last 赋为 tmp ，再插入另一个子树。 也就是每个节点将父节点所在前缀的状态作为 last 但是 广义SAM 插入字符 w 时可能会发现 last 的 w 转移边已经存在，设转移到的状态为 $q$ ，假如 $\\max(q) = \\max(last) + 1$ ，那说明当前前缀处于状态 q 中，就不作任何操作。否则新建一个状态 nq ，当前这个前缀处于 nq 中，然后类似构造普通 SAM 的时候一样更新一下 q 和 nq 的信息 也就是说，不用任何改变… 正确性自行想象 我也不会 BZOJ 3926 [ZJOI2015]诸神眷顾的幻想乡 给定一棵树，每个节点都有一个字符，满足树的叶子节点数不超过 $20$ ，问这棵树的所有路径中所有本质不同的子串个数 $n \\leq 100000$ 考虑以所有叶子节点作为根，DFS 插入字典树 广义SAM 跑一下即可 放了 std （此处应展示代码） 来看一道比较难的题 Codeforces 700E Cool Slogans 给你一个长度为 $n$ 的字符串 $S$ ，求最长的一个字符串序列 $a[1..k]$ 满足序列中的每一个字符串都是 $S$ 的子串，且对于任意的$1&lt;i \\leq k$ 都有 $a[i−1]$ 在 $a[i]$ 中至少出现两次。两次出现允许重叠。 问最大满足条件的 $k$ 是多少 $n \\leq 200000$ 思考20min… Hint: 一个重要性质：$a[i-1]$ 必定为 $a[i]$ 的后缀（前缀同理） 否则后面那些字符都是没用的，可以删去 发现选择的字符串一定是 SAM 一条链上的 还有一个性质：因为状态中 Right集合 所代表的所有字符串等价（短串能去转移，长串也一定能去转移） 所以我们可以考虑选择长度为 $\\max(u)$ 的串，而且更长的串更任意被转移到 说实话，我似乎想了2h还是不太懂…. 泥萌如果能yy出来的话教一下我啊QAQ 似乎有人有同样的疑问，假装是对的。。。 是的，我用了删除线，那么我就来口胡一波！其实是问了某位 dalao + 自己好好整理过了 结论：当前状态 $S$ 到其他状态最长串的转移一定是最优的 考虑数学归纳法，显然对于 $\\max$ 为 $|S|$ 的状态，结论是满足的 假设对于 $|b|&gt;k$ 满足条件 对于 $|b|=k$ 不满足，当且仅当某个状态 $S’$ 只能由较短串 $a\\;(|a|&lt;|b|)$ 转移，不能由某个状态的最长串 $b$ 转移，满足 $f[a] \\leq f[b]$ （也就是 $S’$ 可以由两个 $a$ 构成，只能由一个 $b$ 构成，且 $S’$ 的某个前缀是 $b$ 的后缀） 我们考虑这样一个串 $S’’$ ，是由 $S’$ 左端点左移得到的，且满足 $b$ 是它的前缀 显然 $f[S’’] \\geq f[S’]$ ，考虑他们能转移的状态 如果能转移到的最优状态相同，结论成立 否则就变成了之前的情况，根据假设，结论成立 也就是 $|b|=k$ 时满足条件 可能还需要好好理解 于是可以考虑 DP[x] 表示 x 到根这条链上选若干个字符串出来组成 a 数组的最大长度，pos[x] 表示 a[dp[x]] 具体是哪一个位置 （显然，长度相同的，越靠前越好） 考虑 x 从 pos[pa[x]] 转移 只需要判断一下它的 Right集合 即可 用线段树合并求出 感谢 题解 此题还有 SA 做法 练习大概 Codeforces 更好一点？ BZOJ 2806 [CTSC2012]Cheat BZOJ 1921 [CTSC2010]珠宝商 BZOJ 3998 [TJOI2015]弦论 BZOJ 4032 [HEOI2015]最短不公共子串 BZOJ 4566 [HAOI2016]找相同字符 CF 616F Expensive Strings CF 235C Cyclical Quest CC TSUBSTR Substrings on a Tree CC TMP01 To Queue or not to Queue 广义 BZOJ 2780 [SPOJ8093]Sevenk Love Oimaster BZOJ 3473 字符串 51Nod 1869 那些年，我们一起讲的故事 更多应用可以参考 张天扬的集训队论文 后缀树（此处应手画 aabbabd 的后缀树） 几个重要性质： 反串构造一个 SAM ，那么它的 parent树 就是原串的后缀树 后缀树上一个点的父亲到它的转移串，就是这个点在 parent树 上对应区间的逆序串 如果再 DFS 一遍后缀树，就可以得到后缀数组 为什么第一个性质成立？ 考虑 S 的 parent树 ，叶子节点一定包含 S 的某个前缀，从叶子节点往上走，节点里的串长度越来越小，直到走到根（包含一个空串），并且父亲节点中的串是儿子节点中的串的后缀。如果将这个过程反过来考虑，正好像是在 $S_r$ 的后缀 Trie 上从上往下走 哇！看起来很简单的样子 那么，我们来做题辣！ 小🌰 Codechef KILLKTH Killjee and k-th letter 给定一个字符串 $S$ ，将这个字符串的所有子串按照字典序排列，得到一个更长的串，每次询问第 $k$ 个字符，强制在线。 $|S|,Q \\leq 2 \\times 10 ^ 5$ 思考 10min… 来自 RXDoi 的纯正题解！ 任轩笛 2018/1/8 星期一 下午 1:47:53搞个后缀树 任轩笛 2018/1/8 星期一 下午 1:47:55求个前缀和 任轩笛 2018/1/8 星期一 下午 1:47:59二分以下 任轩笛 2018/1/8 星期一 下午 1:48:09再在树上倍增一下就行了吧 当然 SA 也是可以做的 二分答案可以找到是由那个节点做出贡献 树上倍增用于找到对应的位置 比较麻烦是提取所有树边上的串 考虑最终为区间 $[l[i],r[i]]$ 一开始建状态的时候，默认 $r[i]=n$ 然后 BFS ，似乎还有一个结论可以找到，并不是很懂 123456789for (int i=2; i&lt;=size; i++) in[T[i].pa] += (T[i].pa != 1);for (int i=2; i&lt;=size; i++) if (!in[i]) q[qr++] = i;while (ql &lt; qr) &#123; u = q[ql++]; tmp = T[u].pa; if (!(--in[tmp])) q[qr++] = tmp; l[u] = r[u] - (T[u].val - T[tmp].val) + 1; r[tmp] = min(r[tmp], l[u] - 1); e[tmp][s[l[u]]-'a'] = u;&#125; 记得当时写了 5h？ 练习BZOJ 3413 匹配 BZOJ 3238 [AHOI2013]差异 BZOJ 3879 SvT Codeforces 917E Upside Down std才9KB... 编不下去了 &gt;.&lt;THE END.","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"「学习笔记」线性分治","date":"2017-12-31T15:59:57.000Z","path":"2017/12/31/Algorithms-Divide-and-Conquer/","text":"嘛，分治应该是一个比较有意思的一个东西。蒟蒻Cyani也来学一发姿势辣。。 前置技能分治为什么更好？按照我的理解：分治的复杂度更优，往往基于减少一些 重复 的运算。这就需要我们去把大问题划分为若干个小问题，这些小问题的公共部分就可以利用一些技巧求解。 分治的复杂度计算。主定理！ 一般地，一个分治的时间复杂度可以表示为： $$\\large T(n) = a \\times T(n/b) + f(n)$$ 画出递归树，或者暴力展开就会发现： $$\\large T(n) = O(n ^ {\\log _ b a} + \\sum _ {i=0} ^ {\\log _ b n - 1} a ^ i f( \\frac n {b ^ i}))$$ 其中左边是递归底层的总复杂度，右边是非底层的复杂度。要计算 $T(n)$ 的渐进复杂度，就要比较 $f(n)$ 与 $O(n ^ {\\log _ b a})$ 的阶。 情况一， $f(n) &lt; O(n ^ {\\log _ b a})$可以证明得到： $$\\large T(n) = O(n ^ {\\log _ b a})$$ 可以发现，递归树的每一层都比上一层高出指数级。即叶子部分是时间复杂度的主体。 情况二， $f(n) = O(n ^ {\\log _ b a} \\times \\log ^ k n )$可以证明得到： $$\\large T(n) = O(n ^ {\\log _ b a} \\times log ^ {k+1} n)$$ 可以发现，递归树每一层代价都相同。总共有 $O(\\log n)$ 层，复杂度要乘以 $log$ 。 情况三， $f(n) &gt; O(n ^ {\\log _ b a})$可以证明得到： $$\\large T(n) = O(f(n))$$ 可以发现，递归的主要代价都在树根。 CQD分治一般形式定义过程 $Solve(l,r)$。假设运行 $Solve(l,r)$， 可以得到 $f[l..r]$ 的值/处理 $[l,r]$ 的询问。 $Solve(l, r)$ $Solve(l, mid)$ 考虑 $Solve(l, mid)$ 中的操作/询问，对 $[mid+1,r]$ 中的影响。 $Solve(mid+1, r)$ 离线算法。 常见应用：k维偏序问题的一般形式：$k$ 维空间中有 $n$ 个点。问最长的一个点的序列 $p1,p2,..$ ，使得 $pi$ 的所有坐标都比 $pi+1$ 小。 一维偏序：直接排序。 二维偏序：排序+树状数组。 三维偏序：树套树（？），利用CDQ分治转化为二维偏序，利用排序+树状数组解决。 首先按照 $z$ 轴排序。因为所有的修改操作都在查询操作之前。所以就与 $z$ 轴无关了。 一些题目 BZOJ4553-[TJOI2016]序列 有一个长度为 $n$ 的序列。有些位置上的数可能变化为另一个给定的数。但最多只会变化一个位置的上。问最长的一个子序列，使得不管怎样变化，这个子序列始终是非递减的。 三维偏序，DP。 计算每个位置能变成的最大值 $r[i]$ ,最小值 $l[i]$。当且仅当 $j&lt;i,r[j] \\leq x[i],x[j] \\leq l[i]$ 时能够转移。发现是一个三维偏序，cdq分治即可。 注意，我们需要先处理子问题 $[l,mid]$,再处理 $[l,mid]$ 对 $[mid+1,r]$ 的贡献。最后递归处理 $[mid+1,r]$ 。 普通分治没有固定的套路，直接来看一些题： BZOJ4237-稻草人 在平面上有 $n$ 个点 $(xi,yi)$ 。问存在多少点对 $(pi,pj)$ 满足 $xi&lt;xj,yi&lt;yj$ 且这两个点对构成的矩形内部不存在其他点。 按x轴分治。 首先按照 $x$ 轴排序，然后分治。考虑划分为两个点集之后，如何求出满足条件的点对数？ 单调栈！考虑左边维护一个随着 $y$ 增大， $x$ 变小的一个单调栈。右边维护一个随着 $y$ 增大，$x$ 也增大的单调栈。对于右边的点，找出它最多能向下延伸到的位置。在左边二分查找能对应的点。 BZOJ2458-[BeiJing2011]最小三角形 在平面上有若干个点。选取三个点，使得这三个点的距离之和最小。 计算几何，分治。 做法类似于一个经典问题：平面最近点对。可以做到复杂度 $O(n \\log n)$（利用抽屉原理证明）。此题也是类似。 考虑首先按照 $x$ 轴分治，递归处理两边。再考虑横跨的情况。假设当前的最优解为 $ans$ ，那么就要取与 $x[mid]$ 差不超过 $ans/2$ 的所有点。然后单调扫描，可以找到与当前点 $y$ 相差不超过 $ans/2$ 的所有点。根据抽屉原理，这个边长为 $ans$ 的正方形中，不会有超过 $8$ 点。所以这一部分的时间复杂度是 $O(n)$ 的。如果用归并排序的方法，就可以做到 $O(n \\log n)$。 BZOJ2287-[POJChallenge]消失之物 与普通的01背包类似。不过需要你求出，当某个物品不存在时，放置的方案总数。 经典的分治背包。 考虑按照物品分治，第 $i$ 个物品存在的时间为 $[1,i-1],[i+1,n]$。 然后分治的过程中DP即可。复杂度 $O(n^2 \\log n)$ 。 BZOJ4025-二分图 给定一个图，每条边有一个存在的时间范围。问每一时刻，是否是一个二分图。 按时间分治，并查集。 显然可以按时间分治。而判断而二分图就可以用经典的带权并查集，需要按秩合并。 注意处理权值的方法。似乎有必要贴代码？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define rep(i,a,b) for (int i=(a); i&lt;=int(b); i++)using namespace std;inline int read() &#123; char ch = getchar(); int x = 0, op = 1; while (ch &lt; '0' || '9' &lt; ch) &#123; if (ch == '-') op = -1; ch = getchar(); &#125; while ('0' &lt;= ch &amp;&amp; ch &lt;= '9') &#123; x = x * 10 + ch - '0'; ch = getchar(); &#125; return op * x;&#125;const int maxn = 200009;struct node &#123; int u, v, s, t; &#125; a[maxn];int pa[maxn], rk[maxn], val[maxn], ans[maxn], n, m, T, top;int stk[maxn]; vector&lt;int&gt; p;int getpa(int x) &#123; while (pa[x] != x) x = pa[x]; return x;&#125;int getdist(int x) &#123; int res = 0; while (pa[x] != x) &#123; res ^= val[x]; x = pa[x]; &#125; return res;&#125;void link(int x, int y) &#123; int tmp = getdist(x) ^ getdist(y) ^ 1; x = getpa(x); y = getpa(y); if (rk[x] &lt; rk[y]) swap(x, y); if (rk[x] == rk[y]) &#123; rk[x]++; stk[++top] = -x; &#125; pa[y] = x; val[y] = tmp; stk[++top] = y;&#125;void del(int bot) &#123; int x; while (top != bot) &#123; x = stk[top--]; if (x &gt; 0) pa[x] = x; else rk[-x]--; &#125;&#125;void solve(int l, int r, vector&lt;int&gt; &amp;p) &#123; int mid = (l + r) &gt;&gt; 1, u, v, bot = top; vector&lt;int&gt; L, R; rep (i, 0, p.size()-1) if (a[p[i]].s &lt;= l &amp;&amp; r &lt;= a[p[i]].t) &#123; u = a[p[i]].u; v = a[p[i]].v; if (getpa(u) == getpa(v))&#123; if (!(getdist(u) ^ getdist(v))) &#123; del(bot); return; &#125; &#125; else link(u, v); &#125; else &#123; if (!(a[p[i]].t &lt; l || mid &lt; a[p[i]].s)) L.push_back(p[i]); if (!(a[p[i]].t &lt; mid+1 || r &lt; a[p[i]].s)) R.push_back(p[i]); &#125; if (l == r) &#123; ans[l] = 1; del(bot); return; &#125; solve(l, mid, L); solve(mid+1, r, R); del(bot);&#125;int main() &#123; n = read(); m = read(); T = read(); rep (i, 1, m) &#123; a[i].u = read(); a[i].v = read(); a[i].s = read()+1; a[i].t = read(); p.push_back(i); &#125; rep (i, 1, n) &#123; pa[i] = i; rk[i] = 1; &#125; solve(1, T, p); rep (i, 1, T) puts(ans[i] ? \"Yes\" : \"No\"); return 0;&#125; BZOJ4456-[ZJOI2016]旅行者 有一个 $n \\times m \\leq 20000$ 的网格图。给定每条边的代价。$Q$ 个询问，每个询问需要回答从 $(sx,sy)$ 到 $(tx,ty)$ 的最短路。 分治最短路。 考虑按照矩形的较短边来分治，所以只需要考虑跨过分界线的答案即可。求出分界线上的单源最短路，然后处理在这个矩形内的询问就好了。 看上去复杂度不优？最重要的还是利用主定理分析时间复杂度，%%%jry_2。 如果每一次按照长边分治：（以下S表示矩形的当前面积，n表示矩形的总面积） $$T(S) = 2T(S/2) + O(S \\sqrt n \\log S)$$ 解得：（将 $O(\\sqrt n)$ 提出） $$T(n) = O( n \\sqrt n \\log ^2 n)$$ 每次按照短边分治： $$T(S) = 2T(S/2) + O(S \\sqrt S \\log S)$$ 解得： $$T(n) = O(n \\sqrt n \\log n)$$ 按照短边分治可以少一个 $\\log$ 。 整体二分对于某些具有单调性的问题，我们可以二分答案。然后用各种方法，DP，贪心，数据结构来判断。 但是， 如果有多个询问，那么里面再套数据结构。复杂度好像就不太对了。事实上，很容易发现，多次二分答案时，很多数据结构的操作都是重复的。 所以就可以整体进行二分。 一般形式定义分治过程 $Solve(Q, l, r)$。其中 $Q$ 是询问/操作的序列，$[l,r]$ 是询问的答案范围。 $Solve(Q, l, r)$ 如果 $l = r$ ，那么把所有的答案设置为 $l$ 。退出。 取 $mid = (l + r) / 2$ ，是当前判断的答案。 考虑 $Q$ 中的每一个操作/询问（注意一定要按照时间排序！） 如果是操作，那么执行对 $[l,mid]$ 有影响的操作。同时划分到 $Ql\\ or\\ Qr$。 如果是询问，按照是否达到要求的贡献，划分到 $Ql\\ or\\ Qr$。注意划分到 $Qr$ 时，要减去现有的贡献。 $Solve(Ql, l, mid), Solve(Qr, mid+1, r)$ 一些题目 BZOJ3110-[ZJOI2013]K大数查询 有 $n$ 个位置，$m$ 个操作。操作有两种，每次操作如果是 $(1,a,b,c)$ ,表示在第 $a$ 个位置到第 $b$ 个位置，每个位置加入一个数 $c$。如果是 $(2,a,b,c)$ ，表示询问从第 $a$ 个位置到第 $b$ 个位置，第 $c$ 大的数是多少。 经典的整体二分。 在整体二分的过程中，用线段树维护区间内权值 $[l,mid]$ 的数的个数。根据与 $K$ 的关系，来划分到更小的答案范围。 注意有时间限制，所以所有的操作都需要按照时间排序。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;bits/stdc++.h&gt;#define rep(i,a,b) for (int i=(a); i&lt;=int(b); i++)#define lc (o &lt;&lt; 1)#define rc (o &lt;&lt; 1 | 1)#define Mid ((l + r) &gt;&gt; 1)using namespace std;typedef long long LL;inline int read();const int maxn = 100009;struct segment &#123; LL sum; int add, clr; &#125; T[maxn&lt;&lt;2];struct ask &#123; int op, id, l, r, k; LL val; bool operator &lt; (const ask &amp;a) const &#123; return k &lt; a.k || k == a.k &amp;&amp; id &lt; a.id; &#125;&#125; q[maxn];int n, m, ans[maxn];void init(int o) &#123; T[o].sum = T[o].add = 0; T[o].clr = 1; &#125;void pushdown(int o, int l, int r) &#123; if (T[o].clr) &#123; init(lc); init(rc); T[o].clr = 0; &#125; if (T[o].add) &#123; T[lc].sum += 1LL * (Mid - l + 1) * T[o].add; T[rc].sum += 1LL * (r - Mid) * T[o].add; T[lc].add += T[o].add; T[rc].add += T[o].add; T[o].add = 0; &#125;&#125;void pushup(int o) &#123; T[o].sum = T[lc].sum + T[rc].sum; &#125;void update(int o, int l, int r, int x, int y, int z) &#123; if (l == x &amp;&amp; y == r) &#123; T[o].sum += 1LL * (r - l + 1) * z; T[o].add += z; return; &#125; pushdown(o, l, r); if (x &lt;= Mid) update(lc, l, Mid, x, min(Mid, y), z); if (Mid+1 &lt;= y) update(rc, Mid+1, r, max(Mid+1, x), y, z); pushup(o);&#125;LL query(int o, int l, int r, int x, int y) &#123; if (l == x &amp;&amp; y == r) return T[o].sum; pushdown(o, l, r); if (y &lt;= Mid) return query(lc, l, Mid, x, y); if (Mid+1 &lt;= x) return query(rc, Mid+1, r, x, y); return query(lc, l, Mid, x, Mid) + query(rc, Mid+1, r, Mid+1, y);&#125;void solve(int l, int r, int ql, int qr) &#123; if (l &gt; r || ql &gt; qr) return; if (l == r) &#123; rep (i, ql, qr) if (q[i].op == 2) ans[q[i].id] = l; return; &#125; int mid = (l + r) &gt;&gt; 1, tmp = ql-1; LL sum; init(1); rep (i, ql, qr) if (q[i].op == 1) &#123; if (q[i].val &gt; mid) &#123; q[i].k = 1; update(1, 1, n, q[i].l, q[i].r, 1); &#125; else &#123; tmp++; q[i].k = 0; &#125; &#125; else &#123; sum = query(1, 1, n, q[i].l, q[i].r); if (sum &gt;= q[i].val) q[i].k = 1; else &#123; tmp++; q[i].k = 0; q[i].val -= sum; &#125; &#125; sort(q+ql, q+qr+1); solve(l, mid, ql, tmp); solve(mid+1, r, tmp+1, qr);&#125;int main() &#123; n = read(); m = read(); rep (i, 1, m) &#123; q[i].id = i; q[i].op = read(); q[i].l = read(); q[i].r = read(); q[i].val = read(); if (q[i].op == 1) q[i].val = q[i].val+n; &#125; memset(ans, 0x3f, sizeof ans); solve(0, 2*n, 1, m); rep (i, 1, m) if (ans[i] &lt;= 1e9) printf(\"%d\\n\", ans[i]-n); return 0;&#125;","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"「学习笔记」数论函数","date":"2017-12-31T15:59:56.000Z","path":"2017/12/31/Algorithms-Number-Theoretic-Function/","text":"UPD 2017.12.26 重新学了一发莫比乌斯反演，算是会一些套路了？ UPD 2017-12.28 完结，撒花！ 其实数论真的很优美毒，不是吗？ 前置技能定义数论函数。 定义域为正整数的函数。以下默认所有数都是正整数。 积性函数。 对于所有 $\\gcd (a,b) = 1$ ， $f(ab) = f(a)f(b)$ 。一定会满足 $f(1) = 1$。 完全积性函数。 对于 任意 的 $a,b$， $f(ab) = f(a)f(b)$ 。 在实际应用中，用到的大多都是 积性函数。 积性函数的性质积性。 若 $f,g$ 为积性函数， 那么 $(fg)(n) = f(n)g(n), (\\frac f g)(n) = \\frac {f(n)} {g(n)}$ 也都是积性函数。 用线性筛求 $[1,n]$ 的积性函数。 令 $n = \\prod p _ {i} ^ {k_ i}$ ,那么 $f(n) = \\prod f(p _ {i} ^ {k_ i})$ 。 所以在线性筛的时候，有一种方法就是 计算所有 $f(p_i) ^{k_i}$ 再相乘 。 另一种方法是，考虑增加一个最小质因子后的变化。 常见的积性函数及其性质欧拉函数，积性。 $\\varphi(n) = \\sum _ {i=1} ^n [\\gcd(n,i)=1]$ 表示 $[1,n]$ 中与 $n$ 互质的数的个数。 直接根据欧拉函数的定义就可以得到一些有用的式子。比如：（注意利用 $\\gcd(n,i) = \\gcd(n,n-i)$，以及 $n=1$ 时少算了一次 ） $$\\sum _ {i=1} ^ n i \\cdot [\\gcd(n,i)=1] = \\frac 1 2 \\times (n \\cdot \\sum _ {i=1} ^{n} [\\gcd(n,i)=1] + [n=1]) = \\frac {n \\cdot \\varphi(n) + [n=1]} 2 \\tag 1$$ $$\\sum _ {i=1} ^ n \\sum _ {j=1} ^ n [\\gcd (i, j) = 1] =2 \\sum _ {i=1} ^n \\varphi(i) - 1 \\tag {2}$$ 莫比乌斯函数，积性。 当 $n$ 含有平方因子 $\\mu(n) = 0$ , 否则 $n$ 为 $k$ 个不同的质因子乘积， $\\mu(n) = -1 ^{k}$ 。 除数函数，积性。 $\\sigma _ {k} (n)$ 表示 $n$ 的所有因数的 $k$ 次幂之和。 特别的，$d(n) = \\sigma _ {0} (n)$ ，表示 $n$ 的因数个数。 $\\sigma _ {1} (n) = \\sigma (n)$ ，表示 $n$ 的所有因数之和。 这个角标在上在下都是等价的！ 幂函数，完全积性。 $id _ {k} (n)$ ，表示 $n^k$ 。 特别的， $id _ {0} (n) = 1 (n) = 1$ 。 单位函数，完全积性。 当且仅当 $n=1$ 时， $e(n)=1$ ，否则 $e(n)=0$ 。 Dirichlet卷积定义两个数论函数 $f,g$ 的Dirichlet卷积。 $$\\large (f \\ast g)(n) = \\sum _ {d|n} f(d) \\times g(\\frac n d) \\tag{3}$$ 性质定义。 $(f+n)(n) = f(n) + g(n)$ . 交换律。 $f \\ast g = g \\ast f$ 结合律。 $(f \\ast g) * h = f \\ast (g \\ast h)$ 分配率。 $f \\ast (g + h) = f \\ast g + f \\ast h$ 单位元。 $f \\ast e = f$ 当 $f,g$ 为积性函数时， $f \\ast g$ 也为积性函数。 如果有一个积性函数 $f$ ，则一定存在 $g*f=e$ ， $g$ 就是 $f$ 的Dirichlet逆，也是积性函数。 已知数论函数 $f,g$ ，则可以枚举倍数，在 $O(n \\log n)$ 的时间内计算出 $f \\ast g$ 。 常见的Dirichlet卷积一个函数的约数和可以卷上1。 $$d(n) = \\sum _ {d|n} 1 \\Rightarrow d = 1 \\ast 1 \\tag{4}$$ $$\\sigma (n) = \\sum _ {d|n} d \\Rightarrow \\sigma = d \\ast 1 \\tag{5}$$ _极其重要的，莫比乌斯反演的基础_ $$\\large \\sum _ {d|n} \\mu(d) = \\sum _ {i=0} ^{k} (-1) ^{i} \\times \\binom k i = (1-1) ^{k} = e(n) \\Longrightarrow e = \\mu * 1 \\tag{6}$$ 另一个常用的卷积。 因为 $\\varphi(d)$ 表示与 $n$ 的最大公约数为 $\\frac n d$ 的数的个数，它们的和显然为 $n$ 。 $$\\large \\sum _ {d|n} \\varphi (d) = n \\Longrightarrow \\varphi \\ast 1 = id \\tag{7}$$ 莫比乌斯反演形式一：因数反演如果两个数论函数 $f,g$ 满足 $f = g \\ast 1$ ，也即 $$\\large f(n) = \\sum _ {d|n} g(d) \\tag{8}$$ 那么它们满足 $g = \\mu * f$ ，也即 $$\\large g(n) = \\sum _ {d|n} \\mu (d) \\times f(\\frac n d) \\tag {9}$$ 考虑证明 $f = g \\ast 1 \\Leftrightarrow g = \\mu \\ast f$ 已知 $$\\large f = g \\ast 1$$ 两边都卷上 $\\mu$ ,可得 $$\\large f \\ast \\mu = g \\ast \\mu \\ast 1 = g \\ast e = g$$ 已知 $$\\large f \\ast \\mu = g$$ 两边都卷上 $1$ ，可得 $$\\large g \\ast 1 = f \\ast \\mu \\ast 1 = f \\ast e = f$$ 本质？ $1$ 与 $\\mu$ 在 Dirichlet卷积意义下互为逆元。 形式二：倍数反演这就不是Dirichlet卷积了，不过也是对的。 $$\\large g(n) = \\sum _ {n|d} f(d) \\Longrightarrow f(n) \\sum _ {n|d} \\mu( \\frac d n) g(d) \\tag {10}$$ 变换技巧一些基本套路，多推推就熟练了。 1.枚举 $\\gcd$ 取值 2.交换枚举倍数与约数 3.用莫比乌斯函数求和替换 4.改写求和指标 5.得到一个整除分块的形式，处理一个函数的前缀和 最重要的还是保持恒等，利用 两种贡献 的思想。 一 有一个 积性函数 $f$，它与恒等函数 $1$ 的Dirichlet卷积 $g = f*1$ 如何计算？ 假设 $n = \\prod _ {i=1} ^{t} p _ {i} ^{ki}$ ，$g(n) = \\sum _ {d|n} f(n)$ 。那么就有 $$\\large g(n) = \\prod _ {i=1} ^{t} \\sum _ {j=0} ^{ki} f(p _ {i} ^{j}) \\tag{11}$$ 二整数分块技巧。 求 $\\sum _ {i=1} ^{n} f(i) \\times \\lfloor \\frac n i \\rfloor$ 注意到 $\\large \\lfloor \\frac n i \\rfloor$ 只有 $O(\\sqrt n)$ 种取值。对于固定的 $\\lfloor \\frac n i \\rfloor$ ， $i$ 的取值为 $$\\large \\left[ \\left \\lfloor \\frac n {\\lfloor \\frac n i \\rfloor+1} \\right \\rfloor+1, \\left \\lfloor \\frac n {\\lfloor \\frac n i \\rfloor} \\right \\rfloor \\right] \\tag{12}$$ 对于相同的 $\\lfloor \\frac n i \\rfloor$ ，我们只需要计算 $f(i)$ 的前缀和 即可。复杂度即是 $O(\\sqrt n)$。 同时有 $n,m$ 时同理。 三假设 $a \\ast b$ 已经是Dirichlet卷积，那么 $$\\large id _ {k} \\times (a \\ast b) = (id _ {k} \\times a) \\ast (id _ {k} \\times b) \\tag{13}$$ 再根据常用卷积 $id = \\varphi \\ast 1$ ，发现 $\\varphi$ 是连接两个相邻 $id$ 的桥梁，即 $$\\large (\\varphi \\times id _ {k}) \\ast id _ {k} = id _ {k+1} \\tag{14}$$ 四可以由两个常用卷积推出， $$\\large \\varphi (n) = \\sum _ {d|n} \\mu (d) \\times \\frac n d \\Longrightarrow \\varphi = \\mu \\ast id \\tag{15}$$ 五常见变换方式：约数与倍数的互换。 对于 $d,e,D=d \\times e$ 三项贡献的这种，可以枚举 $D$ 将其化为狄利克雷卷积，也可以枚举 $d$和 $e$ 化成带下取整的式子；一般来讲前者往往易于预处理，可以应付多组询问，后者则在单次询问中有优秀表现。 六最最最容易碰到的莫比乌斯套路。以后就直接作为结论 了： 现在有一个奇怪的函数 $f(n)$ ，不妨设 $n \\leq m$ ，那么， $$\\large { \\sum _ {i=1} ^ n \\sum _ {j=1} ^ m f(\\gcd(i,j)) \\\\ = \\sum _ {d=1} ^ n f(d) \\sum _ {i=1} ^ {\\lfloor \\frac n d \\rfloor} \\sum _ {j=1} ^ {\\lfloor \\frac m d \\rfloor } [\\gcd(i,j)=1] \\\\ = \\sum _ {d=1} ^ n f(d) \\sum _ {i=1} ^ {\\lfloor \\frac n d \\rfloor} \\sum _ {j=1} ^ {\\lfloor \\frac m d \\rfloor } \\sum _ {p|i,p|j} \\mu(p) \\\\ = \\sum _ {d=1} ^ n f(d) \\sum _ {p=1} ^ {\\lfloor \\frac n d \\rfloor} \\mu(p) \\cdot \\lfloor \\frac n {pd} \\rfloor \\cdot \\lfloor \\frac m {pd} \\rfloor \\\\ = \\sum _ {D=1} ^ n \\sum _ {d|D} f(d) \\cdot \\mu(\\frac D d) \\cdot \\lfloor \\frac n D \\rfloor \\cdot \\lfloor \\frac m D \\rfloor \\tag{16}}$$ 就变成要求 $f \\ast \\mu$ 的前缀和了，再套用分块即可。 杜教筛问题的一般形式给出一个奇怪的数论函数 $f(x)$ （simple一点像 $\\mu, \\varphi$ ）。接着给出了一个 $n$ ，一般有 $10^{10}$ 的范围。需要求 $S(n) = \\sum _ {i=1} ^{n} f(i)$ 模一个大数的值。 构造求出 $S(n)$ 会非常困难，考虑找出另一个函数 $g(x)$ ，考虑 $(f*g)(x)$ 的前缀和。 $$\\large \\sum _ {i=1} ^{n} \\sum _ {j|i} f(i) g(\\frac i j) = \\sum _ {ij \\leq n} f(i) g(j) = \\sum _ {i=1} ^{n} g(i) S(\\lfloor \\frac n i \\rfloor) $$ 于是， $$\\large g(1)S(n) = \\sum _ {i=1} ^{n} (f*g)(i) - \\sum _ {i=2} ^{n} g(i) S(\\lfloor \\frac n i \\rfloor)$$ 要求&amp;&amp;时间复杂度&amp;&amp;Trick需要保证 $(f*g)(x),g(x)$ 的前缀和都比较容易计算。 可以直接记忆化搜索，复杂度 $O(n^{\\frac 3 4})$ 。 可以预处理前 $k$ 个前缀和，复杂度 $O(k + \\frac n {\\sqrt k})$ 。取 $k=n^{\\frac 2 3}$ 最优，复杂度 $O(n ^ {\\frac 2 3})$ 。 对于 $\\mu(x),\\varphi(x)$ 的前缀和，我们令 $g(x) = 1$ 即可。 特别重要的！ 一个性质： $\\large \\left \\lfloor \\frac n {ab} \\right \\rfloor = \\left \\lfloor \\frac {\\left \\lfloor \\frac n a \\right \\rfloor} b \\right \\rfloor$ 因为 $\\frac n {n ^ {\\frac 2 3}} \\leq n ^ {\\frac 1 3}$ ，根据上述性质，杜教筛在筛的过程中，会被计算的 $s(x)$ 只有 $O(n ^ {\\frac 1 3})$ 个。 这个东西用于时间复杂度计算很有用！所以像分块套杜教筛啊，杜教筛套分块啊，复杂度都是对的！（只要都是不断整除 $n$） 还有一个 Trick ，我们不是要 HASH 吗，但是那个太慢了。 $S(x)$ 直接存到 $f[n/x]$ 里就好了（ $n$ 是全局的） 复杂的基本形式%%%jiry_2 有时候， $f(x)$ 本身就是两个函数的积/Dirichlet卷积，通常令 $g(x) = 1$ ，可以进一步化简。 推柿子啦啦啦来看一些有意思的题目。顺便….. BZOJ3560 DZY Loves Math V 求 $\\sum _ {i_1|a_1} \\sum _ {i_2|a_2} … \\sum _ {i_n|a_n}$ 。 欧拉函数的性质。 考虑统计每一个质因子出现的次数，再相乘即可。注意 $p^0=1$ 要特殊考虑。 空间开不下？注意到一个 $ai$ 最多只会存在一个 $p &gt; \\sqrt {a_{max}}$ 。 51Nod1675 序列变换 给定序列 $a,b$ ，求存在多少对 $x,y$ 满足 $\\gcd(x,y)=1,a_{b_x}=b_{a_x}$。 莫比乌斯反演的第二形式。 定义 $f(k)$ 为 $gcd(x,y)=k$ 的个数，定义 $F(k)$ 为 $k|\\gcd(x,y)$ 的个数。显然 $F(k)$ 很容易求，于是用 $(10)$ 就好了。 BZOJ3561 DZY Loves Math VI 求 $\\sum _ {i=1} ^ n \\sum _ {j=1} ^ m lcm (i,j) ^ {\\gcd(i, j)}$ 。 莫比乌斯反演，暴力。 虽然不是 $(16)$ 的形式，也可以用类似的套路，反演得到： $$\\sum _ {d = 1} ^ {n} d ^ d \\cdot \\sum _ {p = 1} ^ {\\lfloor \\frac n d \\rfloor} \\mu(p) \\cdot p ^ {2d} \\cdot \\sum _ {i=1} ^ {\\lfloor \\frac m {pd} \\rfloor} i ^ d \\cdot \\sum _ {j=1} ^ {\\lfloor \\frac n {pd} \\rfloor } j ^ d$$ 这个东西直接暴力嘛。。 BZOJ4816 [SDOI2017]数字表格 求 $\\prod _ {i=1} ^ n \\prod _ {j=1} ^ m fib(gcd(i,j))$ ，其中 $fib(n)$ 是斐波那契数。 莫比乌斯反演，前缀积。 同样也是 $(16)$ 的套路，只不过到了指数上面。同时前缀和变成了前缀积，同样也是 $O(n \\log n)$ 暴力预处理。 BZOJ3529 [SDOI2014]数表 求 $\\sum _ {i=1} ^ n \\sum _ {j=1} ^ m \\sigma _ 1(\\gcd(i,j)) \\cdot [\\sigma_1(\\gcd(i,j)) \\leq a]$ 。多组询问。 莫比乌斯反演，离线。 哈哈哈，又是 $(16)$ 的套路。。于是就是要求： $$\\large \\sum _ {d|D} \\sigma_1 (d) \\cdot \\mu(\\frac D d)$$ 的前缀和。 然后这个 $a$ 的限制似乎有些难搞？注意到有多组数据，所以可以离线，按照 $a$ 排序。修改和求前缀和就交给树状数组了。 复杂度？ $O(n \\log ^2 n + T \\cdot \\sqrt n \\cdot \\log n)$。 BZOJ4407 于神之怒加强版 求 $\\sum _ {i=1} ^ n \\sum _ {j=1} ^ m \\gcd(i,j) ^ k$ 。 莫比乌斯反演，积性函数前缀和。 又是 $(16)$ 的套路（这句话说了多少遍了）。就是要求： $$\\sum _ {d|D} d ^ k \\cdot \\mu (\\frac D d)$$ 的前缀和。 然后这个是积性函数的狄利克雷卷积，可以线性筛。往往就需要利用 $\\mu$ ，可以直接分情况。或者推公式，展开 $g(D)$ （这个方法比较万能）： $$\\large {g(n) \\\\ = \\sum _ {d|n} d ^ k \\mu(\\frac n d) \\\\ = \\prod _ {p_i} g(p_i ^{x_i}) \\\\ = \\prod _{p_i} (p_i ^{kx_i} \\cdot \\mu(1) + p_i ^{k(x_i-1)} \\cdot \\mu(p_i)) \\\\ = \\prod _ {p_i} p_i ^ {k(x_i-1)} \\cdot (p_i ^k -1)}$$ BZOJ3994 [SDOI2015]约数个数和 求 $\\sum _{i=1} ^n \\sum _{j=1} ^m \\sigma_0(i,j)$ 。 莫比乌斯反演，$\\sigma_0$ 的性质。 这题需要利用 $\\sigma_0$ 的性质： $$\\large \\sigma_0 (n,m) = \\sum _ {i|n} \\sum _ {j|m} [\\gcd(i,j)=1]$$ 证明：考虑一个质因子 $p$ ，假设 $n$ 中有 $x$ 个，$m$ 中有 $y$ 个。那么根据约数个数定理，$\\sigma_0(n,m) = \\prod (x+y-1)$。而如果要使 $\\gcd(i,j)=1$ ,每个质因子同样有 $x+y-1$ 种取法（$x$ 或 $y$ 为 $0$ ）。恰好是约数定理的形式。 接下来就是套路变换啦。 BZOJ3309 DZY Loves Math 对于正整数 $n$，定义 $f(n)$ 为 $n$ 所含质因子的最大幂指数。例如 $f(1960)=f(2^3 \\times 5^1 \\times 7^2)=3, f(10007)=1, f(1)=0$ 。给定正整数 $a,b$ ，求 $\\sum _ {i=1} ^a \\sum _ {j=1} ^m f( \\gcd(i,j))$ 。 莫比乌斯反演，特殊性质函数的前缀和。 根据 $(16)$ ，我们只需要求 $g(D) = \\sum _ {d|D} f(d) \\mu ( \\frac D d )$ 的前缀和即可。 但是，发现这个 $f(d)$ 不是积性函数，似乎就无法线性筛了。于是就要利用 $\\mu(n)$ 的特殊性质。 将 $D$ 表示为质因数乘积的形式，如果 $\\frac D d$ 对 $g(D)$ 有贡献，每个质因子的次数不会超过 $1$ 。 如果一个质因子 $p$ 在 $\\frac D d$ 中，我们称选择 $p$ 。 引理：对于一个包含 $n\\ (1 \\leq n)$ 个元素的集合，选择奇数个元素的方案数的等于选择偶数个元素的方案数。 归纳法很容易证明。 我们知道，$\\mu(D) = (-1) ^ k$ ，其中 $k$ 是选择的个数。 接下来分三种情况：（设所有质因子中，最大的次数为 $a$ ） $D = p^a$ ， $g(p^a) = f(p^a) - f(p^{a-1}) = a - (a - 1) = 1$ 。 $D = p_1 ^{a_1} p_2 ^{a_2} … p_m^{a_m}$ ，且 不 满足 $a_1 = a_2 = … = a_m$，假设最大次数 $a$ 有 $b$ 个。考虑 $a-1$ 的贡献，此时最大次数的质因子都被选择，剩下的 $1 \\leq m-b$ 个数可以任意选择，根据引理，正负全都被抵消了。考虑 $a$ 的贡献，由于 所有数中选择奇数与偶数个的方案，$a-1$ 时选择奇数与偶数个数的方案都相等 ，同样会正负都抵消。此时 $g(D) = 0$ 。 $D = p_1 ^{a_1} p_2 ^{a_2} … p_m^{a_m}$ ，且有 $a_1 = a_2 = … = a_m = a$。如果全部选择， $f(d) = a-1$ ，对 $g(D)$ 的贡献为 $(a-1) \\times (-1)^m$ ;而其他情况下， $f(d)=a$，对 $g(D)$ 的贡献为 $a \\times (-1) ^ {m-1}$ 。此时 $g(D) = -(-1)^m$ 。 为什么第三种情况套单独考虑？ 因为此时 $m-b=0$ ，不满足引理的条件，需要单独考虑。 同时也可以发现， 第一种情况没必要特殊考虑，同第三种情况。 最后，这个东西也是可以线性筛的。 利用 每个数只会被最小的质因子筛 用 $a[]$ 记录每一个数最小质因子的次数，$b[]$ 记录最小质因子的 $a[]$ 次，就可以递推了。 BZOJ3512 DZY Loves Math IV 求 $\\sum _ {i = 1} ^ n \\sum _ {j = 1} ^ m \\varphi (ij)$ ，$n \\leq 10^5, m \\leq 10^9$ 欧拉函数的性质，莫比乌斯反演，杜教筛。 大爷的姿势。 令 $S(n,m) = \\sum _ {i=1} ^ m \\varphi (ni)$ 。 $$\\large { S(n,m) \\\\ = \\sum _ {i=1} ^ m \\varphi (ni) \\\\ = \\sum _ {i=1} ^ m \\varphi ( \\frac n {\\gcd(i,n)}) \\cdot \\varphi(i) \\cdot \\gcd(i,n) \\\\ = \\sum _ {i=1} ^ m \\varphi(\\frac n {\\gcd(i,n)}) \\cdot \\varphi(i) \\cdot \\sum _ {d|i,d|n} \\varphi(d) \\\\ = \\sum _ {i=1} ^ m \\varphi(i) \\cdot \\sum _ {d|i,d|n} \\varphi(\\frac n d) \\\\ = \\sum _ {d|n} \\varphi(\\frac n d ) \\cdot \\sum _ {i=1} ^ {\\lfloor \\frac m d \\rfloor } \\varphi(di) \\\\ = \\sum _ {d | n} \\varphi(\\frac n d) \\cdot S(d, \\lfloor \\frac m d \\rfloor )}$$ 第二步，由于 $n,i$ 不一定互质，所以单独提出了 $\\gcd$ ；第三步，巧妙地运用了 $(7)$ ；第四步，由于 $\\frac n {\\gcd(i,n)},d$ 互质，所以可以直接合并；第五步应该及其套路。 当 $n=1$ 时，需要大力杜教筛搞一搞。 嘛.. 这个复杂度不会爆炸？ 注意到，需要计算的 $S(n’,m’)$ ，一定满足 $m’ = \\lfloor \\frac m {n’} \\rfloor$（除了第一个），所以要计算的就很少啦。复杂度差不多是 $O((n ^ {\\frac 2 3} + m ^ {\\frac 3 2}) \\times HASH)$ ？ 还要HASH一下，同时，根据 $\\varphi$ 的性质，可以先把 $n$ 中额外的质因子搞出来。 UPD 注意，第四步的推导是错误的，必须要满足 $|\\mu(n)|=1$ ，这样才能保证互质（因为每个质因子都只有一个，只能存在于 $\\frac n {\\gcd(i,n)}$ 或者 $\\gcd(i,n)$ ）。所以搞出额外的质因子是必须的。 51Nod1238 最小公倍数之和 $\\sum _ {i=1} ^{n} \\sum _ {j=1} ^{n} lcm(i,j)$ 只是杜教筛。 两维的嘛..要先拆开来啦.. $$\\large {f(n) \\\\ = \\sum _ {i=1} ^{n} lcm(n,i)\\\\ = n \\times \\sum _ {i=1} ^{n} \\frac i {\\gcd (i, n)}\\\\ = n \\times \\sum _ {d|n} ^{n} \\sum _ {id \\leq n} i \\times e(\\gcd (i, \\frac n d))\\\\ = n \\times \\sum _ {d|n} ^{n} \\frac 1 2 \\times (e(d) + d \\times \\varphi(d))\\\\ = \\frac n 2 + \\frac 1 2 \\times n \\times \\sum _ {d|n} d \\times \\varphi(d)\\\\ }$$ 最主要是搞出 $S(n) = \\sum _ {i=1} ^n i \\times \\sum _ {d|i} d \\times \\varphi(d)$ 也就是 $id \\times [(id \\times \\varphi) \\ast 1] = (id _ 2 \\times \\varphi) \\ast id$ 的前缀和。考虑如何消去难以计算的 $\\varphi$ 。 我们需要卷上一个新的东西。考虑利用 $(7)$ 来消去。考虑卷上 $id _ 2$ 来提出括号中的 $id _ 2$ ，于是 $$\\large id _ 2 \\ast (id _ 2 \\times \\varphi) \\ast id = id _ 2 \\times (1 * \\varphi) \\ast id = id _ 3 \\ast id$$ 这个前缀和就比较好求辣。令 $h(i)$ 表示这个柿子的前缀和，于是（考虑展开后每个 $d$ 的贡献次数） $$\\large h(n) = \\sum _ {d=1} ^{n} d \\sum _ {id \\leq n} i ^ 3$$ 注意到不同 $i$ 的上限只有 $O(\\sqrt n)$ 个，所以这个前缀和也可以分块！$g(x) = id _ 2$ 的前缀和也很容易计算。由于把 $S$ 划分为 $O(\\sqrt n)$ 个子问题时也需要 $O(\\sqrt n)$ 的时间复杂度，所以总的复杂度不变。仍然为 $O(n ^ {\\frac 2 3})$ 。 发现很神奇的， $ANS = s(n)$ 。 另一种方法。 得到 $S(n) = \\sum _ {i=1} ^n i \\times \\sum _ {d|i} d \\times \\varphi(d)$ 后，可以改变形式使得更容易筛。改为枚举 $i$ 是 $d$ 的多少倍。 $$\\large {S(n) = \\sum _ {i=1} ^n i \\times \\sum _ {d|i} d \\times \\varphi(d) \\\\ = \\sum _ {i=1} ^ n i \\times \\sum _ {d=1} ^ {\\lfloor \\frac n d \\rfloor} d ^ 2 \\times \\varphi (d)}$$ 嗯，那么要求的就是 $id _ 2 \\times \\varphi$ 的前缀和，再分块。卷上 $id_ 2$ 。要求 $id_ 3$ 的前缀和。 题外话。 51Nod1227也是同样的方法，只是一开始得到的为 $(\\varphi \\times id) \\ast 1$ 。51Nod1237大致方向差不多，只是推的过程简单很多。 如果用方法二，卷起来得到了 $id _ 2$ ，十分容易计算！ 如果直接卷 $id$ 得到 $1 \\ast id _ 2$ ，也可以应用方法一，里面套一层分块。 似乎两种方法本质一样，都需要进行一次约数/倍数变换。分块在外面或者里面。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"「学习笔记」网络流相关","date":"2017-12-31T15:59:54.000Z","path":"2017/12/31/Algorithms-Flows/","text":"待填的坑。 （无/有源汇）上下界（最大/最小费用）可行流，KM算法，数据结构优化建图，分治优化，手动增广，LP对偶费用流，差分费用流，线性规划与网络流。 2017.11.18。 暂时告一段落了。 2017.12.12。 又回来了。 前言今年NOIP2017提高的初赛考到的最小割。这是否意味着网络流进入NOIP考纲？ 蒟蒻Cyani发现，周围的同学都会网络流啊。蒟蒻也来学一学姿势。 比较推荐LRJ的蓝书，胡伯涛的论文，关于模版和建模有比较详细的讲解。 听说CF的网络流质量挺高的？ 还有BZOJ的网络流。 为了使叙述更加易懂，本文尽可能减少数学符号的使用。 前置技能最大流每次找到最短增广路径，最坏增广 $O(nm)$ 次。所以时间复杂度取决于找最短增广路径的时间复杂度。 EK算法。 直接暴力 $BFS$ ，复杂度 $O(nm^2)$ 。 Dinic算法。 按照起点到 $u$ 的距离分层，沿着分层网络上的边增广，直到 $s$ 无法到达 $t$ 。重复以上步骤。最多重复 $O(n)$ 次，每次复杂度 $O(nm)$ 。总的复杂度 $O(n^2m)$ 。 ISAP算法。 EK算法的改进版，做法类似于Dinic，维护每个点到终点的最大距离（没有暴力重新计算，而是增广过程中更新）。需要增加当前弧优化，GAP优化。复杂度 $O(n^2m)$ ，常数比Dinic小。 推荐ISAP，详见这篇博文。 网络流算法Dinic跑二分图时，复杂度为 $O(\\sqrt n m)$ 。经过实践，ISAP跑二分图的复杂度也差不多，似乎常数略大？ 最大流最小割定理一个图的割定义为， $s,t$ 分别所属两个点集 $S,T=V-S$ ，代价定义为 $S$ 到 $T$ 所有边的代价总和。 最大流=最小割。 关键的证明步骤：是最大流-&gt;不存在增广路径-&gt;可以构造一个割使之等于流-&gt;是最大流。证明等价性。 关键在于 构造 这个割。 令 $S$ 为 $s$ 能够达到的点集，那么对于任意 $u \\in S, v \\in T$ 都有 $f(u,v)=c(u,v)$ ，否则 $(u,v)$ 就属于残量了，与前提矛盾。不难发现这个割的容量总和等于流量。 注意：最小割之间的边一定是满流的边，反过来不一定成立。 最小费用最大流注意到一个网络的最大流并不是唯一的。有一类题会在边上附加单位流量费用。最小费用最大流用于解决当流量最大时，最小的费用总和。 EK-SPFA算法。 在EK算法BFS寻找最短路的基础上，改成SPFA寻找最短路。复杂度 $O(nmF)$ ，其中 $F$ 表示最大流量，事实上远小于这个上界。 zkw费用流。 先挖坑。。 其实我的费用流模版比ISAP短诶。。 常见模型Simple这些小技巧的正确性就挺显然的吧。。 多源多汇。 增加超级源 $s’$ ，超级汇 $t’$ ，连上流量无穷的边。 节点容量。 将一个点 $u$ 拆成两个点 $u1,u2$ ， $u1\\rightarrow u2$ 连上节点容量的边，入边连上$u1$，出边连上$u2$。同样适用于节点费用。 动态加边。 不能更改原来边的容量，费用。注意无后效性！ 费用流如何应用？ 首先需要确保达到最大流，必要时限流。否则费用流就没有意义了。 费用不是线性关系。 拆边。比如流量 $x$ 的费用为 $x^2$ ，此时可以分段。具体来说，连上流量 $1$ ，费用 $cost(1)-cost(0)$ ，流量 $1$ ，费用 $cost(2)-cost(1)$ 。。这个例子对应的流量就是 $1,3,5,…$ 。 费用流限流。 在汇点之后再加一条边到超级汇，限制流量。 最大权闭合子图对于一个有向图 $G$ 对于其的一个子集 $N$ 满足：闭合子图中的所有节点指向的，都是闭合子图的节点。赋予每个点一个权值$wi$，要求最大化闭合子图的权值。 构图方法。 对于原图中的边，替换为流量无穷的边；对于权值为正的节点，源$S$向这个节点连接容量为$wi$的边；对于权值为负的节点，这个节点连向汇点容量为 $-wi$ 的边。 感性证明。 注意到一个性质：新的图的最小割一定不包含容量无限的边（称这种割为简单个）。于是满足闭合子图的定义，每个简单割的 $S$ 集一一对应一个闭合子图。 设所有正数的权之和为 $sum$ ，最小割为 $w$ 。发现闭合子图的权就是 $sum-w$ ，于是我们需要最小化 $w$ ，才能最大化闭合子图的权。 最大密度子图对于一个无向图，定义一个子图的密度为边数除以点数。求密度的最大值。 注意到是分数的形式，考虑 分数规划 ，二分答案 $g$ 。于是我们要求出 $|E|-g|V|$ 的最大值，根据与 $0$的 关系进一步确定区间。 一种比较容易想到的做法： 注意到，如果我们选择了一条边 $(u,v)$ ，那么一定要选择 $u,v$ 。这种依赖关系恰好对应了 最大权闭合子图 。我们只需要把边也变成点即可。复杂度为 $O(\\log n \\times Maxflow(n+m, n+m))$ 。发现点数过于大。 深入利用特殊性质，得到更好的做法二： 因为要应用最小割，所以首先转成最小化的形式：$g|V’|-|E’|=\\sum _{v \\in V’} g - \\sum_ {e \\in E’} 1$。前面部分无需改变，考虑如何将后面部分与最小割联系。 注意到后面部分就是 $\\frac 1 2 \\times \\sum _ {v \\in V’} d[v] - c[V’, V-V’]$，左边部分与之前的合并在一起，右边部分就是 $V’,V-V’$ 之间最小割。附加所有节点到$T$的边容量为 $g - \\frac {d[v]} 2$。注意，容量有可能为负数，需要增加一个足够大的固定值。 最终，流网络的点数为$n$。 这个模型很容易推广到带边权与点权的问题。 二分图点权最大独立集&amp;覆盖集。话说在无向图里，这个问题是NPC的呢。但是二分图就可用最大流跑啦。 覆盖集：$U \\in V$，$\\forall (u,v) \\in E, u \\in U \\vee v \\in U$ 。 独立集：$U \\in V$, $\\forall (u,v) \\in E, u \\notin U \\vee v \\notin U$。 发现最小覆盖集和最大独立集互补。只用考虑最小覆盖集。 根据定义很显然啊。 考虑这样建边，新建 $S$ ，对每个 $X$ 部的点 $i$ 连上容量为 $a[i]$ 的边，边 $(i,j)$ 就要从 $i$ 向 $j$ 连 $\\infty$ 的边，每个 $Y$ 部的点 $j$ 向 $T$ 连容量为 $b[j]$ 的边。 注意到最小割的性质。路径 $S \\rightarrow u \\rightarrow v \\rightarrow T$ ，至少有一条边被割，不可能是 $u \\rightarrow v$ ，对应到原问题就是 $u,v$ 中至少选择一个。 所有点权之和减去最小覆盖集就是最大独立集合辣。 应用，论文题：BZOJ1324 Exca王者之剑 一个一般化，基于二元关系的建模方法适用问题： 有 $N$ 个元素，每个元素可以选或者不选，有对应的代价。描述若干个二元组，不同关系是产生不同的代价。求中代价的最小/最大值。 找出题目中的二元关系。 有必要时需要附加点。如果出现类似与 $x$ 选了， $y$ 必须选的情况，相当于 $y$ 没选但 $x$ 选了的代价为 $\\infty$ 。 具体方法。 新建一个源点 $S$ 和汇点 $T$ ，割 $(S,u)$ 表示不选，割 $(u,T)$ 表示选。对于所有二元关系 $(u,v)$ ，在 $(u,v),(v,u)$ 连上容量为 $e,f$ 的边。根据四种情况可以列方程，解出所有容量，跑最大流即可。 可能出现的情况以及应对方法。解方程后得到中间两条边的容量之和$K$为负数，如果图不是二分图，就GG。否则考虑令$Y$部的点，与$S,T$相连的边的意义交换。可以使中间的容量之和变为$-K$。 最大权闭合子图，最大密度子图也是这种二元关系建模的特殊应用。 具体参见 彭天翼《浅析一类最小割问题》 容量上下界的可行流未完待续。 一些好题 BZOJ1305 [CQOI2009]dance跳舞 有 $n$ 个男生， $n$ 个女生。有一个 $n \\times n$ 的关系，表示是否愿意一起跳交际舞。每个人最多和 $K$ 个不喜欢的异性跳舞。每个人不会和一个人跳多次舞。每一轮所有人都要一起跳舞。问最多能进行几轮。 二分+最大流二分图匹配。 显然需要二分答案$ans$。考虑将每个点拆分为两个，喜欢$u1$，不喜欢$u2$。考虑$S$连向$u1$容量$ans$，$u1$连向$u2$容量$K$。最后，再是喜欢的点对连接，不喜欢的点对连接，容量都为$1$。跑最大流，如果$S$到所有$u1$都是满流的，就可行。 BZOJ3630 [JLOI2014]镜面通道 有两块镜面 $(0,0) \\rightarrow (X,0)$ 和 $(0,Y) \\rightarrow (X,Y)$ 。中间有若干个正方形和圆形镜面。问最少拿走几块图形，使得左面的光能够通过反射照到最右面。 计算集合+节点容量+最小割。 水能过去，光就能过去。很显然的一个结论吧。。随便感受下就好了。 于是我们需要删除最少的图形，使得左右连通。也即一个割。考虑拆点，建立节点容量，为 $1$ 。在两连通的两个图形之间，要建容量为无穷的边。下镜面作为 $S$ ，上镜面作为 $T$ 。跑最大流即可。 BZOJ1565 [NOI2009]植物大战僵尸 有一个 $n \\times m$ 的矩阵，每个位置有一个植物，每个植物会保护若干个位置。僵尸只能从每一行的最右端开始进攻，而且不能进入被保护的位置。每攻击一个植物，可以获得一个价值（可能为负数），求最后能够获得多少的价值。 拓扑排序，最大权闭合子图。 发现僵尸只能从每一行的最右端开始进攻其实也是一种保护关系，每个植物保护它左边的植物。考虑拓扑排序，对于构成环的节点，我们就删去。对于剩下的DAG，运用经典的最大权闭合子图模型即可。 BZOJ3996 [TJOI2015]线性代数 给出一个 $n \\times n$ 的矩阵 $B$ 和一个 $1 \\times N$ 的矩阵 $C$ 。求一个 $1 \\times N$ 的 $01$ 矩阵 $A$ .使得 $D =(A \\times B-C) \\times A ^ T$ 最大。其中 $A^T$ 为 $A$ 的转置。输出 $D$ 。 $n \\leq 100$ 最大权闭合子图。 一看到题的时候，一脸懵逼。。这个数学题可以用网络流？？ 其实还是很水的啦。注意到，$Ans = \\sum _{i = 1} ^ {n} \\sum_ {j=1} ^{n} A[i] \\times A[j] \\times B[i][j] - \\sum _ {i=1} ^{n} A[i] \\times C[i]$。 如果选择了 $B[i][j]$ 那么一定要选择 $A[i],A[j]$ ，就是一个最大权闭合子图啦。 算复杂度，点数 $|V|=O(n^2)$ ，边数 $|E|=O(n^2)$ 。所以最大流的复杂度是 $O(n^6)$ ？？！！ WTF，复杂度直接爆炸啊！确定自己没有看错？？ 呐，这个图是二分图诶。。所以复杂度就是 $O(n^3)$ 啦。。 BZOJ2127 happiness 有一个$n \\times m$的班级，每个学生会选择文科或者理科，得到不同的喜悦值。如果一个人与前后左右选择的科目相同，可以获得额外的喜悦值。问喜悦值最大为多少。$n,m \\leq 100$。 根据二元关系建图。 做完这道最小割，我整个人都最小割了。。—-hzwer 应为要使答案最大化，我们一开始先将喜悦值取负。 加上 $u,v$ 都选文科的喜悦值为 $-v1$ ，都选理科的喜悦值为 $-v2$ ，其他情况下喜悦值为 $0$ 。可以发现 $(u,v)$ 需要连 $v1+v2$ 的无向边， $(S,u),(S,v)$ 连 $v2$ 的无向边， $(u,T),(v,T)$ 连 $v1$ 的无向边。已经取正数最后减去 $v1+v2$ ，再除以 $2$ 即可。 对于每个人自己选择文理科，另外处理。使用同样的技巧，首先把边取负，再加上 $a[u]+b[u]$ 。最后一起求最小割，减去多余的，取负即可。 BZOJ1834 [ZJOI2010]network网络扩容 给定一个有向图，每条边的容量和费用。每增加一单位容量就会增加一单位费用，求最大流增加$K$的最小费用。 很显然的一个费用流建模。考虑首先按照给定的图构造，每条边附加一条容量无限，费用为 $Wi $的边。跑费用流。 如何保证最大流恰好增大到 $K$ ？求出原来的最大流，附加一个超级汇，限制流量即可。 BZOJ2597 [WC2007]剪刀石头布 给定一个竞赛图，有些边的方向还未确定。定向这些边，使得三元环的个数最多，输出方案。 $n \\leq 100$ 容斥原理，分段费用。 发现正着做很难，考虑 补集转换 。注意到， 一个不满足条件的三元组 $(a,b,c)$ 对应于 $a,b,c$ 之一的两条出边。 $$ANS = \\binom {n} {3} - \\sum _ {i = 1} ^ {n} \\binom {out[i]} {2}$$ 考虑为这些边建立点 $e[1], e[2], e[3], …$ 。每个 $e[i]$ 向 $T$ 连上容量 $1$ 费用 $0$ 的边（容量为 $1$ 限制它只能作为条边的出边）。 对于边 $(u, v)$ ，如果这条边能够成为 $u$ 或者 $v$ 的出边，就连上 容量 $1$ 费用 $0$ 的边。 每个点 $u$ 的流量需要 $S$ 来提供，根据分段费用的方法，建立 $n-1$ 条容量为 $1$ 费用依次为 $0, 1, 2, 3, …, n-2$的边。 跑费用流。考虑复杂度，点数 $O(n^2)$， 边数 $O(n^2)$, 至多增广 $O(n^2)$ 次，总的复杂度 $O(n^6)$。实际上，由于图较为稀疏，所以使用SPFA的费用流达不到这个上界。 LRJ的模版好慢啊啊啊，卡了半天常数。。。有时间学学ZKW费用流QAQ BZOJ3171 [TJOI2013]循环格 有一个 $n \\times m$ 的矩阵，每个元素表示了一个方向（上下左右）。问最少改变多少元素的方向，使得从任意位置出发，按照元素的方向运动，最后能到达原来的位置。 $n \\leq 15$ 环的性质，费用流建模。 考虑环的性质： 所有节点的出度和入度都为 $1$。 考虑拆点，$(x,y,1),(x,y,2)$。 $S$ 连向每个 $(x,y,1)$ 容量为 $1$ 费用为 $0$ 的边。 $(x,y,1)$ 向四周的 $(x’,y’,2)$ 连上容量为 $1$ 费用为 $1$ （当与原来方向相同时为 $0$ ）的边。所有 $(x,y,2)$ 连向 $T$ 容量为 $1$ 费用为 $0$ 的边。跑最小费用最大流。 注意到，费用最小的前提的是 流量最大，所以与 $S,T$ 相连的边一定是满流的（很显然一定能做到）。 这样就能够限制每个位置的出度入度都为 $1$。 BZOJ2879 [NOI2012]美食节。 有 $n$ 种菜和 $m$ 个厨师，厨师 $j$ 烧菜 $i$ 所需的时间是 $t[i][j]$ ，一个厨师一次只能烧一样菜。现在知道有 $p[i]$ 个学生需要第 $i$ 道菜。求所有学生所需要的等待时间总和的最小值。 $n \\leq 40, m \\leq 100, \\sum p[i] \\leq 800$ 。 神奇的费用流建模，动态加边。 显然需要划分为两部分点。 一开始的错误想法：建立 $n$ 个点 $a[1], a[2], a[3], …$ ，$S$ 连向这些点容量 $p[i]$ 费用 $0$ 的边。为厨师建立点 $b[1], b[2], b[3], …, b[m]$ 连向 $T$ 容量为 $1$ 费用为 $0$ 的边。所有 $a[i], b[j]$ 连接 容量无限， 费用 $t[i][j]$ 的边。每一次增广后，我们得到了 $S \\rightarrow a \\rightarrow b \\rightarrow T$ 的路径。相当于厨师选择烧这样菜。然后我们再连接 $b[j]$ 到 $T$ 的边，容量仍然为 $1$ ， 费用要增加先前的时间。 呐，看上去没错啊？怎么会比答案少呢？？事实上就是因为费用流算法存在反向边，目的是 退流 。所以一定程度上网络流也是贪心？？然后退流就是经典的 反悔操作 。这就使得这个算法中存在后效性（退流之后，新的边就不合法了）。 考虑一种新的权值计算方式。 假设一个厨师烧菜时间的序列: $t1, t2, t3, …, tn$ 那么总共的时间为 $n \\times t1, (n-1) \\times t2, …, tn$ 。考虑倒着计算，依次加入 $k \\times t$ 的边。 拆点！为了使 $1$ 倍时间， $2$ 倍时间，等，都只计算一次。考虑将每个厨师拆成 $\\sum p[i]$ 个点，依次表示烧倒数第 $k$ 条边。然而这么多边建出来会T啊。考虑动态建边，当一次增广，烧完倒数第 $k$ 道菜，加入倒数第 $k+1$ 道菜。 计算一下复杂度。需要增广 $O(\\sum p[i])$ 次，点数始终保持 $O(n+m)$ 个， 边数始终保持 $O(nm)$ 条，于是总的复杂度为 $O((n+m)nm \\times \\sum p[i])$ 。SPFA-EK费用流卡着时限过QAQ。看来要学ZKW费用流了QAQ。 BZOJ1001-[BeiJing2006]狼抓兔子。 给定一个平面图，求最小割。 平面图转对偶图。 此题暴力ISAP可过。不过经典的做法是，求出他的对偶图（区域变成新的点，相邻连边）。于是跑最短路就好了。 BZOJ2400-Optimal Marks。 给定一个无向图，某些点的权值已经知道，请确定剩下点的权值。定义一个图的代价为所有边两端点权的异或值之和。求无向图的最小代价，当代价最小时，最小的点和。 按位拆分，最小割。 显然可以按位拆分。显然可以最小割。S集的权为0，T集的权为1。如果是已经确定的位，就与S or T连上流量为INF的边。原图连流量为1的边。 比较不显然的是最小点权和。最小费用最大流？TLE! 这里有一个Trick。我们把所有的流量1改为1000。对于所有与S没有直接连边的点，连上流量为1的边。当割最小时，先要满足价值最小，其次满足点权和。 BZOJ1280-Emmy卖猪pigs。 有若干个猪圈，猪圈里养了若干头猪。依次来了几位客人，每位客人带上了若干个猪圈的钥匙，他最多可以买 $ai$ 头猪。之后，你可以把这些猪圈中的猪任意安排，再关上。问最多能卖多少猪？ 经典最大流建图。 不难发现一个性质：当一个猪圈中已经有一个客人来过后，第二位客人能够买前一位客人能卖的猪。于是建图就很simple了： 每个猪圈（源点）向到这个猪圈的第一位客人连流量为猪的数量的边，每个客人向后续有重叠的客人连流量为无穷的边。每位客人向汇点连容量为 $ai$ 的边。 BZOJ1449-[JSOI2009]球队收益 有 $n$ 支球队，每支球队已经赢了 $win[i]$ 场，输了 $lose[i]$ 场，每支球队还有参数 $c[i],d[i]$ 。剩下的球队会进行 $m$ 场比赛。问所有球队的价值总和的最小值。一个球队的价值定义为 $c[i] \\times win’[i] + d[i] \\times lose’[i]$ (代表最终的胜利，失败的场数)。 拆边费用流。 发现一场比赛对应两个价值，但是流量无法凭空产生，那么该如何建图呢？ 有一个很秒的想法，注意到每只队伍最终胜利和失败的次数的总和是比边的。首先假设剩下的场数都是输的，然艘计算每多胜一场可以增加的权值。由因为这个增量是显然递增的，所以是正确的。 BZOJ3280-小R的烦恼 你需要一些xx，第 $i$ 个商店有 $li$ 个xx，每个xx要 $pi$ 的代价。你在第 $i$ 需要 $ai$ 个xx。每个xx在用完一天之后会XX，所以，拿去修理它，第 $i$ 个地方，需要修理 $d$ 天，需要 $qi$ 的花费。求最小需要花的前。 奇妙的费用流。 注意到，一个xx可以有多次贡献，对应到流里面，流量并不会增加，这样应该如何建图？注意到，每天结束后有固定 $ai$ 个死掉的xx，这个流量可以由原点提供，于是我们就得到建图方式辣。注意到要考虑：每天多出来死的；活的到汇点；第一天新来活的；每天把死的修d天变成活的；前一天活的不用，到后一天；前一天死的不修，到后一天。。貌似这样不太好QAQ，大概就这这样理解啦。 建图如下表： 起点 终点 流量 费用 0 dead[i] a[i] 0 live[i] 2*n+1 a[i] 0 0 live[1] l[j] p[j] dead[i] live[i+d[j]] ∞ q[j] live[i] live[i+1] ∞ 0 dead[i] dead[i+1] ∞ 0 BZOJ5120-[2017国家集训队测试]无限之环 有 $n \\times m$ 的方格，每个方格的上下左右，有可能存在接口，也有可能没有。可以顺时针或逆时针旋转。问最少操作几次，使得每个接口总有一个接口与之连通。很显然，总共存在15种方块（不算空的）。 二分图，费用流。 注意到 网格图是一个二分图 所以考虑黑白染色，就变成了两部分的连接。很显然拆成四个方向的四个点，首先对应接触的点先连接，考虑源点流向X集。 由于每部分的流量总量不变。所以考虑S流向默认的接口 $(1,0)$ 的边。而旋转就是接口之间，花费一定的费用来转移流量。 以只有一个接头为例。首先S连向那个接头 $(1,0)$ 的边，然后那个接头连向两边 $(1,1)$，向对面连 $(1,2)$ 的边。 相邻的两个接头也类似，三个接头的与一个接头的恰好相反。 注意空方块和四个接头的没有必要旋转。 注意那个对面的两个接头的不能旋转。。因为出题人也建不出图。。hhh。。 这个建图嘛，我手撸了1h。共6k，竟然1A了。哈哈哈。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"「学习笔记」线段树进阶","date":"2017-12-31T15:59:53.000Z","path":"2017/12/31/Algorithms-SegmentTree/","text":"线段树的高(chang)级(jian)应用 review分治结构 懒标记 可以快速合并 可以快速更新区间信息 不满足懒标记性质的一些操作 基于均摊复杂度 线段树优美的分治结构 从一道题引入 有一个序列，每次在最后加上一个元素，询问区间Max 序列最后长度 $\\leq 100000$ $Q \\leq 10^7$ 预处理每个区间的前后缀max 对于询问区间 $[l,r]$ 找到 $[l,r]$ 第一次分开的位置 左边的后缀max，右边的前缀max 可以做到 $O(1)$ 考虑更新 加入一个元素的时候，更新一下前缀max 如果区间被插满了，算一下后缀max 小清新线段树线段树的懒标记有很多神奇的用处 但是有些问题并不满足上述的性质 ...... A 基于均摊复杂度的线段树来回顾区间加减，区间覆盖的一些神奇性质 区间加，区间覆盖 $\\Rightarrow$ 区间内相对大小不变 or 相同 于是，对于 区间覆盖 $\\Rightarrow$ 缩成一个点 区间加减 $\\Rightarrow$ 差分 CF438D 维护一个序列，滋瓷区间取模，单点修改，区间求和 $n,m \\leq 10^5, a_i \\leq 10^9$ 思考10min… 注意到，对于一个大于模数的数， 一次 $\\bmod$ 之后，至多为原来大小的一半 直接暴力找最大值，暴力修改 复杂度 $O(m \\log n \\log a_i)$ 简单的加强，要求滋瓷区间覆盖 思考5min… 考虑这样一种暴力的做法 维护区间 $\\min, \\max$ ，分几种情况讨论 $\\max &lt; m$ ，直接 return $\\min = \\max$ ，直接区间覆盖 思考：复杂度为什么是对的？ 考虑将 相邻且相同的数字缩成同一个点 再来看区间取模，可以注意到一次操作至多会增加 $2$ 个点 显然，每个大点定位的复杂度也是 $O(\\log n)$ ，所以复杂度仍然不变 我们从势能法角度来理解渐进时间复杂度分析，先简单介绍势能分析 势能分析常用于一类基于均摊的数据结构的时间复杂度 引入“势能”，把势能看作整个数据结构的一个状态函数 定义 $\\Phi(i)$ 表示第 $i$ 次操作后，数据结构的势能 定义 $c_i$ 表示第 $i$ 次操作的实际时间花费 定义 $a_i$ 为第 $i$ 次操作的均摊时间花费 我们令 $$\\large a_i = c_i + \\Phi(i) - \\Phi(i-1) = c_i + \\Delta \\Phi(i)$$ 显而易见地 $$\\large \\sum a_i + \\Phi(0) - \\Phi(n) = \\sum c_i$$ 也就是说，只要我们确定了 $\\sum a_i$ 与 $\\Phi(0) - \\Phi(n)$ 的上界 就能确定 $\\sum c_i$ 的上界！ 这里，我们不考虑常数问题 回到这一题，受之前的思路启发，我们定义（假设我们已经将相邻且相同的数字缩成一个点） $$\\large \\Phi(i) = \\log n \\sum _ {i=1} ^ n \\log x_i$$ 考虑区间覆盖操作 $$\\large a_i \\leq \\log n + \\log n \\log x_i = O(\\log n \\log x_i)$$ 考虑区间取模操作（假设我们对 $t$ 个点取模） $$\\large a_i \\leq t \\log n - t \\log n + 2 \\log n \\log x_i = O(\\log n \\log x_i)$$ （觉得这一步有锅？我们只要给势能函数乘以一个足够大的常数即可） 同时 $$\\large \\Phi(0) - \\Phi(n) \\leq O(n \\log n \\log x_i)$$ 所以 $$\\large T(n) = \\sum c_i = O(n \\log n \\log x_i)$$ 我们可以发现，覆盖操作比较省时，在积累势能 而与此相对的，取模操作比较耗时，在消耗势能 势能分析的本质： 将多余的时间存储起来，在需要的时候使用 抱歉，您在其他地方找不到这样的证明 因为全都是我yy的 那么，该怎么写呢？ 平衡树 线段树模版拓展 12345678910void update(int o, int l, int r, int x, int y, ...) &#123; if (cut(o, ..)) return; if (l == x &amp;&amp; y == r &amp;&amp; check(o, ..)) &#123; ... return; &#125; pushdown(o); if (x &lt;= mid) update(lc, l, mid, x, min(mid, y), ...); if (mid &lt; y) update(rc, mid+1, r, max(mid+1, x), y, ...); ...&#125; 对于这道题 $cut():\\; \\max(l,r) &lt; x$ $check():\\;\\max(l,r) = \\min(l,r)$ HDU5828 Rikka with Sequence = UOJ228 维护一个序列，滋瓷区间加减，区间开根号（下取整），询问区间和 思考10min… 这类问题通常全局也难以解决，考虑从全局修改入手 注意到开根号几次就差不多全相同了（最多差 $1$ ） 3 4 -&gt; 1 2 -&gt; 3 4 -&gt; 1 2 于是，我们考虑 $check():\\; \\max(l,r) - \\min(l,r) \\leq 1$ 直接变成区间减法 or 区间覆盖 还是分析复杂度 考虑差分，我们只取绝对值 注意到，我们只需要 $O(\\log \\log x_i)$ 就能让 $x_i$ 变为 $1$ 同样，我们也只需要经过这么多次，使得两个数的差分值小于 $2$ 这启发我们定义势能函数： $$\\large \\Phi(i) = \\log n \\sum _ {i=1} ^{n-1} \\log \\log |x_i - x_{i-1}|$$ 考虑区间加减 $$\\large a _ i = \\log n + 2 \\log n \\log \\log x_i = O(\\log n \\log \\log x_i)$$ 考虑区间开根（假设执行了 $t$ 段连续区间的减法） $$\\large a_i = t \\log n - (t-1) \\log n + 2 \\log n \\log \\log x_i = O(\\log n \\log \\log x_i)$$ 而 $\\large \\Phi(0) - \\Phi(n) = O(n \\log n \\log \\log x_i)$ … 口胡完毕 通过这两道题，大概泥萌都已经掌握了势能分析？ 在实际比赛的时候，可以考虑对暴力线段树DFS加入cut,check 或许会有意想不到的收获、 exercise BZOJ 2130 魔塔 HDU 5634 Rikka with Phi B 懒标记顺序&amp;标记回收普通的懒标记在线段树上的深度顺序是与时间相关的 利用标记的顺序，可以干一些奇怪的事情 ...... 一个小🌰 区间取 $\\max$，询问区间和 我们考虑令所有标记值随着深度的增加而增加 每个点向上走，遇到的第一个标记就是它的历史最大值！ 于是可以简单地维护区间和 如何让标记满足这样的顺序要求？ 考虑标记回收 我们维护每一个子树内最小的标记值 $w$ 在打上标记之后，根据 $w$ 的值暴力DFS 删掉所有更小的标记 这样就可保证标记有序 回收标记的复杂度不超过打标记+标记下传 标记回收是一个巧妙的想法，关于这个东西更多的应用，可以参考吉老师的《Segment Tree Beats》与集训队论文 exercise HDU5306 Gorgeous Sequence C 线段树与懒标记的变体传统的线段树使用两个孩子的信息，来更新自己的信息 还有一些变体的问题，需要递归到某一个孩子内更新信息 Codechef STREETTA 区间对等差数列取 $\\min$ ，询问单点值 思考10min… 线段树维护半平面交？ 考虑标记永久化，每个位置只放上一个标记 如何合并标记？ 求出两个标记的分界点。分界点两边各是一个标记占优 那么一定有一个标记占优的部分是一个子树的一部分 把这个标记下传下去继续比较 至多 $O(\\log n)$ 次比较 List 询问一个区间形成的单调栈的大小 思考10min… 令 $getw(x,r)$ 为以 $r$ 的初值走到子树 $x$ 中会增加多少个数 $getw(x,r)=getw(lc,r)+getw(rc,max(\\max[lc],r))$ 发现可以预处理 $getw(rc,\\max[lc])$ 考虑一下复杂度 如果 $\\max[lc] &lt; r$ $getw(lc, r) = 0$ ，我们只需要递归计算 $getw(rc, r)$ 如果 $\\max[lc] \\geq r$ 我们只需要递归计算 $getw(lc, r)$ 总的复杂度为 $O(n \\log ^2n)$ zkw重口味线段树讲道理这个东西只能用来卡常，没什么用？ 单点加减，最值查询 123456789for (M=1; M&lt;=N+1; M&lt;&lt;=1);for (int i=M+1; i&lt;=M+n; i++) scanf(\"%d\", &amp;T[i]);for (int i=M-1; i&gt;=1; i--) T[i] = T[i+i] + T[i+i+1];for (T[x+=M]=V, x&gt;&gt;=1; x; x&gt;&gt;=1) T[x] = T[x+x] + T[x+x+1];for (s=s+M-1, t=t+M+1; s^t^1; s&gt;&gt;=1, t&gt;&gt;=1) &#123; if (~s&amp;1) ans += T[s^1]; if ( t&amp;1) ans += T[t^1];&#125; zkw线段树处理区间修改比较麻烦，往往需要标记永久化 对于区间加减，最值查询，我们可以考虑差分 zkw线段树的查询方式也可以来搞事情，我们来看一道题 有一个 $N$ 片叶子的线段树，是他不是按照 $mid$ 分开的。所以树高不是 $O(logn)$ ，并且一个区间会被拆分成很多个区间。有 $Q$ 次询问，每次询问一个区间 $[l, r]$会被拆分成多少个小区间？ $n,Q \\leq 100000$ 思考3min… 我们只要统计 $[l-1,lca)$ 路径上所有左儿子的右兄弟，$(lca,r+1]$ 路径上右儿子的左兄弟个数之和，倍增即可 线段树合并定义 merge(a,b) 如果 a,b 中有一个不含任何元素，就返回另一个 如果 a,b 都是叶子，返回 merge_leaf(a,b) 返回 merge(a-&gt;l,b-&gt;l) 与 merge(a-&gt;r,b-&gt;r) 连接成的树 复杂度分析 注意到一个性质，当且仅当两颗线段树在某个位置上都存在节点的时候，才会对时间复杂度产生 $O(1)$ 的贡献 显然，这相当于以 $O(1)$ 的时间复杂度删除一个节点 而一开始存在 $O(n \\log n)$ 个节点 有什么用？ 利用这种动态开点的值域线段树，可以解决一堆有序集合进行合并/分裂，同时查询k小的问题 两道经典题 BZOJ2212 [POI2011]Tree Rotations BZOJ2733 [HNOI2010]永无乡 = BZOJ3545 [ONTAK2010]Peaks BZOJ3307 雨天的尾巴 $n$ 个点，形成一个树。有 $m$ 次操作，每次选择两个点 $x,y$ 。对于 $x$ 到 $y$ 的路径上，每个点放一个 $z$。完成所有操作后，每个点存放最多的是哪个数字 思考10min… 考虑差分？ 差不多就是 $u,v,lca,fa[lca]$ 打标记 自底向上，线段树合并 没了。 exercise BZOJ4730 Alice和Bob又在玩游戏 Szkopul [ONTAK2010]Zadanie Autostrady 如何优雅地使用set 你有 $n$ 个墙，第 $i$ 个墙的高度为 $a_i$，给你 $Q$ 个操作 $P$，询问当前墙的状态下最多能存储多少水 $U, x, v\\;(v&gt;0)$ ，$a_x += v$ 思考15min… 可以强行把墙当作水，发现这是单峰的 对于两边，我们都维护一下单调性 可以用线段树区间修改，比较无脑 区间最值操作？ 利用单调性，记录区间最大/最小，暴力 DFS 复杂度？ 当然更好的是用 set 简单易懂 （数据在 prob 文件夹里） LOJ#546. 「LibreOJ β Round #7」网格图 给定一张 $n \\times m$ 的网格图，行标号 $1$ 到 $n$，列标号为 $1$ 到 $m$，网格图上设置了 $k$ 个障碍。 一个机器人在网格图中行走，初始时它位于位置 $s$，每一时刻他有三种行动方式 如果自己面向的方向不是障碍或网格的边缘，向该方向前进一格。 向左（逆时针）转四分之一周。 向右（顺时针）转四分之一周。 初始时机器人可以选择面向任意一个方向 现在有 $Q$ 个询问，每个询问给定一个终点 $t_i$，请你求出他从 $s$ 到 $t_i$ 最少需要的转向次数，每次选择的初始方向可以不同。 $k \\leq 50000, Q \\leq 10^5$ 思考15min… 一个简单的图论建模： 将被障碍分开的若干个连续网格看作一个点，两个点交叉，加一条边权为 $1$ 的边 暴力BFS 考虑数据结构优化，有两个方向 线段树套 set 优化 BFS，我的做法，复杂度两只 log 主席树上建图，复杂度一只 log 大致做法：主席树预处理，树边边权为 $0$ 每个点只会连 $\\log$ 条边，边权为 $0$， 跑BFS","tags":[{"name":"笔记","slug":"笔记","permalink":"https://xuzhean.github.io/tags/笔记/"}]},{"title":"「切题记录」微积分基础","date":"2017-12-31T15:59:52.000Z","path":"2017/12/31/Algorithms-Calculous/","text":"OI 微积分基础 普及一些微积分 常识 基本知识？讲道理选修2-2都有 大概没学过这些东西，多项式理论也看不下去吧… 预备技能极限$\\begin{eqnarray} \\large \\lim _ {x \\rightarrow x_0} f(x) \\end{eqnarray}$ 无穷逼近 时候的值，左极限，右极限 垂直渐进线，水平渐进线 三明治定理 求极限 多项式在 $+ \\infty$ 的极限？首项决定一切 举两个函素的🌰 $\\large \\begin{eqnarray} \\lim _ {x \\rightarrow 0} \\sin(\\frac 1 x)= \\end{eqnarray}$ ？ $\\large \\begin{eqnarray} \\lim _ {x \\rightarrow +\\infty} \\sin(\\frac 1 x)= \\end{eqnarray}$ ？ $\\large \\begin{eqnarray} \\lim _ {x \\rightarrow +\\infty}\\frac {\\sin(x)} {x} \\end{eqnarray} =$ ？ 找到上下界 水平渐进线… 连续性$\\begin{eqnarray} \\large \\lim _ {x \\rightarrow x_0} f(x)=f(x_0) \\end{eqnarray}$ 每个 多项式函数 / 指数函数 / 对数函数 都是连续的 介质定理 ：判断是否有根（记得初中数竞那啥的吧） 最大最小值定理 ：闭区间 $[a,b]$ 存在最大，最小值 微分可导性切线？斜率？ $\\begin{eqnarray} \\large f’(x)=\\lim _ {\\Delta x \\rightarrow 0} \\frac {f(x+\\Delta x) - f(x)} {\\Delta x},f’’(x),\\cdots,f^{(n)}(x) \\end{eqnarray}$ 双侧极限存在且相等 可导函数必定连续 微分还有第二形式 $\\large \\begin{eqnarray} \\frac {\\mathrm{d}y} {\\mathrm{d}x} \\end{eqnarray}$ $y$ 关于 $x$ 的导数 求导的基本法则函数的 $a$ 倍：导数乘以 $a$ 函数和/差：导数求和/差 积法则： $\\begin{eqnarray} \\large h(x)=f(x)g(x), h’(x)=f’(x)g(x)+f(x)g’(x) \\end{eqnarray}$ 商法则： $\\begin{eqnarray} \\large h(x) = \\frac {f(x)} {g(x)}, h’(x) = \\frac {f’(x)g(x)-f(x)g’(x)} {g^2(x)} \\end{eqnarray}$ 链式求导法则： $\\begin{eqnarray} \\large h(x)=f(g(x)),h’(x) = f’(g(x))g’(x) \\end{eqnarray}$ _除了商法则，其他应该都容易感性理解？_ 求导基本法则的证明 至于链式求导法则，写成微分的第二形式，大概就能理解 $\\large \\begin{eqnarray} u=g(x), y=f(u),\\; \\frac {\\mathrm{d}y} {\\mathrm{d}x} = \\frac {\\mathrm{d}y} {\\mathrm{d}u} \\frac {\\mathrm{d}u} {\\mathrm{d}x} \\end{eqnarray}$ 三角函数的导数也是三角函数 （具体规则太多啦…） 多项式如何求导？ 根据积法则，我们可以用数学归纳法推导幂函数的导数 $\\large \\begin{eqnarray} f(x)=x^a,f’(x)=ax^{a-1} \\end{eqnarray}$ 一个性质：一个 $n$ 次多项式的导函数是 $n-1$ 次多项式 是不是很简单 隐函数求导隐函数 ，可以看作是曲线？ 我要求圆的切线方程！ $\\large \\begin{eqnarray} \\frac {\\mathrm{d}} {\\mathrm{d}x}(x^2+y^2) = \\frac {\\mathrm{d}} {\\mathrm{d}x} (r^2) \\end{eqnarray}$ $\\large \\begin{eqnarray} 2x + 2y \\frac {\\mathrm{d}y} {\\mathrm{d}x} = 0\\end{eqnarray}$ $\\large \\begin{eqnarray} \\frac {\\mathrm{d}y} {\\mathrm{d}x} = -\\frac y x \\end{eqnarray}$ 搞定！ 指数函数与对数函数的求导$e$ ? 关于复利 … 奇怪的定义？ $\\begin{eqnarray} \\large e = \\lim _ {x \\rightarrow 0 ^ +} (1 + x) ^{\\frac {1} {x}} \\end{eqnarray} =2.718281828\\cdots$ 复利！ $\\begin{eqnarray} \\large \\lim _ {n \\rightarrow +\\infty}\\left( 1 + \\frac r n \\right)^n = \\lim _ {t \\rightarrow 0^+} (1+t)^{\\frac r t} = e ^ r\\end{eqnarray}$ 奇怪的函数 $\\large \\ln(f(x)), \\exp(f(x))$ 哈，她为什么被称作 自然对数 ？ $\\large \\begin{split} &amp; \\ln’(f(x)) \\\\ =&amp; \\lim _{h \\rightarrow 0} \\frac {\\ln(f(x+h))-\\ln(f(x))} {h}\\\\ =&amp; \\lim _ {h \\rightarrow 0} \\ln(\\frac {f(x+h)}{f(x)}) ^ {\\frac 1 h} \\\\ =&amp; \\lim _ {h \\rightarrow 0} \\ln(1+ \\frac {f’(x)h}{f(x)}) ^ {\\frac 1 h} \\\\ =&amp; \\ln (\\exp{\\Large\\frac {f’(x)} {f(x)}}) \\\\ =&amp; \\frac {f’(x)} {f(x)} \\end{split}$ 是不是炒鸡神奇！ 特别的，当 $f(x)=x$ 时，$\\large \\begin{eqnarray} \\ln’x=\\frac 1 x \\end{eqnarray}$ 对于一般的底数，$\\large \\begin{eqnarray} \\log _b’ x = \\frac 1 {x \\ln b} \\end{eqnarray}$ 考虑 $\\large f(x) = \\exp x$ 的导数 根据之前的结论 $\\begin{eqnarray} \\large \\frac {f’(x)} {f(x)} = \\ln’(\\exp x) = 1\\end{eqnarray}$ 所以 $\\large f’(x) = f(x)=\\exp x$ 对于一般的底数，$\\large (b^x)’=b^x \\ln b$ 积分与微分相对的，是积分 也是一个极限的定义，可以通过极限求解（黎曼和） 定积分$\\large \\begin{eqnarray} \\int _a ^b f(x) dx \\end{eqnarray}$ 几何意义：曲线 $y=f(x)$ ，两条直线 $x=a,x=b$ 与 $x$ 轴围成的有向面积 定积分是一个具体的值 试着求解一下 $\\large \\begin{eqnarray} \\int _ {0} ^ {a} x^2 \\mathrm{d}x \\end{eqnarray}$ （划分为若干个小长方形，然后求极限…） 微积分基本定理 对于连续函数 $f(x)$ ，如果存在 $F(x)$ 满足 $\\large \\begin{eqnarray} F’(x) = f(x) \\end{eqnarray}$ 那么 $\\large \\begin{eqnarray} \\int _ {a} ^ {b} f(x) \\mathrm{d}x = F(b)-F(a) \\end{eqnarray}$ 我们只需要找到 $f(x)$ 的 反导数 数值积分我不会算定积分！ 简单易懂的 数值积分 ，求出近似积分 一个大模版，具体见大白书… 辛普森公式： $\\large \\begin{eqnarray} \\int _ {a} ^ {b} f(x) dx \\approx \\frac {b-a} 6 \\times (f(a)+4f(\\frac {a+b} 2) + f(b)) \\end{eqnarray}$ 主要用途：求各种面积并 123456789101112double simpson(double a, double b)&#123; double c = (a+b) / 2; return (F(a)+4*F(c)+F(b))*(b-a)/6;&#125;double asr(double a, double b, double eps, double A)&#123; double c = (a+b) / 2, L = simpson(a, c), R = simpson(c, b); if (fabs(L+R-A) &lt;= 15*eps) return L+R+(L+R-A)/15.0; return asr(a, c, eps/2, L) + asr(c, b, eps/2, R);&#125;asr(0, 1, eps, simpson(0, 1)); 51Nod 1630 B君的竞技场 我们将竞技场规则简化如下：1. 每个人进入竞技场后，会等概率随机匹配一个人，匹配到的人与当前胜利和失败场数无关。2. 胜利达到 $x$ 场，或失败达到 $y$ 场后，退出竞技场，根据退出时的胜利场数获得奖励，不能中途放弃。3. 水平高的选手，总能战胜水平低的选手，不存在水平相等的人。4. 竞技场有无穷多的人。 B君并不知道自己的水平，你可以认为B君的水平是在所有人中的等概率随机。B君想知道自己退出时期望胜利场数是多少。 $0 &lt; x, y \\leq 20$ 我们假设 B 能战胜 $p$ 的人，显然，我们可以 $O(xy)$ 来算出 B 的期望胜利场数，记为 $f(p)$ … naive的我取 p=0.5 … 求 $f(p)$ 在 $[0,1]$ 的积分即可，我用了自适应辛普森… 似乎直接保存多项式，求定积分也可以… 不定积分$\\large \\begin{eqnarray} \\int f(x)dx \\end{eqnarray}$ 发现没有上下界，事实上，它代表的是 _反导数的集合_ 如果 $F’(x)=f(x)$ ，那么 $\\large \\begin{eqnarray} \\int f(x)dx = F(x)+C\\end{eqnarray}$ 为什么要加上常数 $C$ ？ 发现一个常数的导数为 $0$ ，加上任意的常数得到的函数 $F(x)$ 的导数都是 $f(x)$ 考虑一个多项式 $\\large F(x) = \\sum _ {i=0} ^{n} f_i x^i$ 对他求导，$\\large F’(x) = \\sum _ {i=0} ^ {n-1} f_{i+1} (i+1)x^i$ 所以 $$\\large \\begin{eqnarray} \\int F(x)dx = \\sum _ {i=1} ^{n+1} \\frac {f_{i-1}} {i} x^i +C\\end{eqnarray}$$ 泰勒展开_知其然，知其所以然_ 仿造一个函数 $g(x) \\approx f(x)$ … 考虑先选择一个起点，比如 $(0,f(0))$ ，令 $g(0)=f(0)$ 发现只会存在一个点重合 开始考虑曲线的变化趋势，即导数，保证在此处的导数相等，$g’(0)=f’(0)$ 想进一步精确化，应该考虑凹凸性，就让二者的导数的导数相等，$g’’(0)=f’’(0)$ _我求导的次数越多，不就越接近吗？_ 这是泰勒的想法… 令 $g(x)$ 是一个 $n$ 次多项式函数 ，就能求 $n$ 次导数 一般地，我们假设起点在 $(x_0,f(x_0))$ ，设函数 $g(x)$ ： $\\large g(x) = a_0 + a_1(x-x_0) + a_2(x-x_0)^2 + \\cdots + a_n(x-x_0)^n$ 考虑 $g(x_0),f(x_0)$ 的 $k$ 阶导数相等 先来看看 $h(x) = (x-x_0)^k$ 的导数，我们可以令 $f(x)=x^k,g(x)=x-x_0$ ，$h(x)$ 就是他们的复合函数，根据之前的链式求导法则： $\\large h’(x) = f’(g(x))g’(x) = k(x-x_0)^{k-1} \\times 1 = k(x-x_0)^{k-1}$ $\\large \\begin{eqnarray} f^{(k)}(x_0) = g^{(k)}(x_0) = k!a_k+ \\frac{k!} {1!} a_{k+1}(x_0-x_0) + \\frac {k!} {2!} a_{k+2}(x_0-x_0)^2+\\cdots \\end{eqnarray}$ 也就是说 $\\large \\begin{eqnarray} a_k = \\frac {f^{(k)}(x_0)} {k!} \\end{eqnarray}$ 所以，我们就可以得到 $\\large \\begin{eqnarray} f(x) \\approx g(x) = \\sum _ {i=0} ^{n} \\frac {f^{(i)}(x_0)} {i!} (x-x_0)^i\\end{eqnarray}$ 如果 $g(x)$ 是一个无穷次多项式，那么就可以把 $\\approx$ 改成 $=$ 了 $\\large \\begin{eqnarray} f(x) = g(x) = \\sum _ {i=0} ^{\\infty} \\frac {f^{(i)}(x_0)} {i!} (x-x_0)^i\\end{eqnarray}$ 引入 幂级数，形式幂级数 麦克劳林级数：$x_0=0$ 时的泰勒级数 应用 展开 $\\large \\begin{eqnarray} e^x,\\ln(1+x),\\sin x,\\cos x,\\frac {1}{1-x} \\end{eqnarray}$ 之类奇怪的函数… 得到欧拉定理，$\\large e^{ix} = \\cos x + i \\sin x$ 常用麦克劳林级数表 $\\large \\begin{eqnarray} e ^ {x} = \\sum _ {n = 0} ^ {\\infty} {\\frac {x ^ {n}} {n！}} = 1 + x + {\\frac {x ^ {2} } {2！}} + {\\frac {x ^ {3}} {3！}} + \\cdots \\end{eqnarray}$ $\\large \\begin{eqnarray} \\ln(1-x)&amp;= - \\sum _ {n = 1} ^ {\\infty} {\\frac {x ^ {n}} {n}} = - x- {\\frac {x ^ {2}} {2}} - {\\frac {x ^ {3}} {3}} - \\cdots \\end{eqnarray}$ $\\large \\begin{eqnarray} \\ln(1 + x)= \\sum _ {n = 1} ^ {\\infty}(- 1)^ {n + 1} {\\frac {x ^ {n}} {n}} = x- {\\frac {x ^ {2}} {2}} + { \\frac {x ^ {3}} {3}} - \\cdots \\end{eqnarray}$ $\\large \\begin{eqnarray} \\frac {1} {(1-x)^k} = \\sum _ {n=k-1} ^ {\\infty} \\binom {n} {k} x^{n-k} \\end{eqnarray}$ $\\large \\begin{eqnarray} (1+x)^{\\alpha} = \\sum _ {n=0} ^ {\\infty} \\binom {\\alpha} {n} x^n \\end{eqnarray}$ 其系数是广义二项式系数 $\\large \\begin{eqnarray} \\binom {\\alpha} {n} = \\prod _ {k=1} ^{n} \\frac {\\alpha - k + 1} {k} ,\\;\\alpha \\in \\mathbb{C} \\end{eqnarray}$ 注意柿子 $(4),(5)$ 要求 $|x| &lt; 1$ ，当然形式幂级数就没事啦… 同时，可以发现 $(4)$ 是 $(5)$ 的特例 一些需要注意的事情 $\\large \\ln(1-x)$ 可以由 $\\large \\begin{eqnarray} \\frac 1 {1-x} \\end{eqnarray}$ 积分得到… 而且可以得到它的常数项系数为 $0$ 嘿嘿嘿… $B$ 是伯努利数，$E$ 是欧拉数… 牛顿迭代对于给定的一个函数 $f (x)$ （有单调性？） ，要求一个 $f (x) = 0$ 的根 二分太慢了。。期望 $O(\\log M)$ 引入 牛顿迭代 可选择一个邻近这个根的点作为初始点 $x_0$ , 然后求 $f (x)$ 于 $(x_0, f (x_0))$ 处 切线与 $x$ 轴的交点, 此交点 一般 将更加接近根 $\\large \\begin{eqnarray} x = x_0 - \\frac {f(x)} {f’(x)} \\end{eqnarray}$ 可以看作 泰勒展开式中，我们只取前两项 一般？那么有什么要求呢？ 已经证明，如果是连续的，并且待求的零点是孤立的，那么在零点周围存在一个区域，只要初始值位于这个邻近区域内，那么牛顿法必定收敛。 并且，如果不为 $0$ ， 那么牛顿法将具有平方收敛的性能. 粗略的说，这意味着每迭代一次，牛顿法结果的有效数字将增加一倍 所以差不多是 $O(\\log \\log M)$ 的样子 一个经典的栗子就是开平方… $\\large \\begin{eqnarray} f(x) = x^2 - C \\end{eqnarray}$ 按照 $\\large \\begin{eqnarray} x = x_0 - \\frac {x^2-C} {2x_0} = \\frac {1} {2} (x_0 + \\frac C {x_0}) \\end{eqnarray}$ 不断迭代 一道牛迭+FFT裸题： 51Nod 1166 大数开平方 参考自 神贴 ，大概就是取个倒数，迭代里不用套高精度除法了 我来瞎推一下 此时 $\\large \\begin{eqnarray} f(x) = (\\frac 1 x)^m - C \\end{eqnarray}$ $\\large \\begin{eqnarray} x = x_0 + \\frac {x_0^{-m}-C} {mx^{-m-1}_0} = x_0 + \\frac {x-ax^{m+1}} {m} \\end{eqnarray}$ 搞定！此时变成了单精度除法，乘法用FFT优化 最后求一次倒数，注意可以用倍增牛迭实现 其实没啥用啦… 有啥用？ 多项式的牛顿迭代 求给定多项式 $G(x)$ ，求解一个多项式 $F(x)$ ，满足 $\\large G(F(x)) \\equiv \\bmod x^n$ 假如我们已经知道 $F_{n}(x)$ 满足 $\\large \\begin{eqnarray} G(F_n(x)) \\equiv 0 \\pmod x ^ n \\end{eqnarray}$ 考虑牛顿迭代…可以得到 $\\large \\begin{eqnarray} F_{2n}(x) \\equiv F_{n}(x) - \\frac {G(F_{n}(x))} {G’(F_{n}(x))} \\pmod {x^{2n}} \\end{eqnarray}$ 本质是倍增 每迭代一次精度增加一倍 多项式求逆，多项式开根，多项式求 $\\ln$ ，多项式求 $\\exp$，多项式快速幂，多项式求$\\sin$… 都可以直接推导… 还可解锁更多技能呦","tags":[{"name":"题解","slug":"题解","permalink":"https://xuzhean.github.io/tags/题解/"}]},{"title":"Hello World!","date":"2017-12-31T15:59:50.000Z","path":"2017/12/31/Hello-World!/","text":"你好，世界！","tags":[]}]